<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/">
    <channel>
        <title>少数派 -- Matrix</title>
        <link>https://sspai.com/matrix</link>
        
        <item>
            <id>https://sspai.com/post/105443</id>
            <title>冷静、克制，甚至有些寡淡 关于Apple Creator Studio新图标</title>
            <link>https://sspai.com/post/105443</link>
            <guid isPermaLink="false">https://sspai.com/post/105443</guid>
            <pubDate></pubDate>
            <updated>Thu, 15 Jan 2026 01:52:37 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/14/e72922cd9b4edc09cbcb7cfc687658d7.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>Apple Creator Studio</figcaption></figure><p>昨晚Apple官宣了“Apple Creator Studio” 的诞生，将 Final Cut Pro、Logic Pro 等顶级创作工具整合进一个订阅包。而第一次看到 Apple Creator Studio 展示的新图标时，直观感受是失落的。相比旧版本，它确实不那么好看——至少不是那种让人一眼就觉得精致、个性的好看，极简削弱了原有的细节层次。这次新图标直接展示的“全家桶”皆为深色模式，冷静、克制，甚至有些寡淡，和过去 Final Cut Pro、Logic Pro等软件所呈现的强区分度的色彩以及精致的金属质感形成了鲜明对比，那种创意工具的“气质”正在变弱。</p><figure class="image ss-img-wrapper image_resized" style="width: 629px;"><img src="https://cdnfile.sspai.com/2026/01/14/0f6f2bdda7c5e80b06cf36b76db72d22.JPG?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>历代图标</figcaption></figure><p>一直以来，Apple的创意类软件其实一直是偏“具象”和“拟物”的：场记板、画笔、黑胶母盘，这些元素不仅是装饰，更是一种功能隐喻和专业身份的象征。而现在的新图标更抽象、更符号化，强调形态而非意象，系统一致性盖过单个应用的个性。这种变化本身并不意外，它几乎是 iOS &nbsp;macOS 视觉演进的必然结果——这种风格在不同设备上的适配性明显更强出现在任何Apple设备上时，都不会显得像是“为某一端量身定做”，而是具备一种跨平台的中性气质。而在 Liquid Glass 风格、动态光影以及深浅模式自由切换的系统环境下，旧图标那种各自为政、风格分裂的状态，确实显得不合时宜。</p><figure class="image ss-img-wrapper image_resized" style="width: 619px;"><img src="https://cdnfile.sspai.com/2026/01/14/7a68b0c5120e2341ab9fff36d3adecf7.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p>更值得注意的是，如果把视野放到更远的未来，当这些图标不再只是贴在一块二维平面屏幕上，而是像 Vision Pro 那样，悬浮于空间之中、参与到三维界面和真实环境的交互里，传统拟物风格今天所依赖的优势，反而可能不再成立。现实世界本身已经是“拟物”的，软件再去模拟材质、光影和物理细节，反而容易显得冗余甚至成为干扰。而抽象、符号化的图形在空间中更容易被快速识别，也更容易成为一种新的界面语言。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/14/ee912085cddb620ddf97f3a20bb9bbf5.JPG?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>转向扁平化的iWork</figcaption></figure><figure class="image ss-img-wrapper image_resized" style="width: 627px;"><img src="https://cdnfile.sspai.com/2026/01/14/439d4be81c8ae68ef95094c86255c5c5.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>Google的错误示范</figcaption></figure><p>但同时新图标也令人感到担忧：在今天统一性被推到极致，辨识度是否会成为牺牲品？这条路我们在谷歌身上已经见过一次——模板化、扁平化、多彩但相似的图标体系，最终导致“看起来都像同一个”难以分辨。苹果此次的选择更克制、更高级，但风险是相似的：当所有创意工具都被纳入同一套抽象语言中，它们是否还足够易识别？对于一向重视设计的苹果来说，这或许是一次必要但并不完全令人安心的转向。</p><p>&nbsp;</p>
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://sspai.com/post/105440</id>
            <title>可以不仅仅是主持人：我如何用一些AI技巧打造一个有灵魂的海龟汤平台</title>
            <link>https://sspai.com/post/105440</link>
            <guid isPermaLink="false">https://sspai.com/post/105440</guid>
            <pubDate></pubDate>
            <updated>Wed, 14 Jan 2026 08:51:43 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>&nbsp;</p><blockquote><p>当我们谈论 AI 应用时，往往陷入 RAG (检索增强生成) 或 Prompt Engineering (提示词工程) 的单一维度。但在构建 <a href="https://haiguitang.net/">出前一汤</a> —— 一个多人即时海龟汤推理游戏时，我发现单纯依靠实时推理是远远不够的。</p><p>这一次，我想聊聊我做AI主持海龟汤的心路历程。</p></blockquote><hr /><h2>什么是海龟汤</h2><p>在海龟汤中，展现给玩家的是汤面，真相被称作汤底，这个游戏至少 2 个人才能玩：有一个人是主持人，他在知晓汤底的情况下，对玩家的猜测作出判定，给出是/不是/是或不是/无关的回答。</p><blockquote><p>一位船长下船后，去餐厅喝了一碗海龟汤。 喝完之后，他痛哭流涕，随后自杀了。 请问：为什么？</p></blockquote><p>你可以提问或给出猜测，然后基于得到的反馈，继续猜测，直到找到真相。</p><p>正确答案是：</p><p>船长多年前曾遭遇海难，和船员在荒岛漂流，即将饿死。 当时，一位同伴端来一碗肉汤，说是<strong>“海龟汤”</strong>，船长喝了之后活了下来，但同伴死了。<br />多年后，他在餐厅喝到了真正的海龟汤，发现味道和当年那碗完全不一样。 他瞬间明白了：当年同伴给他吃的根本不是海龟，而是那位死去的同伴自己的肉。 出于巨大的愧疚和绝望，他选择了自杀。</p><h2>从半个小时5美刀到可持续的支出</h2><p>原本做这个网站，就是为了和女朋友一起玩海龟汤。于是用了谷歌的Gemini免费api，基本能应对几个人玩的需求，后来这个网站被抖音的博主发现后宣传了一波，带来了几百人进入网站。</p><p>很显然，这时候免费api无法满足需求。首先我做的是接入到之前搭建好的Gemini key池，但是仍然经不住用户的大量提问。</p><p>为了不让第一批用户流失，我果断接入了openrouter取代key池，结果不到半小时立马花了5美元。</p><p>这对我这个用爱发电的个人开发者来说，简直是破产倒计时。</p><p>痛定思痛，我开始寻找更具性价比的方案。经历了一番漫长的模型“迁徙”——从最初还在实验阶段的 Gemini Thinking Mode，转向了速度极快的 Gemini 2.0 Flash，最后锁定了 <strong>DeepSeek V3.2</strong>。</p><p>最关键的一步是，我利用了 DeepSeek 官方支持的 <strong>Context Caching（上下文缓存）</strong> 技术。海龟汤的规则、汤面设定动辄几千 token，如果每次对话都重复传输，不仅慢，而且都是冤枉钱。通过缓存技术，只需要支付一次“记忆成本”，后续的对话都能复用这段缓存，直接命中了“降本增效”的靶心。</p><p>这一套组合拳下来，成本直接降低了 90% 以上，终于让这个网站能够可持续地运转下去了。</p><h2>从“人工智障”到“全知全能”的困境</h2><p>海龟汤（Lateral Thinking Puzzle）的魅力在于<strong>信息差</strong>。作为主持人，你必须全知全能（知道真相），但又要守口如瓶（只能回答“是/不是”）。</p><p>最初，我直接通过 Prompt 把汤面和汤底塞给 AI：</p><blockquote><p>"你是一个主持人，汤面是... 汤底是... 请回答玩家的问题。"</p></blockquote><p>结果是：</p><ol><li>如果开启思考模式，主持人反应很慢，而且token消耗翻倍</li><li>如果不开思考模式，AI回答的逻辑性很差，很多海龟汤的汤面充满了叙述性诡计。汤底一般都有着复杂的逻辑和人物关系，AI很难在500ms内构建出严谨的逻辑防线</li></ol><p>在几十轮的测试后，我意识到：<strong>让一个 AI 既要理解复杂的谋杀诡计，又要构建严谨的逻辑防线，还要扮演生动的角色，这太强机所难了。</strong></p><p>我们需要把“思考”和“表达”拆开。</p><hr /><h2>走过的弯路：向量检索 (RAG) 的“智障时刻”</h2><p>在设计双层架构之前，我其实先尝试了 <strong>RAG (检索增强生成)</strong> 方案。</p><p>我的设想很完美：做一个“智能缓存层”。</p><ol><li>把每一次玩家的提问和 AI 的回答存入向量数据库</li><li>通过用户反馈和人工干预，标记出正确的回答</li><li>当前 10 次提问积累了足够的数据后，后续玩家如果问了类似的问题，就直接从数据库捞出AI回答最多的答案，或者是人工标记的正确答案，不再消耗 AI Token，还能提高准确度。</li></ol><p><strong>但在海龟汤里，这个方案完败。</strong></p><p>核心原因在于，<strong>向量检索看重的是“语义相似度”，而不是“逻辑精确度”。</strong></p><p>在海龟汤中，玩家经常会进行极为细微的试探：</p><ul><li>玩家 A 问：“他是<strong>自杀</strong>吗？”</li><li>玩家 B 问：“他是<strong>被杀</strong>吗？”</li></ul><p>在向量数据库眼中，这两句话的 Embedding（语义向量）极度相似，甚至可能被判定为同一个意图。<br />如果有一次 AI 回答了“是自杀”，缓存记录了下来。下次有人问“他是被杀吗”，RAG 很可能因为高相似度，直接自信地甩出缓存里的“是”——<strong>瞬间导致游戏逻辑崩塌。</strong></p><p>海龟汤需要的是<strong>字斟句酌的逻辑判定</strong>，而不是<strong>模棱两可的语义搜索</strong>。这次失败让我意识到：<strong>不能依赖概率，必须依赖结构化的逻辑。</strong></p><hr /><h2>核心技术：双层 AI 架构与 Logic Profile</h2><p>为了解决这个问题，我设计了一套 <strong>双层 AI 架构</strong>：</p><h3>Layer 1: The Architect (架构师) —— 离线深思</h3><p>这是系统的核心。每当一道新题库入库时，后台会触发一个高算力模型，我们称之为 <strong>Architect</strong>。</p><p>它的任务不是陪玩家聊天，而是进行<strong>深度逻辑拆解</strong>，生成一份结构化的 **Logic Profile (逻辑档案)**。</p><p>这个过程不需要实时，可以花 30 秒甚至更久。Architect 会思考：</p><ul><li>这个故事的核心诡计是什么？</li><li>到底有哪些物理证据？</li><li>更多我需要的元数据</li></ul><p>最终，它会生成一份包含游戏所有元数据的 JSON 存入数据库</p><h3>Layer 2: The Host (主持人) —— 实时响应</h3><p>当玩家开始游戏时，面对他们的其实是 <strong>Host</strong>。</p><p>Host 不需要消耗大量算力去推理真相，它只需要读取 Architect 预先生成的 Logic Profile。因为最难的逻辑判断已经被“预缓存”了，Host 运行在响应速度极快的模型上，专注处理玩家的自然语言交互。</p><p>这就像游戏开发中的“预渲染”：<strong>把最复杂的计算留在离线阶段，把最流畅的体验留给实时阶段。</strong></p><hr /><h2>✨ 预缓存带来的产品质变</h2><p>这种架构不仅仅是为了省钱或加速，它直接方便了我开发后续的核心功能：</p><h3>1. 通灵召唤与“认知盲区”技术</h3><p>在 <a href="https://haiguitang.net/">出前一汤</a> 中，玩家可以进行<strong>通灵召唤</strong>，抽卡召唤故事里的人物或物品来对话。</p><p>但这有一个巨大的逻辑陷阱：<strong>死者知道自己怎么死的吗？</strong></p><p>如果是被背后偷袭，死者就不应该知道凶手是谁。如果实时让 AI 判断这一点，很容易露馅。<br />但在 Logic Profile 中，Architect 已经预先定义好了每个角色的 <code>认知盲区</code>：</p><p>基于这份档案，Host 在扮演角色时就有了完美的“剧本”。玩家会发现，召唤的角色只会描述自己视角的事情，像是在上演罗生门。</p><p>这种<strong>基于视角的叙事碎片</strong>，正是推理游戏的精髓。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/14/0bd49a1896957be8960c3980f792fe78.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/14/5134e938c000e0ad3d26196b7e7bf38b.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p>&nbsp;</p><h3>2. 现场搜证：有序的随机</h3><p>我们还做了一个类似“刮刮乐”的<strong>现场搜证</strong>功能。玩家面对 6 个档案袋，需要消耗积分刮开线索。</p><p>这 6 个线索不是随机生成的，而是 Architect 精心设计的：</p><ul><li><strong>1 个核心物证</strong>（直接指向凶手）</li><li><strong>3 个侧面线索</strong>（辅助推理）</li><li><strong>2 个干扰项</strong>（专门用来误导玩家）</li></ul><p>如果完全依赖实时 AI 生成，它往往编不出高质量的干扰项。只有通过预生成的 Logic Profile，我们才能保证每一局游戏的体验都是经过“设计”的。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/14/1e89cb6a557dc8fa8a3983893e0e1436.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><hr /><h2>不仅仅是文字：沉浸式体验的打磨</h2><p>除了后端的硬核逻辑，作为独立开发者，我也在前端体验上下足了功夫。</p><h3>调查卷宗与工作台</h3><p>推理游戏最大的乐趣在于整理线索。我不希望玩家还要拿纸笔记录，所以在游戏里内置了一个完整的“侦探工作台”：</p><ul><li><strong>案卷 Tab</strong>：自动收集解锁的文字/图片线索</li><li><strong>物证 Tab</strong>：通过网格视图管理搜证结果，支持打上「关键」「存疑」「排除」的印章</li><li><strong>可视化笔记</strong>：将关键问答像便利贴一样钉在案情白板上</li></ul><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/14/85ad88434ae06a4cefec7d50fcfc0060.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><h3>动态立绘系统</h3><p>利用 Architect 生成的角色描述（Prompt），我们对接了图像生成模型，为每个召唤角色生成专属立绘。<br />为了防止剧透（比如死者不能画得太血腥导致直接看出死法），Architect 的生图 Prompt 遵循一套严格的<strong>美学与防剧透原则</strong></p><hr /><h2>结语：技术服务于沉浸感</h2><p><a href="https://haiguitang.net/">出前一汤</a> 的开发过程让我明白，<strong>AI 原生应用如果不做逻辑分层，很容易变成一个单纯的 Chatbot 壳子。</strong></p><p>通过引入 <strong>Architect (离线深思)</strong> 和 <strong>Host (在线快响)</strong> 的双层架构，利用 <strong>Logic Profile</strong> 将非结构化的故事转化为结构化的游戏数据，我们实际上是在用 AI 模拟人类游戏设计师的工作流。</p><p>这让 AI 能够驾驭海龟汤这种这种极度依赖逻辑闭环和信息差的游戏。</p><p>当然，技术只是手段。当你深夜和朋友在房间里，看着屏幕上“死者”发来的那句充满了遗憾与未知的证词时，那一刻的沉浸感，才是我想带给每一位玩家的礼物。</p><hr /><blockquote><p><strong>One More Thing</strong></p><p>作为一个不需要下载、打开即玩的时候 PWA 应用，出前一汤 完美适配了移动端。</p><p>欢迎来试玩：<a href="https://haiguitang.net/">出前一汤</a></p><p><i>同时也欢迎独立开发者们在评论区交流 AI 应用开发的心得！</i></p></blockquote>
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://sspai.com/post/105375</id>
            <title>人生不同阶段，把握的“财务尺度”不一样</title>
            <link>https://sspai.com/post/105375</link>
            <guid isPermaLink="false">https://sspai.com/post/105375</guid>
            <pubDate></pubDate>
            <updated>Wed, 14 Jan 2026 08:50:47 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>即使作为一个懂得一些财务、也写过很多年代码的人，记账这件事依然让我头疼。我不喜欢传统意义上的「记账」：不是因为它没用，而是因为它<strong>太浪费时间</strong>。但与此同时，我又非常在意一件事，我希望自己能随时知道：</p><ul><li>我现在到底有多少钱？（净资产）</li><li>这个月大概花了多少钱？（现金流）</li><li>资产配置是否合理？（结构）</li><li>过去几个月投资表现如何？（趋势/回报）</li></ul><p>听起来这些都需要“记账”才能得到，但我后来发现：<strong>我们真正想要的不是记账动作，而是这些问题的答案。</strong></p><hr /><h2>1/ 人生不同阶段，把握的“财务尺度”不一样</h2><p>我慢慢意识到：记账是否值得，取决于你现在掌控的资金尺度。</p><p><strong>学生阶段：几千块的尺度</strong></p><p>每个月能动用的钱不多，<strong>节流</strong>很重要。 这时候记录每笔开销很合理，因为每一笔都可能影响你这个月能不能活得舒服。</p><p><strong>工作几年后：几万到几十万的尺度</strong></p><p>工资、奖金、房租、信用卡、基金股票、甚至买房卖房……</p><p>你真正的决策点变成了：</p><ul><li>投资是否合理</li><li>是否有隐性负债</li><li>大额消费会不会伤到现金流</li><li>资产是否分散、有没有风险敞口</li></ul><p>此时，如果你把有限的时间和决策力都用在记录“今天午饭 28 还是 32”，投入产出比很可能不划算。</p><p>你会更需要的是 —— <strong>总览与趋势</strong>。</p><hr /><h2>2/ 传统记账的陷阱：成本高、回报慢、还容易断</h2><p>传统流水记账的逻辑是：</p><blockquote><p>记录每一笔交易 → 分类/标签 → 汇总报表 → 得出结论</p></blockquote><p>问题在于：结论来得太晚，成本却每天都要支付。</p><p>一旦生活节奏变化，漏记几笔就想“算了”，最终断掉。</p><p>所以很多人记账坚持不下来，<strong>不一定是自律问题，而是工具的成本结构问题。</strong></p><hr /><h2>3/ 找到更高效的方法：借用“资产负债表”来管个人财务</h2><p>后来借用了财务会计里最核心的一张表：<strong>资产负债表（Balance Sheet）</strong>。</p><p>它不关心每一笔钱怎么流动（过程），它先回答一个更关键的问题（结果）：</p><blockquote><p><strong>在某个时点，我拥有多少资产、背了多少负债，净资产是多少？</strong></p></blockquote><p>把它搬到个人财务上，方法变得很简单：</p><p><strong>用“盘点”取代“逐笔记录”</strong></p><ul><li>每周/每月盘点一次主要账户余额（银行卡、支付工具、信用卡、投资账户）</li><li>记录重要变动（加薪、还款、买大件、投资加减仓）</li><li>其余零碎消费不用追求完整</li></ul><p>你会惊讶地发现：即使你不记每一笔，也能非常稳定地掌握自己的财务状况。</p><p>因为你得到的是<strong>现实世界的答案</strong>：余额是多少、净资产是多少、趋势如何、结构如何。</p><hr /><h2>4/ iRich 的诞生：把“余额记账法”做成真正好用的 iOS 体验</h2><p>如果你用过表格（Google Sheet/Excel）做资产负债表，你会知道它虽然有效，但不够顺手：要维护、要自己设计、要手动汇率、还要自己更新投资市值。我想要的是：<strong>用最少的输入，得到最清晰的结果。</strong></p><p>这就是 iRich 的定位：<strong>资产校准式净资产仪表盘</strong>。</p><p><strong>1）只记录“重要的财务事项”，留下重点</strong></p><ul><li>你可以给关键变动打标签（比如：#房租 #奖金 #大件 #旅游 #投资加仓）</li><li>你不是在补全流水，而是在给未来复盘留下“关键节点”</li></ul><p><strong>2）用一目了然的报表，做更理性的资产决策</strong></p><ul><li>净资产现状：我现在到底有多少钱/欠多少钱</li><li>净资产趋势：这几个月是在变好还是变差</li><li>资产结构：钱分散在哪些账户/资产类型（现金、储蓄、投资、负债等）</li></ul><p><strong>3）投资资产自动追踪市值：股票/基金/加密货币/贵金属</strong></p><ul><li>你不需要每次都手动查价格、算市值。</li><li>iRich 自动同步价格，帮你把投资资产融入净资产视图里。</li></ul><p><strong>4）多币种资产自动换算</strong></p><ul><li>有外币资产、海外投资、出差常用外币？</li><li>iRich 自动汇率换算，让你始终用统一口径看总资产。</li></ul><p><strong>5）隐私与同步：以本地存储为主，支持 iCloud 多设备同步</strong></p><ul><li>你的财务数据不该为了“方便”付出过高代价。</li><li>iRich 以本地为主，iCloud 同步多设备更新，尽量把控制权交回给用户。</li></ul><hr /><h2>5/ 这样用 iRich：每月盘点一次，日常几乎不打扰</h2><p><strong>第一次（10 分钟）：搭好你的资产负债表</strong></p><ul><li>添加常用钱包：银行卡、支付宝/微信、现金、信用卡；</li><li>添加投资资产：股票/基金/加密/贵金属（按你需要）；</li><li>设置币种与汇率口径；</li><li>遇到关键节点，顺手校准一下；</li><li>还款后、买大件后、出门旅行前、发工资后 30 秒校准一次，就能立刻看到对净资产的影响。</li></ul><p><strong>每月/每周一次（3–5 分钟）：盘点一次资产</strong></p><ul><li>校准主要账户余额；</li><li>看一眼净资产趋势与结构变化；</li><li>记录一两条“本月关键事项”（可选）。</li></ul><p>你会得到一种很舒服的状态：<strong>不用每天记账，但你对自己的财务很有数。</strong></p><hr /><h2>6/ 结语：高效记账的本质，是把时间花在“尺度更大的问题”上</h2><p>当你的财务尺度从“每顿饭多少钱”变成“我的净资产趋势如何”，你需要的工具也应该改变。</p><p>流水记账不是错，只是它的成本不一定适合每个人、每个阶段。</p><p>如果你想用更少的时间换来更稳定的掌控感 —— <strong>资产负债表式的盘点（余额校准）会是更现实的解法。</strong></p><p>而 iRich，就是为了把这条路做得更轻、更顺、更长期。</p><h2>7/ 最后：感谢你读到这里，邀请你来体验 iRich</h2><p>如果你能读到这里，真的很感谢你。</p><p>愿意花时间认真思考“怎样更高效地掌握财务”，本身就是一种很稀缺的能力 —— 很多人不是不想变好，而是从来没停下来把问题想清楚。</p><p><strong>如果你也认同：与其每天把时间花在记录零碎消费，不如用更低成本长期掌握净资产现状与趋势</strong>，那我想认真邀请你来体验 <strong>iRich</strong>。</p><p>你可以这样开始：</p><ol><li>去 App Store 下载 <strong>iRich&nbsp;</strong></li><li>用 10 分钟把你的主要账户搭好（银行卡/支付工具/信用卡/投资）</li><li>之后每周或每月盘点一次余额，看看净资产与趋势就够了</li></ol><span class="ss-application">&nbsp;</span><p>&nbsp;</p><p>另外，如果你愿意支持我们：</p><p>在 iRich 的 App 页面里能找到我的联系方式。<strong>找到我，并告诉我你是从这篇文章来的</strong>（你也可以说暗号：<strong>“少数派”</strong>），我会<strong>赠送你一份 iRich Pro 体验会员</strong>，希望 iRich 能成为你生活里那种 —— <strong>不打扰，但很可靠</strong>的个人资产仪表盘。</p>
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://sspai.com/post/105423</id>
            <title>不不不，你玩的那个游戏根本不叫“雷电3”</title>
            <link>https://sspai.com/post/105423</link>
            <guid isPermaLink="false">https://sspai.com/post/105423</guid>
            <pubDate></pubDate>
            <updated>Tue, 13 Jan 2026 13:27:29 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <blockquote><p>本文是11年前《让我们重新认识一下“雷电3”》的重制版。</p></blockquote><p>2023年12月12日，《恶魔之星》（Demonstar）重制版《Demonstar Original Massions》正式上架Steam平台，国区首发价42元，目前售价15元。</p><p>即便是2023的我，看到这款快30年前成为我电子游戏人生启蒙的作品，以更精良的画面和高兼容度重见天日，不可能不感到兴奋。</p><p>可能有茫茫多人对这个名字感到十分陌生。但当我叫出它的另一个诨名时，你可能会恍然大悟：</p><p>“雷电3”。</p><p>并且事实上，《恶魔之星》跟《雷电》系列还真的有那么一点点渊源。</p><h2><strong>既然有点渊源，那就先从《雷电》系列开始讲起吧。</strong></h2><p>第一代《雷电》（Raiden）于1990年发售，是由西武开发（有限会社セイブ開発，以下简称“西武”）旗下街机游戏部门开发并出品的一款纵向卷轴射击游戏，最早面向街机机台，一年后移植到了当时的各大家用机和PC平台之上，包括世嘉MD、NEC PC Engine、富士通FM TOWNS和任天堂SFC等设备，后来还囊括了IBM PC兼容机和雅达利Jaguar主机。</p><p>这类卷轴射击游戏有一些共同的特点：玩家操控战机或角色，在有限的游戏显示区域内闪转腾挪，消灭敌人和Boss，还要不断躲避敌人的飞弹。这其中的大部分游戏，玩家能在游玩过程中拾取积分、武器升级和其他道具。《19XX》系列、《雷电》系列、“东方Project”企划和《怒首领蜂》（怒首領蜂，DoDonPachi）系列都是该领域的知名作品。</p><p>根据维基百科，《雷电》因其相较于其他卷轴射击游戏更易上手而获得热捧。尽管后来的同类型射击游戏并非全都以《雷电》为蓝本进行开发，但在玩家圈子中，大家都认为《雷电》已经成为这类游戏的事实标准。在《雷电》之后推出的纵向卷轴射击游戏，社区都免不了和《雷电》系列比上一番。</p><p>很快，西武在1993年推出《雷电II》，首发面向街机机台，并在1995年之后推出了PlayStation平台和Windows 95系统的移植版。相较前作，《雷电II》新增了机体升级系统和两种新的战场装备，提升了战斗的激烈程度，因此保持了前作积累起来的热度；1994年，西武在《雷电II》的基础上制作了增强版《雷电DX》，同样首发面向街机机台，随后移植到PlayStation家用机平台上。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/13/5424fbeed9f709b2ad2d10b6cad723d2.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>相信不少人已经非常熟悉这几个画面了。来源：作者截图</figcaption></figure><p>《雷电》系列有许多和其他卷轴射击游戏不一样的设计。最特别的当属战场武器升级。在当时，包括《雷电II》之后的大部分卷轴射击游戏，都遵循一台机体只有一种主武器的设计，玩家在游戏时捡到了战场升级，只会将已有的武器升级至更高威力。如果玩家想要变换主武器，需要在开始游戏之前选定合适的机体或角色。但在《雷电》中，机体和武器并非直接绑定，而是需要通过拾取战场上的不同武器来变换形态。</p><p>在《雷电II》中，玩家能够在战场上获得三种不同类型的主武器，玩家们一般称为“红弹”、“蓝弹”和“紫弹”。这三种武器会集成在同一个武器升级道具里，颜色每隔几秒变一次。这就要求玩家如果想要升级已经装备的武器，需要在精准躲避敌人弹幕的前提之下，算好拾取道具的时机。这大大增加了游戏的随机性，也给予了玩家反复挑战的乐趣。</p><p>企业有意拓展IP广度以扩大受众是理所当然之事。所以在1995年之后，西武以《雷电》系列为核心，分别开发了外传性质的作品《毒蛇任务1》（Viper Phase 1，1995），以及《雷电战机》（Raiden Fighters，1996~1998）系列。</p><p>好景不长，西武开发街机游戏部门在1999年解散，《雷电》这一IP也迎来了漫长的冬眠期。</p><h2><strong>《恶魔之星》的出现</strong></h2><p>在聊《恶魔之星》之前，我想先聊聊“共享游戏”这个概念。因为《恶魔之星》在1997年推出时就是以共享游戏的方式发行的。</p><p>和共享软件类似，共享游戏已经具备了完整的游戏玩法和关卡，且游戏的开头部分或前几章都能够免费体验。用户试玩之后，若想体验后续的完整内容，再进行一次性的支付。</p><p>这是非常多北美小型软件和游戏公司维持业务发展的经营模式。包括3D Realms、Epic Games和id Software都采用这种方式销售他们的游戏，并在必要的展会上通过BBS分发他们的共享游戏。</p><p>共享游戏在当时能够流行开来，少不了存储介质形态的影响。虽然CD-ROM开始在20世纪90年代末迅速崛起，但3.5英软盘仍然具备成本和数量优势，一张散装空盘的价格甚至可以低于1美元。且单张1.44MB的容量对于小型游戏开发商而言，能够装下游戏将近1/4甚至1/3的内容。这就使得总体积不超过10MB的《恶魔之星》完全能够以共享游戏的面貌示人。</p><p>《恶魔之星》的开发者Scott Host完全经历了PC游戏还是小作坊的年代。根据维基百科，最早他和伙伴们一同创立了Cygnus Studios并开发了几款游戏。90年代初期，他们和Apogee Software（也就是3D Realms）达成合作，共同完成了一些作品，包括著名的《毁灭公爵2》（Duke Nukem II）。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/13/3bf8aa645c7ccfdf5f5d564c97e86cb9.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>实体版《毁灭公爵2》封面。来源：Steam</figcaption></figure><p>之后，Cygnus Studios受到id Software的邀请，公司搬迁至德克萨斯州并开始合作开发游戏，同样包括大名鼎鼎的《毁灭战士》（Doom）。1994年底，在Scott Host和伙伴们分道扬镳，公司在迁回芝加哥之后，工作室便改名为Mountain King Studios，也就是《恶魔之星》爱好者们口中常提到的“山王工作室”。在沉寂了三年之后，由山王工作室制作并发行的《恶魔之星》正式诞生。</p><p>1997年发行的《恶魔之星》是Cygnus Studios第一款游戏《Galactix》的正统续作，与《Galactix》共享同一世界观，游戏玩法和画面也经过了全面升级。《恶魔之星》具备所有纵向卷轴射击游戏的所有特质，但难度相对较高，也更加上瘾。</p><p>事实上，《恶魔之星》在玩法设计上和《雷电》系列及其衍生作品高度相似。比如在游戏中，命中特殊敌人会掉落的各类升级道具，包括不同颜色的主武器、追踪飞弹和大型炸弹，以及防御护盾等。此外，《恶魔之星》的关卡中也有不少和《雷电》类似的，总会抵近射击的敌机，和高度相似的弹幕之类的设计。从这几点看来，尽管官方并未出面解释，但《恶魔之星》的玩法确实很容易让人联想起《雷电》系列，而不是将其看作是一款完全原创的卷轴射击游戏。</p><p>不过《恶魔之星》也有着独属于自己的有趣设计。像是第一关的关底Boss，玩家可以先不进行攻击，而是找个版边等一小会儿，就会发现Boss的攻击手段开始失效，不出一分钟Boss就会完全失去攻击能力。这时玩家就可以按照自己的方式鱼肉Boss了。</p><p>在2002年和2003年，山王工作室还分别发行了《恶魔之星：隐秘任务1》（Demonstar Secret Missions 1）和《恶魔之星：隐秘任务2》（Demonstar Secret Missions 2），这两款游戏仅有PC版，目前只在山王工作室的官网上销售。从网上的通关视频来看，这两款游戏在美术上堆料更猛，同屏敌人和弹幕数量也成倍增加，对于弹幕射击游戏高手来说，非常适合拿来当作自己的下一个挑战项目。这两款游戏很有可能在未来推出重制版，喜欢《恶魔之星》系列的朋友们不妨等一等。</p><p>在世纪之交的那几年，这类小型工作室不仅会自主制作和发行游戏，也会帮助其他小型工作室发行游戏。因此山王工作室除了自行开发并发行过7款游戏之外，也负责过两款第三方游戏的发行工作。2004年之后，山王工作室不再制作和发行新游戏，这家小公司自此完全离开了公众视野。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/13/85882a04a7a7b772395994d8d8e2fa3a.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>《恶魔之星》最初的样子，眼熟吧？来源：作者截图</figcaption></figure><h2><strong>难，甚至难上加难</strong></h2><p>让我们把时间再调到2023年年底。对于在十几年前就知道此“雷电3”就是个“冒牌货”，并开始逐渐熟悉整个卷轴射击游戏这个品类的笔者而言，这款《恶魔之星》重制版就是我的绝佳圣诞礼物。</p><p>包括动作游戏和卷轴射击游戏这些强调反应和记忆力的游戏，我玩的一直都不好，跟网上那些一命通关的大神相比，我完完全全就是个菜鸡。并且我玩的时候确实会因为各种各样的突发状况气到砸手柄砸键盘，但我一向人菜瘾大；加上网上的相关内容通常都是一命通关的视频，这就容易给人一种“我上我也行”的错觉。然而，《恶魔之星》从来都不是一款简单的卷轴射击游戏。</p><p>经典版《恶魔之星》在2003年经历过一次重制，以适应更新的Windows系统，但游戏玩法本身没有进行任何修改。2023年的《恶魔之星》重制版支持高刷新率，大幅提升画质与特效，也对玩法进行了大刀阔斧的变革。而且，中文互联网上的一些弹幕射击游戏大神也直接参与到了《恶魔之星》重制版和相关作品的内测和QA过程中。</p><p>在经典版《恶魔之星》的中期，关卡敌人和弹幕就开始变得非常密集，并且由于多数敌人都会针对玩家机体的位置发射子弹，因此在混乱的游戏画面中找到自己的生存空间就变得非常艰难。加上拾取不同颜色主武器时威力会退回最低值的设计，导致游戏在中后期会对玩家造成相当大的闯关压力。对关卡流程不熟悉的玩家往往会在游戏中后期送掉好几条命。</p><p>此外，在绝大多数日本厂商开发的卷轴射击游戏中，玩家操作的机体或者角色的有效碰撞体积非常小，这个碰撞点通常会有一个非常显眼的标记，比如一颗发光的点来表示。但是在《恶魔之星》中，玩家操控的机体本身，是一个完整的碰撞模型。也就是说，这款游戏不存在传统意义上的“擦弹”技巧，玩家看到敌人的飞弹，能做的就是让机体完全躲开，蹭上就会掉血甚至机毁人亡。</p><p>《恶魔之星》重制版则在此基础上增加了诸多限制，不过开发者Scott Host仍在持续更新，游戏机制和首发时期又有了一些变化，但难度仍然比经典版《恶魔之星》高出不少。</p><p>首先，游戏降低了初始主武器的威力，但是平衡了流程中可拾取的不同颜色的武器的威力，这个改动更加鼓励玩家在拾取同样颜色的武器之后，尽可能不要出现操作失误而丢命或不小心拾取其他颜色的武器，毕竟重生的机体只有初始火炮，威力有限，随着关卡难度不断提升，敌机种类和血量的增加，玩家的通关压力也会随之增大。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/13/8f0df4b3336fdecb67316b92a73d5ba9.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>《恶魔之星》重制版的新机制：恶魔之星黑洞。来源：作者截图</figcaption></figure><p>其次，游戏降低了主武器的远距离火力，这个设计也影响到升级过的主武器。玩家因此需要频繁在敌机之间游走，最大化利用近距离的火炮威力快速清剿敌机，否则就会深陷重围。但由于《恶魔之星》重制版不论键盘、鼠标还是手柄操作，都会带有一点点“粘滞感”，不像《雷电》系列或《怒首领蜂》系列那般干脆，不熟悉关卡的玩家在面对大量敌机和必杀场景时肯定会较为被动。</p><p>在最新的《恶魔之星》v1.1版本中，自机一旦遭到撞击掉血，还会撞掉武器等级，导致后续火力输出不足，这对玩家的操作提出了更高的要求。</p><p>《恶魔之星》重制版也增加了《隐秘任务》系列里才有的设计。其一是玩家的机体在持续一段时间不射击后会缓慢自动回血，其二是在自机满血前提下拾取回血道具和额外的特殊道具会生成无敌护盾。这两项机制看似有用，但在实际游戏体验中，只能说聊胜于无吧。</p><p>《恶魔之星》重制版还增加了“恶魔之星黑洞”这一全新机制。如果玩家在关卡中快速、频繁、且无伤地击落敌机并拾取了所有场上的升级道具，就会触发恶魔之星黑洞。恶魔之星黑洞会根据关卡背景音乐的节拍发射飞弹，对本就混乱的战场制造更多压力，所以玩家也要控制自己在高压场景下不要过于激进地战斗。</p><p>这里不得不岔开说一句，《恶魔之星》重制版的音乐真的非常好听。由Pfeffermouse操刀制作的原声带大大提升了整个游戏的沉浸感，甚至给整个游戏注入了全新的活力。</p><p>虽然《恶魔之星》重制版变得更难了，但完整保留了经典版《恶魔之星》的所有内容，包括关卡和背景音乐，玩家可以在设置里切换成经典模式，重温几十年前，原汁原味的《恶魔之星》游戏。相较之下，原版游戏要比重制版简单不少。不过，原版《恶魔之星》中第一关开头直达第七关的黑洞被取消了，如果想要跳关，需要先完整通关一遍，才能在设置菜单里选择关卡。</p><h2><strong>“纠错”并不容易，尤其是日薄西山的小众品类</strong></h2><p>西武倒闭之后，《雷电》系列的部分开发元老加入MOSS，继续《雷电》系列新作的开发。或许是将系列从2D画面带到3D画面所消耗的精力和资源比想象中多得多，《雷电III》直到2005年才正式推出。这段空窗期也似乎让《恶魔之星》坐实了玩家心目中“雷电3”的位置。</p><p>尽管卡普空和SNK的正版和盗版机台几乎是以碾压之姿称霸早期中国大陆的街机市场，但这不代表街机厅老板不希望引进其他类型的游戏，以扩大街机厅受众。像是《19XX》《雷电》这类卷轴射击游戏的机台确实会出现在国内街机房中显眼或者不显眼的位置。</p><p>包机房则是《雷电》系列发光发热的另一大阵地。尽管不如《生化危机》和《实况足球》具有统治级地位，但前两款游戏可并不像《雷电》那样能带来最即时的快感。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/13/7f013e001e5cb41f165089e04a37d28a.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>现在的“包机房”不仅转正，而且变成了玩家们难得的交流分享兴趣的线下社区。来源：bilibili@某天的游戏小屋</figcaption></figure><p>我相信，尽管不如卡普空、SNK和KONAMI的游戏那般爆火，但《雷电》系列终究是影响到了不少出入街机厅和包机房的老老少少。而这，也一定是盗版软件厂商将《恶魔之星》的中文名乱改成“雷电3”的重要原因。</p><p>在“雷电”面前，《恶魔之星》这个名字不仅拗口，还不好记，而且根本没人听说过这个东西。大家手里的闲钱都是有限的，要玩就要玩最好的，即便一张盗版PC游戏光碟在当时只需要五元钱。</p><p>就这样，“雷电3”开始出现在电脑城，出现在“XX合1”的PC盗版游戏碟中，与“共和国之辉”，“抢滩登陆战”等游戏一起，肩负起启蒙90后和95后的大任。它教会了许多人怎么用鼠标控制飞机，教会了许多人怎么使用光标键，让许多人认识到PC游戏究竟是一个什么东西。它让人上瘾，让人快乐，也让人气到砸鼠标砸键盘。一部分接受了启蒙的人们，认定了它就是“雷电3”。</p><p>当然，随着互联网日益发达，现在还对卷轴射击游戏有热情的玩家和社区，早已知道此“雷电3”非彼《雷电3》。而且，现在也有一些人看到《恶魔之星》的通关视频之后，发现自己曾经玩过的就是真的《雷电III》。</p><p>实际上，中国曾确实引进过正版的《雷电III》PC版游戏，由智冠科技代理发行，但那已经是2007年的事情了。直到2014年，《雷电III》才正式登录Steam。目前能在Steam和其他平台上买到的，则是2023年推出的《Raiden III x MIKADO MANIAX》重制版，国区售价108元。</p><p>不过，现在还是有人只知道那个跟《雷电》系列有那么一捏捏关系的“雷电3”，而完全不知道它的真名，也不知道《雷电》系列，即便“Demonstar”这几个大字就明晃晃地贴在游戏的开始界面上。当他们打开视频网站，看到各种各样“《雷电3》一命通关视频”之后，才突然意识到：“这好像和我小时候玩的，完全不是一个东西啊！”</p><p>作为电子游戏大领域下一个日渐小众的品类，几乎每一名社区成员都会耐心地回复他们，这才是真的《雷电3》，你玩的那个，叫《恶魔之星》。</p><p><i>（头图来源：作者截图）</i></p>
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://sspai.com/post/105385</id>
            <title>活着就挺好｜2025 年度总结/这些年的感悟</title>
            <link>https://sspai.com/post/105385</link>
            <guid isPermaLink="false">https://sspai.com/post/105385</guid>
            <pubDate></pubDate>
            <updated>Tue, 13 Jan 2026 08:33:44 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>前几天读到了一篇很赞的年度回顾文章，深受触动。因为是在少数派读到的，故将自己的处女作写在这里。</p><span class="ss-linkCard">&nbsp;</span><p>2025年，最大的感受莫过于：<strong>活着就挺好</strong>。这一年，我失去了一个好朋友，猝不及防。好友的突然离去，让我深刻感受到：<strong>意外与明天不知道哪个先来</strong>。从朋友的朋友的朋友的故事，到自己身边的朋友，从听说到亲身经历，这种触动是抵达内心深处的，是每每想起都会泪流满面。</p><p>第一次写年度总结，就按照同一作者参考的古典老师 <strong>生命之花模型 八个版块</strong>来做人生复盘吧。</p><span class="ss-linkCard">&nbsp;</span><h3><strong>一、职业发展</strong></h3><p>先写职业，是因为这一年，我超过50%的时间都在工作，工作占据了我最多最多的时间和精力。当然，也是有收获的，年收入达到目前为止的最高值（但平均每小时的收益估计是历史最低值）。</p><p>2024年10月底，我入职了现在的公司，因上家公司无法正常发放工资，幸得朋友推荐来到现在的公司。毕业以来，一直是产品经理岗，但当时只有解决方案/售前岗位，在大环境不景气的情况下，想的是：有总比没有好，解决方案能多接触客户，了解客户需求有助于更好的做产品，况且能够积累人脉，也挺好的。然而，实际情况与理想总有那么点偏差：虽然还是有铁路/机场的业务，但入职以来一半以上的精力都在城市交通，在半年后完全转到了城市交通，从to B 到了to G，这么说起来，职位、行业、工作内容都改变了。唯一不变的，可能就是都算是AI相关的。</p><p>这一年，工作带给自己最大的感受是痛苦+难受。年初因为刚入职，有新人期且新岗位的投标工作是第一次接触，项目多+任务急，有点应接不暇，是痛苦的。年底，在做些非本职的项目经理工作，很基础的文档工作及多方沟通协调，是难受的。过程中，有些忘记具体情况了，翻看之前写的随笔，发现<i>一年总共写了几篇，多半都在分析这份工作的利与弊。</i>【<strong>Curious about everything</strong>】写在入职介绍中的话语与现实形成巨大反差。工作内容没有创造性，多是基础的文档工作，可替代性强，是不喜欢的最根本原因。工作中没有主动权和话语权，完完全全是个螺丝钉🔩，这让自己很难主动投入其中，之前领导宣贯的“做自己产品的owner”，更是无从谈起，<i>没有基础条件便没有主动意识，空有责任心也只是对一项工作，而非项目本身</i>。</p><p><strong>生命诚可贵，何必如此消耗自己。</strong></p><h3>二、爱情家庭</h3><p>这一年，除了工作外，其余精力多在家庭。虽然付出的还是非常少。</p><h4>1.房子</h4><p><strong>今年家里最大的事：卖房。</strong></p><p>2月底挂牌，12月初卖掉，较买价亏损40%。挂牌到卖出的这10个月，市场一直在降，我们这房子降了有80万，心里预期也一直在降，最后成交价较预期低了约15万。可能10月份早一点降价，能多卖30万，这估计也是能卖到的最高价了。但没办法，12月才有人出价。</p><p>和老公一起走进链家会议室到离开，似乎没有太大的心理波动，整体来说很平静，完全没有卖房的喜悦，更多的是无奈，受市场影响，对房价的无奈。中间谈判过程，我们想过，这么低的价格不卖了，这10个月以来，这个想法也在反复。最终决定卖，是觉得：这房子早晚都是卖，并且老破小的房子没有升值空间，况且见证了这一年来房价的持续下跌，之后可能会更低；五层的楼梯房，每周末都有人来看房，精装修的房子看了都说好，但却一直没有人出价，好不容易遇到出价的人，那就卖了吧。</p><p><strong>关于房子的第二件事：新房。</strong></p><p>3月份开始看房，随意走进一个新房售楼处之后，决定：买新房。LDK格局太好了，第四代住宅设计的太好了。</p><p>2个月看了北京全城一二十个新楼盘之后，在五一假期的最后一天付了定金。我们一直是坚持卖了再买的原则，以首套资格来买房（那会首套二套利率不一样）。五一出去玩了，最后一天接到链家和售楼处的多通电话，说有优惠政策，在迷茫中走进售楼处，谈到了晚上，最终还是付了定金。与卖房时类似，我和老公都没有买房的喜悦，反而更多的是忐忑，“买对了吗？”。</p><p>庆幸！我们虽付了定金，但依然保持清醒，在各种优惠下，虽曾经徘徊，但依旧没有网签。新房市场也不好，新楼盘的去化率非常低，根本不用着急。在9月下旬，做出决定：申请退款，先不买了，卖了再说，不着急。（到目前为止，退款还未到账，相信很快了。）</p><p><strong>再来聊一下房贷</strong></p><p>刚刚看了“人物”一篇关于房贷的文章，和老公聊了下彼此的感受，觉得很有必要记录在此，因为房贷对我们来说，也非常重要。</p><p>刚工作没多久我们就结婚买房了，所以我们算是一直与房贷相伴生活。前几年真的非常拮据，刚工作收入低，除了房贷，还欠着亲戚的一些钱，差不多三年吧，把亲戚的钱还清，也买了车，生活逐渐正常起来。那会觉得先还完欠的钱，再怀孕，避免生娃后开支大、压力大，现在想想当时的想法有点可笑，哈哈。我和老公的消费习惯大体是相同的，正常生活的轨迹，没有那么拮据<sup class="ss-footnote" href="" title="很重要的一点是因为，我们在贷款时就留有余地，不让自己太拮据。">1</sup>，也没有随心所欲，想干啥干啥，就是正常的与房贷相伴而行。接下来我们开始提前还贷，记得那会在坐月子，听老公说能提前还贷，问了同事，发现他们一年前已经开始如此操作了。就这样，每个季度攒一笔钱，就申请提前还贷，又还了三年，商贷还清了。公积金贷款没多少，积累到可以还清的程度，便开始考虑卖房、换房。</p><p><strong>真的是传统的中国人，一直不停歇的倒腾房子。</strong></p><h4>2.育儿</h4><p><strong>家里第二件大事：儿子上学了。</strong></p><p>两岁到三岁是褪去婴儿感，三岁到四岁则逐渐成为一个小大人，有自己的主意与认知，有自己的一套规则，开始去思考，已不可能忽悠他，反而要听他的安排。</p><p>这一年有过两次育儿焦虑。一次是游泳课，那是上学前一个月，是他第一次接触老师，接触家庭以外的教育环境，他想玩，不听老师教导且打了老师一下，老师有些无奈，有点无法管教他。我当时有点担心儿子无法融入外面的环境，担心儿子是不是太不听话，我们没有教育好等等。第二次是幼儿园吃饭，那是幼儿园正式上学前的家长陪同期，他坐不住，东张西望，想玩，不能专注于吃饭，且有点挑食。我当时有点焦虑于没有从小培养他独立、专注吃饭的好习惯。</p><p><strong>小朋友的成长是很神奇的，他完全可以自己适应环境。</strong>在第15次游泳课时，发生了质的改变，他喜欢上了游泳，喜欢淋水、潜水，也可以憋气了，战胜了心理对水和未知的恐惧。现在上了35节课了，已经学会了自救，踢腿和划手也逐渐熟练起来。<strong>还好妈妈没放弃！</strong>第一次报了20节课，每次上课如上刑，特别费劲，好几次边哭边游，本想着游完算了，以后大了再学吧，没想到在第15次发生了质变。第一次的课外班，好在妈妈没放弃。</p><p><code><strong>老师不合适，咱就换；心理有恐惧，咱就慢慢克服；进度慢，咱就慢慢来。学习有困难，咱就坚持试试，坚持了若不行，咱就以后再学，坚持了若可以，妈妈就挺你到底。一切都是可以解决的。</strong></code></p><p>上学不到一个月，吃饭的问题就解决了。饭量一直保持并列第一或第二名，次次光盘，不再挑食。元旦学校活动时，看到你吃饭的样子，左一口右一口，专注于吃饭，看到妈妈正在看你，跟妈妈打招呼<sup class="ss-footnote" href="" title="如果是以前，就跑来找妈妈，或者开始哼唧了。">2</sup>，继续专注于吃饭，妈妈真的很欣慰。在家吃饭也好多了，虽偶尔还是想着下饭桌玩，但多数时间可以坐下来大口吃饭，并光盘。在幼儿园真的养成了很多好习惯：洗最干净的手，谢谢水龙头，打招呼，独自午睡。上厕所、穿衣服，这些倒是上学前就会了。<i>有些习惯需要再加强：打招呼、勤洗手、多漱口、收拾玩具等。有些行为需要改进：生气会打人、抠人甚至咬人。经过和老师交流，这些行为习惯在学校都做的很好，在家和学校共同的点在于：磨叽、不着急。咱们学校家里共进步吧。</i></p><p>说起育儿，自己有些惭愧，虽然已经在尽可能的陪伴儿子<sup class="ss-footnote" href="" title="每天送儿子上学，尽可能接儿子放学，每晚陪儿子睡觉，周末都在陪儿子。">3</sup>，被老师认可为非常用心负责的家长，参加幼儿园所有活动，但总觉得还是不够，<strong>尤其是教育方面</strong>，没有做到每晚的教育，估计这一年勉强能平均到每周一到两次。买的奇奇学英语课很久没学了，绘本多数在吃灰，偶尔会带儿子画画，学习逻辑思维的书，多半是儿子自己玩他的一堆车车。有时甚至为了和平共处，他看动画片我加班。。。感谢幼儿园的教育，爱国教育、传统国学、食素食养、阳光体育、自主游戏，学唱歌、读绘本、做游戏，跑酷、画画、科学小实验，职业、安全等各方面的知识，多谢幼儿园和各位老师，弥补了妈妈教育精力投入较少的遗憾。新的一年，自己多读些育儿书，在儿子的教育方面投入精力，陪伴儿子逐渐改掉偶尔赖唧的习惯，可以足够自信、落落大方的在大家面前讲话。</p><p><code>👇下面这是儿子眼中的中国。北京第一场大雪，和儿子一起堆⛄️，堆好一个雪堆后他不让在上面再放个雪球，而是去找树枝插上，说：这是中国🇨🇳，还讲了中国战胜日本，中国人独立自强的故事。突然的一段讲述，老母亲非常震惊。后面有次去玩沙子，堆起来也是要插根树枝🌿作为国旗。</code></p><figure class="image ss-img-wrapper image_resized" style="width: 212px;"><img src="https://cdnfile.sspai.com/2026/01/13/db4f38458b5b611ac656fc2d16c48ed7.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>儿子说：这是中国🇨🇳</figcaption></figure><blockquote><p>陪伴小朋友成长，也是我们再一次成长的过程，重拾已忘记的童年。</p><p>这段陪伴成长的旅程，让我认识到：</p><p>世界原本的样子，原没有黑白，是我们定义了黑白；</p><p>可以不必着急，是我们太在意外在的声音，忘记了对自我本体的关注；</p><p>我们的不开心往往是因为事情没有按照我们的预期来行进。</p><p>慢一点，耐心再耐心一点，听听孩子的诉求，而非让他按照我们的想法去做事，框个大点的边界就可以。</p></blockquote><h4>3.爱情婚姻</h4><p>这一年，属于我和老公的专属二人世界，寥寥无几。就更别提两个人花前月下的时间了，即使是两个人，可能多数时间也在讨论房子、儿子和工作。</p><p>回顾这些年，上学时的暧昧期热恋期太美好了，虽然时常吵架，但正是这份小吵小闹加深了彼此的认识。住在一起，更要彼此适应，也免不了争吵，但更多的是互相体谅与包容。再后来有了小朋友，更多是围着他转，刚开始还挤时间单独相处，后来逐渐习惯了这种生活方式，俩个人的时间越来越少。已经记不清有多少年没吵架了，在一起久了就是过日子。已经不会为了忘记纪念日而生气，忘记就忘了吧，不会为了特殊的日子而精心准备，自己也没了那么多仪式感。现在对生活、物质没有那么大欲望了，很难因为一个礼物或举动而十分开心。</p><p>以前看到很多文章都称对方为“队友”，现在想想这个称呼多么亲切啊，一起组队升级打怪的好友。我们逐渐成为最懂彼此的那个人，了解对方的成长经历、现在的生活习惯与喜好，工作中的开心与难过，认识彼此身边的好友，建立了比血缘更牢固的纽带。是啊，我们也是彼此生命中陪伴最久的那个人，这是多么神奇的缘分。</p><p>新的一年，希望我们可以在柴米油盐的日子里，增加点甜品，酸的也不错。</p><h4>4.家人</h4><p>在有小朋友之后，多了跟老妈生活在一起的日子。这一年每次见爸妈都会发现他们比上次更衰老了一点，也认识到两代人的差距越来越大，共同话题越来越少，更多的是日常的嘘寒问暖。有了解到一些朋友的童年及电视剧里的一些情节，非常感谢爸妈，他们给予我无私的爱，老爸的鼓励式教育给予我充足的自信，虽然和老妈有争吵，但更多的是爱。因为爱，即使共处久了会吵架，隔段时间还是很想他们，想让老妈来住住，虽然带老妈出去旅游她爱唠叨，当下都会想下次不带她出来了，但隔段时间又会想多带她出去逛逛。在生娃的那几天，切身体会到老妈说的：<strong>孩生日娘苦日</strong>。</p><p><strong>希望父母身体健康。</strong></p><h3>三、个人健康</h3><p>这一年，我胖了15斤，又回到了巅峰时期。</p><p>跑步、普拉提，我热爱的运动，今年坚持的非常差。十月十一月有坚持了一段时间，但忙起来就容易打乱节奏，再进入状态就很难。<strong>运动不仅需要时间，状态也很重要。</strong>工作太忙，大多数时间，工作的忙碌导致自己已经没有时间和精力去生活了，闲下来就想躺着歇着，运动更是难以顾及。吃的也越来越随意，不吃足够的碳水真的无法坚持完成当天的工作。前半年加班熬夜较多，也会因为自身的责任感，而睡不好，下半年要好很多，较多的时间能够跟儿子一起早睡早起。之前身上没啥大碍，今年开始觉得腰疼，肩颈也越来越僵硬，很多时候工作忙起来都没时间喝水、上厕所，一心想着忙完这件事再怎样，多少对身体有影响吧。</p><p>就从这周开始吧，运动起来，尽量保持运动的习惯和状态，<strong>每周2次跑步+2次瑜伽/普拉提课</strong>。随着运动的恢复，饮食、睡眠、身体都会好起来的，腹肌也会归来✌️。</p><p>对了，新的一年，希望增加爬山，<strong>每个月1次爬山</strong>。</p><p><strong>心理情绪</strong></p><p>自己能明显感受到，自己的情绪越来越稳定，习惯看到事情好的一面，相信凡事都有利弊，什么事情都可以解决，也都可以心平气和的解决。</p><p>情绪波动多源于忙碌的工作。一是会思考家庭、工作与生活的平衡，儿子的教育与陪伴很重要，与老公的沟通也很重要，日常生活运动习惯这些也很重要，现在很少有时间顾及到，偶尔还会因为工作的忙碌或烦躁，影响对儿子的态度<sup class="ss-footnote" href="" title="事后又非常愧疚">4</sup>。二是忙碌的工作并不会带给我成就感，更多是负面情绪，我喜欢凡事往好处想，昨天有梳理这份工作的好处，但更多的是难受。更明确自己的想法，希望做有创造性的工作，<strong>压力不可怕，可怕的是压力背后没有成长</strong>。</p><p>太有责任心会让自己很累。凡事想做100%，想尽全力考虑周全，想完美，真的很累。越来越发现，工作中这样的心态只会让自己很累，成果却没有那么显著。而自己又很难做到70%或80%，很难做到不闻不问、不过多询问、让干1就干1。略微有点迷茫，但可能还是会坚持现在100%的原则。</p><p>写上述文字时，还略有迷茫，当晚看到人物一篇“活成不喜欢的样子，就算失败吗”的文章，里面讲到【削足适履】，这个形容真的非常贴切了，外在的事物只是一双鞋子，真的没必要为了它而削足，瞬间豁然开朗。<strong>相信自己依然是那个活力满满，自信满满的小A，坚持自我，活出自己的风采。</strong></p><h3><strong>四、休闲放松</strong></h3><p>日常消遣主要是小红书，甚至一个电视剧也能通过小红书了解、看完。真正有营养的内容并不多，但仍然忍不住打开、翻看。新的一年希望能控制，多用播客、微信读书这类APP代替小红书。</p><p>有娃后，只能在晚上他睡着后起来看电视剧了，《小巷人家》《唐朝诡事录》还是很不错的。好像今年只去过三次电影院，看了《哪吒2》《南京照相馆》《阿凡达3》。都挺好的，慢慢培养自己写作的能力，可以每次看完写个观后感。</p><p>这一年去了大连、秦皇岛、古北水镇、三亚，最开心的是在三亚酒店躺着的那两天，儿子开心的玩水，我俩舒服的休息，还拍了美美的照片。工作忙、不出差，也没时间和机会到处逛了。年初根据购买的游玩年卡制定了每周末的游玩计划，只执行了几次，到开始卖房那会基本就停了，一是房子二是工作忙周末就想休息，经常是附近公园逛逛，很少出远门了。</p><p>新的一年，我们再次行动起来，每周末找个地方逛逛。</p><h3><strong>五、理财投资</strong></h3><p>20250731卖了大部分基金，20250801重新以8500元的本金开始。</p><p>2021年春节前后，开始投入基金，总投入3.9万，没多久基金就开始下跌📉，跌的时候想再等等，没想到一路狂跌，记得22年产假结束上班那会，已亏了1.2w，想再等等，没想到依然下跌，后来基本没管了。今年忍痛，以亏损1.5万结束第一轮战斗，再以低投入重新开始。今年下半年行情好，已经赚了2000元。</p><p><strong>凡事都讲究个付出才有回报。</strong>我就没好好研究基金，怎么赚钱呢，全是大势所趋。之前有经过其他事发现：<strong>只要认真研究什么事都能整明白</strong>。</p><p>新的一年，把家庭收入按百分比做支出分配，投入点精力在基金上，好好研究研究。</p><h3><strong>六、社交人际</strong></h3><p>身边的朋友大多有了家庭，每个人都有工作、家庭的好多事要处理，大家相聚的次数越来越少，社交也多以线上为主。我是E人，不忙的时候，习惯找朋友聊聊天，外出到哪个地方，找朋友出来坐坐。今年唯有一次，特意攒局请大家出来聚聚。巧的是，也正是那天我们相聚的时刻，另一好友去世了。</p><blockquote><p>猝不及防的离开，十分心痛。</p><p>上次见面还谈笑风生，再见面却是在追悼会，看着黑白照片和那缩小的身影。</p><p>相约时，本以为时间还长，日子还久，“忙着呢，找时间/有机会再聚”，却不知再也没有下一次了。</p><p>一次平常相聚的道别，没想到是永别。</p></blockquote><p>那几天我突然意识到，<strong>每个朋友在自己心里都有着不同的位置和角色，无可替代</strong>。这也让我更加珍爱生命，活着就挺好，生命很短暂，多做些自己想做的事情吧。身边的家长和朋友，能见面就见面，不再心存“以后还有机会”的想法。</p><h3><strong>七、学习成长</strong></h3><p>惭愧，自己这一年好像没啥学习成长，或者说这几年都没有。之前若是有，则都是运动方面的兴趣爱好。今年若硬要说一个，那可能是咖啡方面的知识吧。</p><p>现在习惯了工作日每天一杯咖啡，在家是手冲，外出是瑞幸。不坐班，上半年儿子没上学，没法在家办公，每天走路半小时到附近的咖啡馆，不忙的时候喜欢和店员聊聊天，慢慢了解了不少咖啡的知识。各方面都了解了个大概，并没有那么深入的研究。</p><p>去年年末和今年年初，有学习雅思，顶着工作忙碌的压力上课，之后不那么忙了反而没有再继续学习。自己心中一直有个想法或者说是梦想，目前的积累还不足以支撑，需要持续不断的学习与积累。</p><p>新的一年，希望能够坚持学英语，多听播客，多读书。<strong>每天10分钟英语，每周两次播客，每月一本书</strong>，从这样的基础开始吧。</p><h3><strong>八、自我实现</strong></h3><p>这一年重要的自我实现在于对自我的认知吧。</p><p>2024年上一份工作，让自己认识到：自己职业的局限性，哪些能实现，哪些自己是做不到的，交际、说话办事也是非常重要的能力。</p><p>2025年，自己情绪更稳定，认识到生命的可贵，职业发展中更明白自己想要的是什么<sup class="ss-footnote" href="" title="刚开始，想着“躺平”，安心做好本职工作，让干啥干啥，发现这只适用于当时的情景和当下的公司，并不是自己的追求。目前虽对下一步计划仍没有那么清晰，但也是越来越清楚自己想要的是什么。">5</sup>，也更懂得工作和家庭、生活是需要平衡的，需要分配精力的。</p><p>这一年开始思考并反复思考：<strong>人为什么活着，活着的意义是什么。</strong>会在路上、商场、旅游景点等各个地方观察各行各业的人。每一个人都在自己的岗位做着自己喜欢或不一定喜欢甚至是讨厌的工作，工作收入用来生活，买漂亮衣服、吃美食、旅游等，获得开心与满足，似乎形成了循环。从古到今，上万上亿的人这么生活着。那么，活着的意义是什么呢？自己也没有完全想明白，一直认为就是体验，<strong>体验这美妙、丰富又复杂的世界</strong>。</p><p>新的一年，上述七项列到的计划都能完成，就已经是非常棒的自我实现啦。</p><hr /><p>本文主要是2025年的总结，因为前几年没有写，所以也会有这些年的一些感悟。六千多字写完，自己觉得非常开心，很充实、丰厚。</p><p>㊗️大家都能实现自己的新年愿望，践行新一年的计划。</p><h4>&nbsp;</h4>
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://sspai.com/post/105383</id>
            <title>iphone非全面屏最后的旗舰！2026年为什么我还这么喜欢iphone 8 plus</title>
            <link>https://sspai.com/post/105383</link>
            <guid isPermaLink="false">https://sspai.com/post/105383</guid>
            <pubDate></pubDate>
            <updated>Tue, 13 Jan 2026 07:50:27 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>大家好，现在是 2026&nbsp;年 1&nbsp;月 13 日。你现在看到的这篇文章，灵感正是源自这部<strong>iPhone 8 Plus</strong>，近日，“<strong>15&nbsp;年前的 iPhone 4S&nbsp;开箱</strong>”&nbsp;词条登上热搜，那我也趁热打铁，分享一篇关于 9&nbsp;年前的 iPhone 8 Plus&nbsp;的体验报告。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/12/9b6997f69fcf376e55832f54b9a6b172.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>图01_ <strong>iphone 8 Plus</strong>&nbsp;官方图-来自Apple官方</figcaption></figure><p>在过去一个多月，我把抽屉里积灰许久的<strong>iPhone 8 Plus</strong>翻出来使用，发现自己还是格外喜欢这款手机。作为苹果最后一款采用传统非全面屏设计（带实体 Home&nbsp;键 + Touch ID）的数字系列旗舰，即便在全面屏盛行的 2026&nbsp;年，<strong>iPhone 8 Plus</strong>&nbsp;的外观在我看来，依旧漂亮得像一件艺术品。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/12/a4664010b0cc36ccd385272cf2734a4c.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>图02_ <strong>iphone 17 Pro&nbsp;</strong>&amp;<strong> iphone 8 Plus</strong>正面对比</figcaption></figure><p>于是我索性把它带去上班，闲暇时就拿出来把玩一会儿：滑动两下桌面，按一按 Home&nbsp;键解压，刷一刷微博和B站，也用它随手拍了很多照片。更有意思的是 ——&nbsp;恰恰是这部手机，推动我写下了这篇体验文章，在进入正题聊体验之前，我想先和大家聊聊自己写文章和 iPhone&nbsp;的一些渊源。</p><p>早在十几年前，我还在上高中的时候，就总看王自如和幻想曲通讯的 iPhone&nbsp;体验评测。那时候我就想着，以后也要像他们一样，做一期属于自己的手机体验视频分享。但无奈受限于时间成本、视频制作能力，再加上严重的拖延症，这件事就一直被搁置了下来。</p><p>不过后来我发现，图文形式的体验分享好像更适合我 ——&nbsp;不仅更容易坚持下去，还能收获不错的正反馈。比如五年前，我在什么值得买上发过一篇闲鱼二手购入 iPhone 8 Plus&nbsp;的文章，就收获了几百个收藏和数百条评论。或许正是这些来自文章分享的正反馈，让我对这部 iPhone 8 Plus&nbsp;更加偏爱了吧，也正因为如此，才有了这篇文章。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/12/37acca71c82a20250a54cb242e5e0f38.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>图03_ <strong>iPhone 8 Plus</strong>正反馈文章</figcaption></figure><p>接着让我们回归正题。这部发布于 2017&nbsp;年 9&nbsp;月的非全面屏<strong>iPhone 8 Plus</strong>，在当年的苹果发布会上其实算不上最亮眼的主角。毕竟同台登场的<strong>iPhone X</strong>，凭借刘海屏 + Face ID&nbsp;开启了苹果的全面屏时代，这才是奠定苹果未来十年发展方向的基石。可就是这样一台已经发布 8&nbsp;年多的 “老古董”，到底还有什么魔力能吸引到我呢？</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/12/cd2f72259e5cb9568ac267be9700f6ba.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>图04_ <strong>iPhone X</strong> &amp; <strong>iPhone 8 Plus</strong> &amp; <strong>iPhone 8-来自Apple官方</strong></figcaption></figure><p>第一个原因，我想大概是<strong>iPhone 5&nbsp;到 8&nbsp;代机型</strong>，恰好诞生在我的高中和大学时期 —— 那正是我最渴望拥有一部好手机，却又无力承担的年纪。上学那会儿，看着班里同学用着这些堪称工艺巅峰的机型，精致的外观、手感绝佳的 Home&nbsp;键，对当时身为数码爱好者的我来说，iPhone&nbsp;就是遥不可及的 “白月光”&nbsp;之一。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/12/1abfcb9ae75ed039561b45c53e8b8337.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>图05_ <strong>iphone 8 Plus </strong>的home键</figcaption></figure><p>当然，当年的白月光还不止有 iPhone，还有另外一个已经没落的手机品牌 HTC，我想如果有机会的话，我应该也会讲讲我和 HTC&nbsp;的故事。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/12/e77ddb570bc577169bf5f7aa02f05e05.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>图06_HTC手机和iphone 8 Plus&nbsp;</figcaption></figure><p>让我们把故事拉回到<strong>iPhone 8 Plus</strong>的身上。18&nbsp;岁还在上高中的我囊中羞涩，根本没能力拥有这样一部手机。少年时的梦想，只能等到大学毕业、努力工作赚钱后再去实现。于是在 2022&nbsp;年，也就是我参加工作的第三年，凭借多年积攒的存款和丰富的闲鱼购物经验，我鼓起勇气花 1150&nbsp;元在闲鱼上买下了这部曾经梦寐以求的 iPhone 8 Plus。有人说，30&nbsp;岁再去买 18&nbsp;岁心心念念的东西，早就没了当初的意义。但我想说，我不仅觉得有意义，而且更加开心 ——&nbsp;哪怕这部 iPhone&nbsp;早已过时，这份开心也真实无比。因为这是我努力多年才得到的、曾经遥不可及的礼物，也是赠送给年少时期的我的礼物。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/12/e12240a091823301e89d1f39f58c607f.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>图07_闲鱼购入<strong>iphone 8 Plus</strong>&nbsp;记录</figcaption></figure><p>更重要的是，这台在闲鱼购买的 iPhone 8 Plus&nbsp;没有翻车：它是原装未拆修的，成色很不错，中间只换过一次电池，如今五年过去了，我依旧在正常使用它。这里也给大家分享一个我存了多年的二手验机经验图，这份图我最初是从酷安网友的分享中保存的，后来又重新编辑整理，制作成了新版的自用图。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/12/e57f25066ef9c97d46eb78486aaa653d.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>图08_二手手机重点测试项目-来自酷安网友分享</figcaption></figure><p>第二个原因，作为一名曾经疯狂刷机的数码爱好者，当年为了满足体验各种系统的瘾头，我不仅入手了两台支持多系统安装的手机，还折腾着给手里的安卓机 Root、刷机，甚至自学安卓系统 Recovery&nbsp;编译和 Rom&nbsp;移植。至今我都忘不了，高中时每天疯狂研究刷机的日子：刷完自己的手机，就帮同学刷机，只为体验到不同系统的新鲜感。但再怎么折腾，上学时囊中羞涩的我，始终没能体验到 iOS&nbsp;系统 ——&nbsp;这也成了我当年的一大遗憾。也许这也是为什么在 iPhone 8 Plus&nbsp;发布五年后的 2022&nbsp;年，我依然愿意买下它的原因之一。当然，现在的 iPhone 8 Plus&nbsp;已经没法升级到最新的 iOS&nbsp;系统了，它的系统更新最终停在了 iOS 16。不过对我来说，这个版本也足够让我感受到 iOS&nbsp;系统的独特乐趣了。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/12/d659b35c28ea2e39b766cd0e0c64ed10.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>图09_ <strong>iphone 8 Plus</strong>系统更新</figcaption></figure><p>第三个原因，就是<strong>LCD&nbsp;屏幕</strong>的加持。作为一名曾经的 “LCD&nbsp;教徒”，同时也是高度近视患者，当初选择 iPhone 8 Plus，正是因为它是苹果阵营里最强的 LCD&nbsp;旗舰机型。不过现在我对 LCD&nbsp;倒是没那么执着了，毕竟如今的手机大多用上了高频 PWM&nbsp;调光的 OLED&nbsp;屏幕，护眼表现也还算靠谱。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/12/a6af792ae0898290b0930e406bf930fc.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>图10_iPhone 8&nbsp;系列采用了LCD视网膜高清显示屏-来自Apple官方</figcaption></figure><p>第四个原因，就是 iPhone 8 Plus&nbsp;放到 2026&nbsp;年的今天，依然是一台很称职的备用机。当然，每个人对备用机的需求不尽相同，我的主力机是小米 13 Ultra，所以 iPhone 8 Plus&nbsp;就专门用来刷短视频、刷微博，偶尔还会拍一拍自己锻炼的视频，并且也有4K 60帧的录制，作为备用机来说，它的表现已经完全够用了。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/12/c513897d1a4178704531b15fad8fb0f8.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>图11_ <strong>iPhone 8 Plus</strong>录制 4K 60&nbsp;帧视频</figcaption></figure><p>而且 iPhone 8 Plus 有一个我特别喜欢的设计 —— <strong>Home 键的震动反馈</strong>，这甚至让我养成了没事就按它解压的习惯。它的震动反馈调校得相当出色，我觉得比小米 13 Ultra 的震动还要舒服。尤其是在 B 站给 UP 主一键三连的时候，指尖传来的震动感，直接把体验感拉满。另外，iPhone 系统推送通知的震动反馈也同样出色，消息从来不会遗漏。而且我使用 Apple 其他产品的时候，iPhone 的隔空投送也比安卓手机的互传好用太多。</p><p>另外还有一点，在白天光线充足的环境下，iPhone 8 Plus&nbsp;拍出来的照片效果也很不错。有几天我特意用它和手里的主力机小米 13 Ultra&nbsp;做了拍照对比，大家可以看看，除了高光压制差了一些和大光比场景以及长焦段没有优势，我觉得iPhone 8 Plus 拍照效果也还行，顺便今年元旦去天津旅游的时候我也带着iPhone 8 Plus 出门，大家可以看看具体的成片效果。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/12/524dea738f422f1df454ac00fbf15794.JPG?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>iPhone 8 Plus 拍摄样张01</figcaption></figure><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/12/fdb9585e14425995bc42b86c17523be0.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>小米13 Ultra 拍摄样张01</figcaption></figure><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/12/1e68c4981418f94bdff5688fa96e3b42.JPG?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>iPhone 8 Plus 拍摄样张02</figcaption></figure><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/12/67d993bcb64a14b85cc5d3889426d17d.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>小米13 Ultra 拍摄样张02</figcaption></figure><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/12/35d6ee3eb72af2c4dd5ca3e3a7b1db55.JPG?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>iPhone 8 Plus 拍摄样张03</figcaption></figure><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/12/578cee9aa014c0dc347b9ac75e3ac3ad.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>小米13 Ultra 拍摄样张03</figcaption></figure><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/12/4912a746c9294a6d3e5981a7eb5c604f.JPG?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>iPhone 8 Plus 拍摄样张04</figcaption></figure><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/12/2b274b427ac89d06a35ba2328820beac.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>小米13 Ultra 拍摄样张04</figcaption></figure><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/12/eed78f6b0a1589f472bfc831985ae225.JPG?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>iPhone 8 Plus 拍摄样张05</figcaption></figure><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/12/9798c754093bc0f2b71691a6ea84eb69.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>小米13 Ultra 拍摄样张05</figcaption></figure><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/12/05cc56f6eb336d546c3194a9bbab8afd.JPG?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>iPhone 8 Plus 拍摄样张06</figcaption></figure><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/12/c2b2902f2206ee4d8eeba87aa2929df7.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>小米13 Ultra 拍摄样张06</figcaption></figure><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/12/16ce3e0e289c6aa6cecbcc764c10d0ef.JPG?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>iPhone 8 Plus 拍摄样张07</figcaption></figure><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/12/9fb5862b63c778bd141f1854273bd3da.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>小米13 Ultra 拍摄样张07</figcaption></figure><p>第五个原因，就是在我的潜意识里，<strong>iOS&nbsp;系统要比早年的安卓系统更安全</strong>。前面我提到过，我曾经痴迷于安卓手机的解锁、Root 和刷入第三方刷机包，但这种极致自由的背后，必然伴随着不小的安全风险。尤其是早年的安卓生态，连官方应用商店都没有统一的标准，远比不上 App Store&nbsp;或 Google Play&nbsp;的管控力度。另外，在安装第三方软件这件事上，以前的国产安卓手机可以说是毫无门槛 ——&nbsp;无论你从哪里下载的安装包，基本都能直接安装；反观现在，不仅需要验证账号，还会弹出明确的风险提示，管控已经严格了很多。除此之外，系统更新支持周期也是一大关键。iPhone&nbsp;的系统更新支持普遍能达到 5&nbsp;年以上，而国产安卓手机的系统更新周期大多只有 2-3&nbsp;年，部分品牌甚至几乎没有后续更新，比如在2025年的9月15日，Apple官方依然为iphone 8 Plus提供了安全更新，也许正是因为这些原因，才让我潜意识里一直觉得 iOS&nbsp;系统更安全。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/12/e2cc99515c0ea4b0ba75000eaa0bce21.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>图12_2025年9月15日 apple官方继续为 <strong>iphone 8 Plus</strong>推送更新</figcaption></figure><p>以上五个原因，就是 2026&nbsp;年我依旧偏爱 iPhone 8 Plus&nbsp;的理由。而我觉得最关键的一点，还是前面提到的 ——&nbsp;它让我有了写下这篇文章的冲动，这也是最让我心动的地方。</p><p>以上就是本篇文章的全部内容了。我是狗空蓝，iPhone 8 Plus&nbsp;是目前我最喜欢的一款 iPhone。因为我用过的 iPhone&nbsp;只有 6S、7&nbsp;和这台 8 Plus，还没有机会体验其他机型。也许到了 2030&nbsp;年，我会入手一部属于自己的二手 iPhone 17 Pro&nbsp;吧。希望大家能喜欢这篇文章，我们下次再见！</p><p>&nbsp;</p>
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://sspai.com/post/105287</id>
            <title>无线与性能兼得：为兆能讯通ZN-M2路由器编译带 WiFi 的固件</title>
            <link>https://sspai.com/post/105287</link>
            <guid isPermaLink="false">https://sspai.com/post/105287</guid>
            <pubDate></pubDate>
            <updated>Tue, 13 Jan 2026 02:29:20 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p style="margin-left: 0px;"><strong>Matrix 首页推荐</strong>&nbsp;</p><p style="margin-left: 0px;"><a href="https://sspai.com/matrix">Matrix</a>&nbsp;是少数派的写作社区，我们主张分享真实的产品体验，有实用价值的经验与思考。我们会不定期挑选 Matrix 最优质的文章，展示来自用户的最真实的体验和观点。&nbsp;<br />文章代表作者个人观点，少数派仅对标题和排版略作修改。</p><hr /><p>现在，支持 WiFi6 技术的路由器，已经成为诸多数码爱好者的标配——相较于以往的技术，有着更稳定、流畅的体验。市面上WiFi6 路由器也早已成为主流；不过，高性价比又具有可玩性的 WiFi6 路由器，却长期可遇不可求。我的要求是：能刷 OpenWrt，采用 64-bit ARM 架构处理器，具有可观性能。</p><p>幸运的是，我遇到了兆能讯通M2路由器（下文简称「兆能M2」），是在办宽带的时候，当地的中国电信分公司赠送的。它的配置如下：</p><ul><li>搭载高通 IPQ6000 处理器，主频1.2 GHz</li><li>支持 WiFi6，2.4 GHz / 5 GHz双频，无线速率可达1200 Mbit/s</li><li>支持千兆网络</li></ul><p>在性能优异的同时，拥有广阔的玩转空间。闲鱼上未经改装的原机，2023年只需50元左右即可拿下，而到了2026年1月更是在30元内即可搞定，可见其性价比之高。</p><p>为了更好发挥兆能M2的可玩性，我给它编译了支持无线的OpenWRT固件，充分发挥 IPQ6000 芯片的潜力，畅快做主力。</p><p>本教程也与中国移动定制的路由器——和目 CMIOT AX18 通用，二者都采用同一套硬件配置<sup class="ss-footnote" href="" title="需要注意的是，CMIOT AX18 也有采用联发科处理器的版本，购买时务必向卖家核实。我个人建议你直接选择兆能M2。">1</sup>。</p><p style="margin-left: 0cm;"><strong>注意，阅读本文需要你掌握以下知识：</strong></p><ul><li>Linux 的基本知识（例如，如何运行 Linux 命令</li><li>SSH 的基本使用方法（如何登录到路由器）</li><li>OpenWRT 的基本使用</li><li>menuconfig 的操作方法</li></ul><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/09/704b3b1ceb45d3682621431c8e8c0a49.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>兆能M2路由器的 OpenWRT 后台首页。</figcaption></figure><h2>背景</h2><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/13/e4ed8b8af19d6a3576baeaf6c9e86058.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>这台就是兆能M2路由器。</figcaption></figure><p>由于可玩性高，兆能M2（以及采用相同方案的和目 CMIOT AX18）在恩山论坛<sup class="ss-footnote" href="" title="恩山论坛是一个以研究路由器技术闻名的国内论坛。">2</sup>获得关注，玩家众多，固件适配有不少。笔者最初也是遍寻恩山的固件来尝试。</p><p>但是，<strong>多数固件是不带无线的</strong>，意味着刷了这些固件，你的兆能M2就只能当有线路由器使用了。与此同时在闲鱼上，你能找到的改装版本有相当一部分拆掉了天线。就笔者观察，主要有以下一些原因：</p><ul><li>大多数玩家偏重 IPQ6000 的转发性能，用作主路由放在弱电箱；同时由于处理器性能强大，有些玩家也偏重于用它运行各类OpenWRT应用。以上场景都不使用它的WiFi。</li><li>兆能M2的 OpenWRT 固件曾长时间缺乏稳定、有效的 WiFi 解决方案，以至于玩家认为该款路由器「无线性能欠佳」，只好弃用 WiFi。</li><li>部分玩家希望在出厂的 256 MB RAM当中，使用高通的硬件加解密组件。但受限于 RAM 容量，WiFi 与硬件加解密不可得兼，故舍弃 WiFi。</li></ul><p>在笔者看来，得益于内置 WiFi6 芯片 IPQ6018 的加持，兆能M2 WiFi6 的实力不可小视。在使用官方固件时，信号质量不错，能充分发挥家宽的性能。要是无线功能闲置不用，将有多可惜，白白浪费了这么好的底子！因此，有一个带无线且稳定的固件，对笔者来说是刚需。</p><h2>事先准备</h2><h3>⭐升级内存（重点！）</h3><p>要想给兆能M2刷入 OpenWRT 固件，内存（RAM）扩容是刚需，必须升级！</p><p>兆能M2出厂 RAM 容量只有256MB，跑官方固件不成问题。然而，<strong>适用于兆能M2，且支持无线的 OpenWRT 对内存要求更高</strong>，空载内存占用就可以达到甚至超过 256MB。<strong>如果不升级，固件依然可以运行，但将会非常卡顿</strong>，半天都打不开路由器管理后台，即使用 PuTTY 登录 SSH 也反应迟钝。</p><p><strong>RAM 必须 512MB 起步。建议有条件的玩家扩容到 1GB</strong><sup class="ss-footnote" href="" title="最大可以扩容到 2GB，但通常 1GB 已经绰绰有余。">3</sup>，这样运行速度将会飞快，稳定性也更佳。</p><p>你可以在淘宝寻找专业的路由器升级扩容服务，通常有经验的工程师会帮你升级好 RAM，并刷入正确的 CDT 文件（高通的设备信息文件，包含内存信息）。笔者就请专业工程师将 RAM扩容到了1 GB，运行丝滑流畅，足以胜任各类应用。</p><h3>官方固件用户请注意</h3><p>如果你正在使用官方固件，请你先从官方固件刷入一版第三方 OpenWRT 固件作为过渡，这样才便于登录 SSH，以便于刷入引导程序 U-Boot。刷入方法如下<sup class="ss-footnote" href="" title="刷入方法参考了这个链接：https://www.right.com.cn/forum/thread-7827262-1-1.html">4</sup>：</p><ul><li><strong>第一步：</strong>登录路由器管理页面，默认密码是 admin，默认管理页面是192.168.2.1（路由器底部标签有具体的用户名、密码和默认管理地址）。</li><li><strong>第二步：</strong>登录后点「高级设置」➡️「升级固件」，选择固件文件后上传，取消勾选「保存配置」，等待3～5分钟完成升级。</li></ul><p>选择的固件需要是 nand-factory 格式的固件（文件名带有 <code>nand-factory</code>）。<strong>相关固件可以自行搜索</strong>（例如在恩山论坛搜索），若你还来不及更换内存，<strong>务必选择可在官方 256MB 内存（RAM）运行、不带无线的固件</strong>。</p><p>如果你已经升级了内存，理论上也可以使用本教程编译出来的固件（请往下翻到「编译成功后」小节），这需要你自行测试。</p><h3>刷入U-Boot</h3><p>U-Boot 用于支持第三方 OpenWRT 固件的引导，并提供刷机功能，若设备无法开机，就可以刷入其他固件「救砖」。</p><p>兆能M2最常用的 U-Boot，就是由暗云编译的<strong>闭源 U-Boot。</strong><a href="https://anclark.github.io/assets/appendix/ZN_M2_UBOOT.7z" target="_blank"><strong>点击这个链接下载</strong></a><strong>。</strong><sup class="ss-footnote" href="" title="原始的下载链接是：https://mbd.pub/o/bread/YpaZlp5u，但该链接已经失效。这里使用我提供的备份。">5</sup></p><p>需要注意的是，暗云的 U-Boot 分为普通版和扩容版：</p><ul><li>普通版的文件名为<code>uboot-cmiot-ax18.bin</code>，支持官方固件的分区结构（rootfs 大小约为 50MB）。</li><li>扩容版的文件名为<code>uboot-cmiot-ax18-mod.bin</code>，配合重新调整的分区结构使用，rootfs分区更大（达到 96MB），便于装更多软件，但需要配合正确的ADT文件（相当于分区表）使用。</li></ul><p><strong>原厂的分区通常已经够用，安装常用工具、保存路由器配置都绰绰有余，因此使用普通版即可。</strong>考虑到兆能 M2 没有原生的 USB 接口连接外置存储<sup class="ss-footnote" href="" title="兆能M2的主板上预留了 USB 3.0 的焊接点，但这对动手能力有极高要求。若你有使用 USB 3.0 的需求，建议直接购买高手改装后的版本，或者是请专业技术人员改装。">6</sup>，个人不建议你使用兆能 M2运行 Docker、文件服务器等高阶应用，这些专业的事儿交给 NAS 或自建服务器完成会好得多，咱就用路由器上网就行。</p><p><strong>通过过渡固件刷入 U-Boot 的方法如下：</strong></p><ul><li><strong>第一步：</strong>用 WinSCP 等 SSH 文件传输工具连接路由器，将<code>uboot-cmiot-ax18.bin</code>传送到<code>/tmp</code>目录下。</li><li><strong>第二步：</strong>使用 SSH 登录路由器，或使用 WinSCP 的「运行命令」功能，执行以下命令，刷入 U-Boot：</li></ul><pre class="language-null"><code>mtd write /tmp/uboot-cmiot-ax18.bin /dev/mtd13</code></pre><p>刷入完成后，在 SSH 中输入 <code>reboot</code> 即可重启路由器。</p><h2>下载 OpenWRT 源代码</h2><p>本教程使用的 OpenWRT，<a href="https://github.com/coolsnowwolf/lede" target="_blank"><strong>基于 Lean（人称「L大」，GitHub：coolsnowwolf）维护的 OpenWRT 源码树</strong></a>。</p><p>L大的源码树具有以下的突出特性：</p><ul><li>及时与上游同步，使用最新的 OpenWRT 版本与 Linux LTS 内核</li><li><strong>为诸多国产路由器提供了完备的官方支持</strong>，其中就包括兆能M2（提供的是 CMIOT AX18 的配置，但同时适用于兆能M2）</li><li>包含独有的应用程序，例如网络加速引擎 TurboACC、用于登录校园网的 minieap 等等</li></ul><p>不过，或许是考虑到很多玩家将兆能M2用作有线路由器，不需要用到无线功能，L大的源码树默认没有提供兆能M2的无线支持。因此，<strong>我 fork 了L大原版的代码树，加入了无线支持</strong>，让刷了 OpenWRT 的兆能M2真正成为一台完整的无线路由器，不荒废路由器的 WiFi6 无线实力。</p><h3>克隆源码</h3><p><strong>克隆源码，并进入源码目录</strong>：</p><pre class="language-null"><code>git clone https://github.com/AnClark/lede-zn-m2-wifi -b zn-m2-wifi
cd lede-zn-m2-wifi</code></pre><h3>初始化 OpenWRT 组件</h3><p>OpenWRT 的一些组件（如 LuCI 网页管理界面）需要单独下载更新，执行以下的命令即可一键搞定。</p><pre class="language-null"><code>#&nbsp;同步OpenWRT各个组件的源代码
./scripts/feeds update -a &amp;&amp; ./scripts/feeds install -a

#&nbsp;下载各类组件（可选，不影响兆能M2的运行）
make download</code></pre><h2>配置设备（<code>make menuconfig</code>）</h2><p>运行<code>make menuconfig</code>打开 OpenWRT 的配置菜单，然后依次配置以下的主要参数。其余功能可以按照你自己的需要来配置。</p><h3>如何操作配置菜单</h3><blockquote><p>基本操作方法：</p><ul><li><strong>左右方向键：选择底部的功能按钮</strong></li><li>上下方向键：在列表中移动光标</li><li>按两次ESC键：返回上一页</li><li>Y键：勾选当前设置项（如果左边有<code>&lt; &gt;</code>或<code>[ ]</code>标记）</li></ul></blockquote><h3>选择目标设备</h3><p>在配置菜单的首页中，<strong>依次</strong>修改下面的设置项：</p><figure class="table"><table><thead><tr><th style="padding: .75pt;"><p style="text-align: center;"><strong>参数名</strong></p></th><th style="padding: .75pt;"><p style="text-align: center;"><strong>值</strong></p></th></tr></thead><tbody><tr><td style="padding: .75pt;">Target System（目标系统）</td><td style="padding: .75pt;">Qualcomm Atheros 802.11ax WiSoC-s</td></tr><tr><td style="padding: .75pt;">Subtarget（子目标）</td><td style="padding: .75pt;">Qualcomm Atheros IPQ60xx</td></tr><tr><td style="padding: .75pt;">Target Profile（目标配置）</td><td style="padding: .75pt;">CMIOT AX18</td></tr></tbody></table></figure><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/09/83d50acaa310d6d66b677c5285a9574b.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>配置菜单的首页，红框中的前三项用于指定目标设备。</figcaption></figure><p>上表指出的三个设置项，末尾都有一个「---&gt;」标志。选中后按回车键，你会看到下图所示的列表。在列表中，选中我指定的项目后，回车即可。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/09/7ed56b1e813678c13649a783d05897dd.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><h3>选择无线配置文件</h3><p>依次进入<strong>【Firmware</strong>（固件）<strong>】</strong> –&gt;&nbsp;<strong>【ath10k Board-Specific Overrides</strong>（覆盖 ath10k 特定主板的配置文件<strong>）】</strong><sup class="ss-footnote" href="" title="实际上，兆能M2的 IPQ6018 属于「ath11k」系列。为了便于集中选择，L大的源码树将「ath10k」和「ath11k」的配置文件选项都整合在同一个子菜单里。">7</sup>。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/09/a2c4b4e31de7084c0e5366394266e697.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/09/73d6c1d3faba85fbab8965bc0b66fb9d.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p>然后勾选「<code>ipq-wifi-cmiot_ax18</code>」下面这一项，以启用兆能M2（或CMIOT AX18）的无线配置文件。如下图所示：</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/09/ef9e4900a9aa5a67092490f96e62fb32.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p><strong>这是设备能使用WiFi的关键。</strong></p><h3>加入各类实用程序</h3><p>L大的 OpenWRT 自带了一些实用程序。为了提升使用体验，建议至少启用本教程建议的功能。</p><p>依次进入<strong>【LuCI】</strong>–&gt;<strong>【3. Applications】</strong>，然后至少勾选下面的项目：</p><ul><li><strong>luci-app-cpufreq</strong>：CPU性能优化调节，可以控制 CPU 频率及调节策略。</li><li><strong>luci-app-autoreboot</strong>：定时重启。</li><li><strong>luci-app-ttyd</strong>：TTYD 终端，可以直接在 OpenWRT 的管理后台使用终端，无须登录 SSH。</li><li><strong>luci-app-turboacc</strong>：TurboACC 网络加速，允许你使用快速转发引擎、修改 TCP 拥塞算法、启用全锥形 NAT，优化网络性能。<ul><li>其中，luci-app-turboacc 下方有一个选项是【<strong>FastPath Engine（快速转发引擎）</strong>】，可以根据需要在3种快速转发引擎中选择一个。我建议选择【<strong>Use shortcut-fe connection manager</strong>】，可以显著提升小包转发性能<sup class="ss-footnote" href="" title="具体可以参考 ACWifi 网站上的这篇评测体验文章：https://www.acwifi.net/19426.html">8</sup>。</li></ul></li></ul><h2>编译固件</h2><h3>前提条件</h3><p>OpenWRT 编译过程中用到的工具，例如编译器、构建工具、WiFi 固件等，都需要从各自的官方网站下载，并从源代码编译。因此，<strong>务必保证你的网络连接顺畅</strong>。</p><h3>执行编译命令</h3><p>为了防止冲突，首先清理上次的编译结果：</p><pre class="language-null"><code>make clean</code></pre><p>然后<strong>正式开始编译</strong>。参数<code>V=s</code>会让OpenWRT在编译时显示详细信息，便于你掌握编译状况：</p><p><code>make V=s</code></p><p><strong>注意：</strong></p><p><strong>首次编译会花很长时间</strong>，因为要从源码开始编译一系列工具（如GCC、CMake、Golang、Rust 编译器）。请务必耐心等待。</p><h3>编译成功后</h3><p>输出的文件位于<code>bin/target/qualcommax/ipq60xx</code>，主要包括：</p><figure class="table"><table><thead><tr><th>文件名</th><th>格式</th><th>用法</th></tr></thead><tbody><tr><td><code>openwrt-qualcommax-ipq60xx-cmiot_ax18-squashfs-sysupgrade.bin</code></td><td>OpenWRT 系统升级包</td><td><strong>需要在 OpenWRT 中刷入</strong></td></tr><tr><td><code>openwrt-qualcommax-ipq60xx-cmiot_ax18-squashfs-factory.ubi</code></td><td>厂家刷机固件</td><td><strong>需要用 U-Boot &nbsp;刷入</strong></td></tr><tr><td><code>openwrt-qualcommax-ipq60xx-cmiot_ax18-initramfs-uImage.itb</code></td><td>Flattened Image Tree</td><td>这不是刷机包，没有软件支持。<strong>请勿使用！</strong></td></tr></tbody></table></figure><h2>刷入固件</h2><p>根据你的情况，你可以用不同方式刷写固件。</p><h3>（1）从过渡固件刷入</h3><p>登录过渡固件的 OpenWRT 网页管理后台，依次进入<strong>【系统】</strong>➡️<strong>【备份与升级】</strong>，在<strong>【刷写新固件】</strong>一栏中，上传我们刚刚编译好的<code>openwrt-qualcommax-ipq60xx-cmiot_ax18-squashfs-sysupgrade.bin</code>，并<strong>取消勾选「保留配置」复选框</strong>。随后，确认升级。</p><p><strong>注意：</strong></p><p>务必取消勾选「保留配置」复选框，让 OpenWRT 在升级过程中将固件恢复到出厂设置，以避免配置冲突引发潜在问题。</p><h3>（2）从 U-Boot 刷入</h3><p>暗云的 U-Boot 支持刷入固件，它提供了一个网页端，只需用网线连接路由器，并登录网页端上传厂商固件（nand-factory 格式）即可。这种方法会完全清除用户设置，相当于重新初始化路由器。</p><p>首先，关闭路由器背后的电源开关，接通电源，随后立刻用尖锐物体（如笔芯、细螺丝刀）长按「RESET」案件不松开，直到设备顶部的「LAN」指示灯变红方可松开——此时设备就进入了 U-Boot 刷机模式。</p><p><strong>提示：</strong>有些批次的兆能M2路由器，在进入刷机模式后，「LAN」指示灯不会变红，取而代之的是「Mesh」指示灯熄灭。以你的设备为准。</p><p>用一根网线连接电脑与路由器的任意一个「LAN」接口，将电脑的 IP 地址设为「192.168.1.2」，网关设为「192.168.1.1」，子网掩码设为「255.255.255.0」。随后打开浏览器，访问「http://192.168.1.1」，打开 U-Boot 的刷机页面，点击「Update firmware」按钮，上传「<code>openwrt-qualcommax-ipq60xx-cmiot_ax18-squashfs-factory.ubi</code>」，等待刷机完成即可。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/13/2a3a9d73d61a3b91a42cba2b80d633f8.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>U-Boot 的刷机页面。</figcaption></figure><p>⚠️<strong>警告：</strong>刷机过程中，切勿关闭电源！</p><h3>（3）如何判断刷机完成？</h3><p>若刷机完成：</p><ul><li><strong>机器上的「Mesh」指示灯会由闪烁转为常亮</strong></li><li>搜索无线网络，你会看到一个<strong>名为「LEDE」的未加密接入点</strong>，这就是路由器的默认接入点</li></ul><h2>评测</h2><p>按照本教程编译出来的固件，使用起来就是一个字：<strong>稳！</strong></p><h3>1.&nbsp;无线信号</h3><p>目前的固件满血发挥兆能M2的无线性能。2.4 GHz 与 5 GHz 双频都能正常配置、连接，WiFi6自动激活，正确地在我的手机上显示相关标识。笔记本连接 5G 频段，用国内源更新 Arch Linux 来测试，5秒内就可以跑满家宽的 100M 带宽，并且一直保持稳定。</p><p>信号强度方面，我家两层楼，路由器放在二楼，在1楼也能收到 2.4G 的信号，几乎满格。</p><p>值得注意的是，相较于<a href="https://sspai.com/post/88679" target="_blank">我上一篇教程使用的固件</a>，这一版固件的无线启动很快，在固件引导完成、「Mesh」指示灯常亮后，就能搜索到路由器的 WiFi 信号。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/09/69c13b29435bfa32c623c09e5ec1d48c.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>兆能M2的无线概览。<strong>标注为「Client」的节点是桥接节点</strong>。</figcaption></figure><h3>2. 无线桥接</h3><p>配合新版固件，兆能M2完美支持无线桥接，方式是作为一台客户端连接其他路由器，为本路由器提供网络连接。只需在无线概览页面中点击 2.4G 或 5G 频段的「扫描」按钮，让路由器自动扫描周围的接入点，然后选择接入点、配置密码等设置，即可搞定。</p><p><strong>OpenWRT 的无线桥接保留原有的 SSID 与密码，并不像华为、TP-Link 等路由器那样将设为与上游路由器相同。</strong>我自己不喜欢那种「与上游一致」的桥接策略，因为不同品牌、不支持跨品牌 Mesh 的路由器桥接时，即使 SSID 相同，实际上仍然是两个独立的接入点，因此设备移动时仍然可能需要重新连接接入点，造成短暂的网络断开。</p><p>OpenWRT 的桥接策略显然更适合我，不仅避免了上述问题，还允许我保留路由器上的特殊设置（例如专门的端口转发规则、专门的服务）。当我需要使用特殊设置时，连接兆能M2自己的热点即可，不需要用到时再连接上游的热点，很灵活。</p><p>值得一提的是，<a href="https://sspai.com/post/88679" target="_blank">我上一篇教程使用的固件</a>是无法使用无线桥接的，打开「扫描」页面是一片空白。新版的 OpenWRT 固件则完美解决了这个问题。</p><h3>3.&nbsp;性能和软件版本</h3><p>IPQ6000 性能可观，处理器本身具有高频率（864MHz 起步，最高 1.2 GHz），再配合高通的 NSS 网卡驱动，胜任平时各类用途不在话下。最直接的体验是使用 LuCI 管理界面时，所有页面几乎都是秒开；日常上网、下载大文件也有平稳顺滑的体验，网络带宽允许的情况下，常用网站轻松秒开。</p><p>L大的这版源码基于 OpenWRT 23.05，采用了截至2026年1月9日最新版的 Linux LTS 内核（6.12.63）。新内核不仅功能和稳定性有显著提升，还完美支持著名的 BBR 拥塞控制算法。BBR 算法可以显著提升 Linux 服务器的网络吞吐量，并有效降低延迟，可直接在 TurboACC 的配置界面中启用。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/09/f2d816201e9e10305c987e0ccd805442.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>TurboACC 管理界面。</figcaption></figure><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/09/2ad764b289094f2a88a8717e607e64af.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>CPU 性能调节界面。使用默认的 schedutil 配置就有可观的性能。</figcaption></figure><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/09/6f62b3c34d75d4efa77eb88328499e93.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>路由器的运行情况（接口总览）。其中的「wwan_ChinaNet」对应的是无线桥接的上级路由器。</figcaption></figure><h3>4.&nbsp;异常重启的问题</h3><p>在长时间运行，尤其是天气渐热之后，兆能M2出现了随机异常重启的状况，严重影响使用体验。恩山论坛的网友指出<sup class="ss-footnote" href="" title="恩山网友的研究过程可以参考这篇帖子：https://www.right.com.cn/FORUM/thread-4086531-1-1.html">9</sup>，这可能是内存颗粒与路由器的 CDT 文件<sup class="ss-footnote" href="" title="CDT 是高通 SoC 的设备定义文件，存储了包括内存信息在内的多种底层定义。">10</sup>不兼容，幸运的是，刷入同论坛技术达人制作的合适 CDT 文件后，问题得以解决。</p><p>具体可以参阅我的博文《<a href="http://anclark.github.io/2023/07/21/OpenWRT/OpenWRT_ZN-M2_Solve_Random_Reboot/" target="_blank">解决兆能M2（和目AX18）异常随机重启的问题</a>》。</p><h3>5. 稳定性</h3><p>新固件的稳定性非常可观。刷入新固件后，<strong>截至发稿时，兆能M2已经连续稳定运行了5天12小时</strong>，无线、有线功能均持续正常工作，足以胜任日常使用。</p><p>温度控制方面。 IPQ6000 的高性能伴随着高热量，但配合双风扇的散热底座，在 6～22°C 的南方冬季，兆能 M2 的温度也能控制在 40°C 以下。当然，夏季的表现需要等待夏季到来时观察，但根据我<a href="https://sspai.com/post/88679" target="_blank">上一版固件</a>的经验，散热底座也能「驯服」路由器面临的高温难题，使兆能M2持续稳定运行。预计我的新固件也将在夏天有不错的稳定性。</p><figure class="image ss-img-wrapper image_resized" style="width: 664px;"><img src="https://cdnfile.sspai.com/2026/01/13/2465bb09ada2523d3c6f3c96d8d67af1.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>运行状况一览。</figcaption></figure><h2>写在最后</h2><p>兆能讯通M2，如此强悍、性价比如此之高，且可玩性又如此之强的 WiFi6 路由器，可遇而不可求。<strong>如果你只把兆能M2当作有线路由器使用，舍弃它的无线功能，说实话我是觉得挺可惜的。</strong></p><p>诚然，在它诞生以来数年，受条件所限，也许我们只能无奈地舍弃WiFi功能。但以 Lean 推出的新版 OpenWRT 固件源码作为基础，经由我加回无线功能后编译的新固件，已经完全弥补了这一遗憾，因此是时候让兆能M2全面发挥无限效能了。</p><p>相信以上这篇教程能对你有所帮助。</p><p style="margin-left: 0px;">&gt; 关注&nbsp;<a href="https://www.xiaohongshu.com/user/profile/63f5d65d000000001001d8d4" target="_blank">少数派小红书</a>，感受精彩数字生活 🍃</p><p style="margin-left: 0px;">&gt; 实用、好用的 <a href="https://sspai.com/mall">正版软件</a>，少数派为你呈现 🚀</p>
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://sspai.com/post/105331</id>
            <title>如何用 claude code 把 claude code 变成个人助手</title>
            <link>https://sspai.com/post/105331</link>
            <guid isPermaLink="false">https://sspai.com/post/105331</guid>
            <pubDate></pubDate>
            <updated>Mon, 12 Jan 2026 12:58:51 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>我不是程序员，编程能力也一般，但是前两天我花了一个下午用 claude code 和 claude agent sdk，在自己的服务器上构建了一个完整的个人 AI agent 小助手，虽然还比较粗糙，但是我现在可以24/7 通过它分析数据、处理文件、构建界面。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/10/5c4dceea3dd4addd2d6d40cc1eeff610.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p>全程我没有写一行代码，只是在构思和交流。在和 claude code 交流，并且目前还一直在迭代，以后也一定是这样的方式，我想这就是 vibe coding 的乐趣，不是掌握编程语言或框架，而是把 AI 当作你思维的延伸——以对话的速度，把模糊的想法变成真实可用的产品。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/10/284afdafb7312bdbd59da657f2925d52.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><h2>产品感比代码能力很稀缺</h2><p>今年，我自己构建了几十个 demo，不是为了炫耀，而是我发现：demo 是传达想法最有效的媒介。</p><p>也是得益于此，我进入到 AI 初创当产品经理，后来 mentor 跟我说我的简历都没有表现出我和公司的契合度，而是我在 github 里面的一些项目，让他特别想要我。</p><p>demo 有几层价值，首先是把你的思想外化，把模糊的想法变成具体的，在你实践的过程中，你会发现你接下来的思考会更轻松，因为你的思考是基于一个已有的东西去延伸，而不是一直在天马行空的想象。就像 AI 的思考模式一样，可视化你的思考过程往往会改变你的结论，先前的 token 会收敛你后面 token 的输出，不至于最后想法很好，实践起来就…</p><p>第二个就是我在前文提到的，让别人相信你看到的，建立信任。在学校的时候，很多人对 AI 的理解还只是停留在简单的对话，我写了很长的如何用 AI 高效分析、调研、访谈的工作流方案，想和同学一起做一些事来赋能一下现有的工作——没反应。然后我做了一个 demo，用 coze 和飞书表格，只花了几个小时，将我们之前的来访者访谈到分析的整个过程流程化。从来访者预约、时间安排、到访前通知以及过程中录音转写到分析，然后他们就信了。</p><p>为什么？因为&nbsp;<strong>demo 是信息密度最高的格式</strong>：报告会让人睡着、Slides 会让人分心、Demo 让人看到自己眼睛的真实信息…</p><p>第三层就是 AI 已经让我们（至少是我这样没技术背景的人）利用最低的成本，让别人看到你的想法到产品。从概念到可用产品，demo 的成本最低，一个下午+一个 AI 工具 = 你可以展示给 100 个人的东西，这就是为什么我对 demo 着迷。</p><figure class="image ss-img-wrapper image_resized" style="width: 488px;"><img src="https://cdnfile.sspai.com/2026/01/10/f7f3810f3f84df95e6ef3bdcaeb11ad1.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><h2>vibe coding 的六大核心技巧</h2><figure class="image ss-img-wrapper image_resized" style="width: 440px;"><img src="https://cdnfile.sspai.com/2026/01/10/551f859394de7ebb00cae1f86cb548a7.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><h3>技巧 1：不要凭空创造，学习别人已经做过的</h3><p>这听起来有点反直觉是吧，而且很多人肯定会说你这不就是抄，但这是最快的前进方式。</p><p>当我用 claude code 构建一个 web dashboard 的时候，我没有让他凭空创建，而是：</p><ol><li>在 GitHub 上找一个开源前端项目</li><li>告诉 AI：「按照这个项目的设计风格，给我一个 React Dashboard 组件库」</li><li>AI 理解了美学，直接生成了匹配的代码</li></ol><p>假如我直接创造呢？他会给我一个「给我一个漂亮的 dashboard」，但是需要 10 轮反馈调整颜色、间距。我很清楚，自己并不是一个设计师，并且我自己脑子里的想法甚至都不是很清楚，与其去做填空题，不如去做选择题。</p><p>在哪搜索？GitHub 上的开源项目（包括样式表）、设计展示网站（Dribbble、Behance）、竞品代码（用浏览器开发者工具检查）…</p><p>我自己无聊的时候比较喜欢看 mobbin，去刷一刷网站或者上 x 去看看大家的分享，然后用 mymind 去记录一些好的创意，不仅仅是记录，有时候光看这些就挺开心的。</p><figure class="image ss-img-wrapper image_resized" style="width: 454px;"><img src="https://cdnfile.sspai.com/2026/01/10/096b12be277f119bf3caf100e325646d.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><figure class="image ss-img-wrapper image_resized" style="width: 455px;"><img src="https://cdnfile.sspai.com/2026/01/10/fc9de359166b4562088184b20d2051c7.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p>其实不仅仅是一个设计，包括说一些有用的，可能我现在用不上，但是我觉得它非常有用，我就会先把它记录下来。后面我需要的时候，我就直接从中去找。</p><p>有一个记录的过程，就会让你的记忆留下一个印象。你后续再去做一个什么东西的时候，可能就会想起这个东西。想起这个东西，你就不用再去大海捞针地去找，你可以从已经收集到的地方去进行一个寻找。</p><p>这不是「拼凑怪物」——这是最高效的学习方式。著名的 Roguelike 游戏开发方法论就是这样：站在巨人肩膀上，快速迭代。</p><h3>技巧 2：<strong>不断问 AI，逐步探索——每个操作前都要问为什么</strong></h3><p>我最初对 VPS 一无所知。什么是 SSH？端口转发怎么用？Docker 是什么？</p><p>但我没有去买课程，而是<strong>在每个操作前都问 AI：</strong></p><ul><li>「我怎样在手机上远程控制 Claude Code？」</li><li>「这个 SSH 密钥是用来干什么的？」</li><li>「Docker 对我的项目有什么好处？」</li></ul><figure class="image ss-img-wrapper image_resized" style="width: 409px;"><img src="https://cdnfile.sspai.com/2026/01/10/c6ea49d03ecd972f49848deda3474128.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p><strong>AI 会</strong>解释概念、给具体步骤、遇到问题时帮助调试，所以我现在就能直接从手机 push 代码到 GitHub，用 Claude Code 在远程服务器上工作。我从未上过一堂 Linux 课，但我学会了「做事」。</p><p>这也是我认为的 vibe coding 的精髓之一：不是「先学技术，再使用它」，而是「让问题驱动学习」，这样每个提问都是一个教学时刻，也算是干中学吧。</p><h3><strong>技巧 3：渐进式开发——理清顺序和依赖关系</strong></h3><p>构建 AI Bot 时，我最初的计划是：先做消息处理器、再做用户管理、再做会话管理、再做Agent 集成、最后安全方面…</p><p>但是到了第三步的时候，我发现安全需要提前设计，比如说一些权限隔离。然后像消息处理器，它就依赖后话管理的接口定义，那用户管理又需要去预留配额的空间，所以我就跟 AI 一起去重新排序。</p><p>我首先就是去定义这个数据模型，比如说 user、session、task 结构。然后第二步就去实现这个核心的逻辑，像 agent 和 mcp server。然后第三步就是添加约束层，就是每个用户它有多少的存储空间。</p><p>因为我这个项目不仅给我自己用，它会给我家里人一起用，帮他们把一些生活上的一些需要用到 AI 的东西全部打包放在这个 bot 里面。所以我会给每个人都会配一定的配额，毕竟 VPS 它的存储是有限的。</p><p>然后权限和安全方面，因为我给他们直接用的是 Claude agent，如果不有一些权限的限制的话，那有可能他们的提示不小心触发了 Claude agent 的一些操作，就会把我整个项目给损毁。所以我就添加了一些安全的一些权限。</p><p>最后就是集成交付层，就比如和聊天软件去集成。</p><figure class="image ss-img-wrapper image_resized" style="width: 463px;"><img src="https://cdnfile.sspai.com/2026/01/10/a0f56deeb110bd8e10322866a10ab896.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p>这个顺序的好处就是我后面的模块，就不用后面模块的添加就不用去改变前面模块的一个接口。所以我加新功能的时候，AI 的上下文就会更加清晰。而且我一旦出现了 bug，我就知道我具体是哪一个层面出现的问题，我就直接去针对性地修改这一个层面就好了。</p><p>这其实就是一个基础的系统设计，我个人认为虽然我不懂代码怎么去实现，但是很多架构方面的东西你要想清楚。</p><p>就像我们去做事情一样，整个一个先后顺序，你去驱使 AI 去做事情也是有一个先后顺序，所以 AI 能够帮你去实现它，但是你自己必须要思考清楚。</p><h3><strong>技巧 4：一个文件，一个工作——写模块化代码</strong></h3><figure class="image ss-img-wrapper image_resized" style="width: 499px;"><img src="https://cdnfile.sspai.com/2026/01/10/013a5222ef9ec5411ed169430355774c.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p>如果一个文件有 2000 行，AI 出错的概率成倍增加。如果一个文件 100 行，只做一件事：</p><ul><li>AI 的上下文更好</li><li>你能更快定位问题</li><li>改动的影响范围受限</li></ul><pre class="language-"><code>bot/
├── handlers.py          # 仅处理 Telegram 命令
├── agent/
│   ├── client.py        # 仅连接 Claude Agent
│   ├── tools.py         # 仅定义自定义工具
│   ├── task_manager.py  # 仅管理后台任务
├── user/
│   ├── manager.py       # 仅管理用户数据
│   ├── storage.py       # 仅处理配额
├── session/
│   └── manager.py       # 仅管理会话

</code></pre><p>LLM 在小的、聚焦的任务上表现肯定是更好，当你要求它「写完整系统」时，就像 10 个开发者同时编码但不沟通、非常混乱。</p><figure class="image ss-img-wrapper image_resized" style="width: 440px;"><img src="https://cdnfile.sspai.com/2026/01/10/932bda5f04a7e81b3485e667f72fae5d.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p>所以我一般就是一个文件实现一个目标，然后不同的功能就放不同的文件夹里面。</p><p>当我想要去改某个功能的时候，我就告诉他在哪个文件里面去添加一个什么样的函数，或者说他自己就能够根据文件结构自己去非常确定地知道在哪里，而不是说一类功能你把它拆到了不同的文件里面去放。那这样子就会非常混乱，他就很容易搞错。</p><h3><strong>技巧 5：架构思考（5 分钟头脑风暴）</strong></h3><p>在每次开始写代码，我会先把我的想法给 AI，先去说我会先跟他说，我们先讨论一下，你可以先不急着去往后实现出来，然后看有什么样的一个方式，能不能实现。</p><figure class="image ss-img-wrapper image_resized" style="width: 413px;"><img src="https://cdnfile.sspai.com/2026/01/10/f89075728d86688347529dc129f47ca8.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p>首先我先要问他能不能实现，要实现的方案有什么样子的，然后他会给我一些架构的建议，以及一些潜在的问题，还有一些那种方案的选择，就让我能更有掌控感。</p><p>这样我也能够确定我的想法不会特别离谱，或者说他需要、他无法实现什么东西，然后他又需要什么，比如说一些 API key 啊，或者说一些外部服务的时候，他能够去指导我，去帮他去获取。</p><p>我感觉好的架构它能够预防你 80% 的后续问题，并且「先改架构」是比你「开始架构好了后面去改代码」这样是更容易一些。</p><p>并且对于我这样没有什么开发经验也没有系统学习过的人，我觉得 AI 的建议往往是会超过我的知识。所以你在干什么事情之前都去问清楚，跟他讨论清楚。如果你自己不放心，每个人再去做一些事实核查，用其他的 AI 做核查也是一样的。</p><h3><strong>技巧 6：利用 Claude Code 和 Agent SDK</strong></h3><p>这真的是 vibe Coding 的最高杠杆工具。我真感觉这个好东西就是被 code 这个字眼给耽误了，claude code 何必只能写代码…</p><p>2025年9月，当 Anthropic 宣布将 Claude Code SDK 正式更名为 Claude Agent SDK 时，这不仅是一次命名变化，更加表达了他不仅仅是写 code 也能够胜任通用任务。</p><p>官方工程博客明确表示：「The key design principle behind the Claude Agent SDK is to give your agents a computer, allowing them to work like humans do.」</p><p><strong>Claude Agent SDK 的核心优势：</strong></p><ul><li><strong>MCP Server：</strong>&nbsp;让 AI 使用自定义工具</li><li><strong>上下文管理：</strong>&nbsp;自动管理上下文和会话</li><li><strong>工具调用：</strong>&nbsp;AI 可以主动调用你的函数</li></ul><p>比如你就去跟 claude Code 说，使用 claude Agent SDK 构建一个花费分析器，用户上传收据图片，Agent 提供统计、分类、支出。那他就能够直接去用这个 SDK 去写一个整体的框架，去处理你的文件上传，管理对话状态，调用你的自定义攻击。</p><p>并且 Claude Code 在他的 plugin Marketplace 里面就有 能帮你去写基于 claude agent sdk 程序的插件，也就是说他自己就能够去查看这个 SDK 去帮你写，不需要你自己去查一些使用文档，去告诉他该怎么写。</p><figure class="image ss-img-wrapper image_resized" style="width: 444px;"><img src="https://cdnfile.sspai.com/2026/01/10/32566bb3f0db6ec762d8c427211cd3eb.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p>所以他对用他来写 Claude Agent SDK 相关的一些软件或者功能是非常友好的，非常顺滑的。如</p><p>果你用传统的方式，你去把一些文档、使用文档去复制粘贴给他，或者说告诉他怎么去做，他就很容易会遇到一些错误情况。因为他自己本身就不了解，然后他在去调用一些服务的时候，他就很容易把接口写错，就会出问题。</p><h2><strong>从想法到产品的完整工作流</strong></h2><h3><strong>步骤 1：问题定义，不是解决方案</strong></h3><p>我认为错误的方式是你教他用 Python 写一个项目，用 Flask API 集成 claude API 等等。我觉得正确的方式：我想在自己的服务器上有一个东西，然后能够随时通过指令，出了问题让他处理文件。</p><p>这两个有什么区别呢？</p><p>首先，为什么我会使用第二个方式？也是因为我对于技术的了解不是那么多，所以我也不会去问他像第一个问题那样子那么具体，让他去用什么技术的一个问题。</p><p>然后第二个就是，我觉得第一种方式限制了 AI 的思考，因为你怎么能够确定你用 Python 方向就一定是用 Python 这个语言去写，一定就是对你这个程序是最友好的呢？然后说 Flask API 难道就一定是最优的吗？</p><p>所以我第二种就是直接让 AI 自己去判断、去选择最佳的框架。那我们只用去定义 what 和 why，那 AI 他自己去推荐 how。</p><h3><strong>步骤 2：架构思考——5 分钟头脑风暴比 5 小时返工更值</strong></h3><p>在开始写代码之前，我会先和 AI 进行一次架构对话。这个步骤很多人会跳过，因为他们觉得「反正 AI 会帮我写」，但这恰恰是最容易踩坑的地方。</p><p><strong>我会这样和 AI 对话：</strong>「我想做一个 Telegram Bot，用户可以通过它和 Claude Agent 交互。这个 Bot 需要支持多用户，每个用户有独立的工作目录和存储配额。你觉得应该怎么设计模块？有什么潜在的问题？」</p><p>然后 AI 会给我一个初步的架构建议。但这里的关键不是 AI 给了什么答案，而是<strong>我怎么评估这个答案</strong>。</p><p><strong>我会问自己三个问题：</strong></p><p><strong>我能理解这个架构吗？</strong></p><p>如果 AI 给我的架构我自己都看不懂，那后面出了问题我根本没法调试。比如第一次 AI 给我的方案里，它建议用一个复杂的事件驱动架构，有 Message Queue、Event Bus 什么的。听起来很专业，但我根本不理解这些东西是干什么的。</p><p>所以我直接告诉 AI：「这个太复杂了，你能给我讲一下不，通俗易懂一点」。总之不会就要问，AI 又不会骂你，他会细心的教你。</p><p><strong>哪个模块风险最大？</strong></p><p>AI 的初始方案很简单，它把整个系统分成四层：Telegram 交互层、Agent 客户端层、用户管理层、数据存储层。听起来很清晰，但我意识到一个问题：<strong>安全</strong>。</p><p>我的 Bot 可以读写服务器上的文件，如果用户A可以访问用户B的文件怎么办？如果 AI 出错，把我的整个服务器文件都删了怎么办？这些 AI 在初版架构里都没考虑到。</p><p><strong>需要加安全层吗？</strong></p><p>所以我又问 AI：「如果一个用户恶意操作，或者 AI 出现 bug，怎么保证系统的安全？」</p><p>AI 给了我几个建议：路径隔离、Docker 容器、权限白名单。这时候我才意识到，<strong>架构设计的时候就要把安全考虑进去</strong>，而不是等到代码写完了再补。</p><p><strong>这 5 分钟的对话，省了我后面至少 5 个小时的返工时间。</strong></p><figure class="image ss-img-wrapper image_resized" style="width: 450px;"><img src="https://cdnfile.sspai.com/2026/01/10/2aa21cefb36bd987db0b740825347bc6.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p>因为如果我直接让 AI 开始写代码，它会按照最直接的方式去实现功能——没有安全检查、没有路径隔离、没有错误处理。等我发现问题的时候，代码已经写了几百行了，改起来又要重新理清楚逻辑。</p><p>架构思考的本质，不是让 AI 告诉你该怎么做，而是逼自己想清楚：这个系统的边界在哪里？最容易出问题的地方是哪里？如果我只能优化一个模块，我会选哪个？</p><h3>步骤 3：<strong>逐模块实现——一次只做一件事</strong></h3><p>确定好架构之后，很多人会直接让 AI「把整个项目写出来」。我一开始也是这么干的，结果就是 AI 写了一堆代码，我完全看不懂，出了问题也不知道从哪里开始查。</p><p>就像人一样，每个人的精力，工作都是一点一点做的。AI 也是一样的，你让他把所有的精力都用来做一个东西，他就能做得好。但如果你让他分散精力去想那么多事情，他可能就没有那么多精力，就会容易出错。所以我后面也是一次就让 AI 做一件事。</p><p>比如说我要去做一个用户管理模块，我不会说让他直接去帮我写一个用户管理系统，因为太模糊了，他自己可能会脑补很多你根本不知道的功能。</p><p>得具体一点，实现一个 user manager，有什么功能，比如创建用户、获取用户的配置、检查存储配额，然后更新存储的配额使用量，然后每个用户它的数据又是在一个单独的文件夹上。</p><p>这样子 AI 就知道边界在哪里，就不会写着写着就跑偏了。</p><p>如果你自己都想不清楚的东西，你也可以把你的想法你就跟他说，我要写一个用户管理模块，然后你就问他用户管理模块大概有什么样的部分。把一个大需求你跟着他一起把它给拆分下来，然后一个一个的来做，相对来说写起来也不会那么容易出错。</p><h3>步骤 4：<strong>处理错误和细节——让 AI 自己测试，给 AI 足够的上下文</strong></h3><p>代码写完不代表就能用了。我感觉花在调试上的时间比写新功能的时间还多。慢慢的也就养成了两个技巧，让调试效率提高了很多。</p><p><strong>首先就是让 AI 自己先测试代码。</strong></p><p>以前我会让 AI 写完代码就直接集成到项目里，然后运行整个项目看有没有问题。结果经常是：项目跑不起来，但我不知道是哪个模块出了问题。</p><p>所以现在我会在 AI 写完一个模块之后，直接告诉它：「写几个测试用例，验证一下这些函数是不是正确的。」</p><p>AI 自己写测试、自己跑测试，大部分低级错误——比如参数类型错了、路径拼接错了、边界条件没处理——它自己就能发现并修复。等它告诉我「测试通过」的时候，我拿到的代码质量比「写完直接交付」高很多。</p><p><strong>第二就是报错的时候，给 AI 足够的上下文。</strong></p><p>这是我踩过最多坑的地方。一开始遇到问题，我会直接告诉 AI：「这个功能不工作。」然后 AI 就开始猜——可能是这个问题、可能是那个问题——猜了十轮还没猜对。</p><p><strong>AI 不是神，它需要你告诉它发生了什么。</strong></p><p>现在我报错的方式是这样的：「我上传了一个 2MB 的 PDF，期望得到 Markdown 输出，但系统返回了 'Permission denied'。我觉得可能是目录权限问题，因为这个目录是第一次被写入。」</p><figure class="image ss-img-wrapper image_resized" style="width: 460px;"><img src="https://cdnfile.sspai.com/2026/01/10/441e15599fa7e87ddb312d78b44a027c.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p>这种描述包含了三个关键信息：我做了什么操作、我期望什么结果、我实际得到了什么。有了这些，AI 基本上一轮就能定位到问题。</p><p>这些都是来源于我真实的坑：</p><p><strong>坑 1：URL 拼接错误。</strong></p><p>我用的不是官方的 Anthropic API，而是自己的 API 网关。配置的时候，我把 base URL 写成了&nbsp;<code><strong>https://my-gateway.com/v1</strong></code>。结果一直报错，找不到接口。</p><p>查了半天才发现，Claude SDK 会自动在 URL 后面加&nbsp;<code><strong>/v1</strong></code>，所以实际请求的地址变成了&nbsp;<code><strong>https://my-gateway.com/v1/v1</strong></code>。</p><p>这种问题 AI 帮不了你，因为它不知道你的配置是什么。我的解决方法是：<strong>在集成到项目之前，先用最简单的方式测试</strong>。比如直接用 curl 发一个请求，看能不能通。如果 curl 都不通，那问题肯定在配置上，不是代码的问题。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/10/d27e04ed88c52690a2fa43a9e17f5db6.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p>比如说我这里，我直接问他「你能做什么」，结果呢，他返回了一个 AI API 的报错。这个是在我刚集成了 API 之后，然后就直接去测试，然后他就给我报了错误。</p><p>所以我就一直让他去检查到底是哪里错的。他就必须是用写完了的整体代码去测。</p><p>如果是我在让他集成之前，就先去把这个什么网关配置、模型的名称什么的都自己去测、去填写好，再把它集成进去，就不会那么麻烦。</p><p>因为他现在是跟着整个代码一起去测试，然后整个代码又是跟整个大项目联合在一起的，所以说你让他去测试，就可能会动到其他的部分。这样子就会有一些不必要的麻烦。</p><p>所以你把这个单独的 AI API 让他单独地去测试，就是在最小程度上去减少影响到其他的方面。这样子首先他专门调这个地方也会调得比较专注，第二个也不会牵扯到其他的部分，就是不会把你的测试的部分跟你的生产代码放在一起去混淆。</p><p><strong>坑 2：Markdown 格式问题。</strong></p><p>AI 默认会用 Markdown 格式输出，加粗、斜体、代码块什么的。但我发现 Telegram 对 Markdown 的支持很差，很多格式渲染出来是乱码。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/10/617588dcceb91afcd02080a0d8dfdf37.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p>一开始我想让 AI 在发送前自动转换格式，但这样太麻烦了，而且容易出 bug。后来我直接在系统 prompt 里告诉 AI：「在 Telegram 里发消息时，不要使用 Markdown 格式。不要用&nbsp;<strong>加粗</strong>&nbsp;或&nbsp;<i>斜体</i>。可以用编号列表或者换行来组织内容。」</p><p>当然，其实你这么跟他说，他有时候还是不会去遵守这个prompt 规定。所以我就直接写了一个脚本，用正则公式直接把这些什么「加粗」「斜体」这种原始的格式直接给去掉，问题直接从源头解决了。</p><p><strong>坑 3：目录不存在。</strong></p><p>有一次我家里人上传文件，系统报错「目录不存在」。原因是代码里假设目录已经存在，但对于新用户来说，他的专属目录还没有被创建过。</p><p>这种问题在本地测试的时候不容易发现，因为你自己测试的时候目录都是现成的。解决方法很简单：让 AI 在写入文件之前，先检查目录是否存在，不存在就自动创建。</p><p>但更重要的是，这让我意识到：<strong>很多 bug 不是代码逻辑的问题，而是环境假设的问题</strong>。AI 写代码的时候，它假设的环境可能和真实运行的环境不一样。所以我现在会特别注意问 AI：「这段代码有什么前置条件？需要什么目录、什么权限、什么依赖？」</p><p><strong>总结一下处理错误的心法：</strong></p><ol><li><strong>先让 AI 自己测，减少低级错误</strong></li><li><strong>报错时给完整上下文：做了什么、期望什么、得到什么</strong></li><li><strong>集成前先用最小方式验证（curl、简单脚本）</strong></li><li><strong>问清楚代码的前置条件和环境假设</strong></li></ol><p>归根结底，调试不是玄学，是信息战。你给 AI 的信息越完整，它帮你定位问题就越快。</p><h2><strong>产品思维——代码能学会，这个学不会</strong></h2><figure class="image ss-img-wrapper image_resized" style="width: 537px;"><img src="https://cdnfile.sspai.com/2026/01/10/39a13f0cfdb9481d7f9133ea65bd3755.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p>到这里，有人可能会觉得：用 AI 写代码也没什么难的嘛，跟着步骤来就行了。</p><p>但我想说的是，<strong>代码只是最容易的部分</strong>。真正决定你做出来的东西能不能用、好不好用的，是你的产品思维。而这个东西，AI 帮不了你。</p><p>我举几个我在做 AI Agent Bot 时的真实例子。</p><p><strong>设计 1：为什么要做存储配额系统？</strong></p><p>一开始我没想过这个问题。用户上传文件，我就存到服务器上，很简单。</p><p>但后来我算了一笔账：我的 VPS 总共 150GB 硬盘空间。如果我开放给 10 个朋友用，每个人传 20GB 的文件，硬盘就满了。更糟的是，如果有一个人传了 100GB，其他人就没法用了。</p><p>这时候我意识到，<strong>我需要一个配额系统</strong>。</p><p>但配额设成多少合适？我想了想自己的使用场景：日常处理的文件，PDF、图片、文档，加起来可能也就几百 MB。给每个用户 5GB，足够用了，而且 150GB 可以支持 30 个用户，还留有余量。</p><p>这个决策 AI 能帮我做吗？</p><p>这也是可以的，你可以让他自己去查整个系统的一个配置，然后你再跟他说你大概有几个人会来使用，调研大概多少是合适的。</p><p>然后包括说，你可以让他去设计那种：他的每一次用户上传的文件或者产生新文件，他就要自己去整理这种文件系统，他要有意识地去提示用户，提醒文件「你这个文件需要整理了，你要怎么怎么样」。</p><p>AI 很快就把代码写出来了。但「5GB」这个数字，是我们讨论想出来的。</p><p><strong>AI 是执行者，你是决策者。</strong>&nbsp;你要想清楚「做什么」和「为什么」，AI 负责「怎么做」。如果你自己都没想清楚，AI 写出来的东西就算能跑，也不一定是你真正需要的。</p><p><strong>设计 2：消息太长怎么办？</strong></p><p>这个问题是我在实际使用中发现的。</p><p>有一次我让 AI 分析一个长文档，它返回了一大段分析结果，大概 2000 多字。结果 Telegram 显示出来一团乱麻——因为 Telegram 对长消息的 Markdown 渲染很差，格式全乱了，而且滚动起来也很难受。</p><p>我第一反应是让 AI 把消息拆成几段发。但试了之后发现体验也不好，几条消息刷屏，而且上下文被打断了。</p><p>后来我想到一个办法：<strong>如果回复超过 1000 字，就自动打包成 .txt 文件发送。</strong></p><p>这样用户收到的是一个文件，点开就能看完整内容，排版也不会乱。而且文件可以保存、可以转发，比一堆消息实用多了。</p><p>这个改动从技术上看很简单，就是加一个字数判断和文件生成的逻辑。但<strong>这是一个产品决策，不是技术决策</strong>。AI 不会主动告诉你「消息太长体验不好」，因为它不知道 Telegram 的渲染有多烂，也不知道用户拿着手机看长消息有多难受。</p><p>这种细节，只有你自己用过、踩过坑，才会想到要优化。<strong>用户体验的提升，往往就藏在这些「小」决策里。</strong></p><p><strong>设计 3：安全问题怎么想？</strong></p><p>这是我花时间最多的一个设计。</p><p>我的 Bot 有一个核心能力：它可以读写服务器上的文件。这是它的价值所在，但也是最大的风险。</p><p>我问自己几个问题：</p><ul><li>如果 AI 出 bug，会不会把我服务器上的重要文件删了？</li><li>如果用户 A 能访问用户 B 的文件怎么办？</li><li>如果有人通过 Bot 执行恶意命令怎么办？</li></ul><p>这些问题 AI 不会主动帮你想，因为它只负责实现你提出的功能。<strong>安全是你自己的责任。</strong></p><p>想清楚风险之后，我做了几个决策：</p><ol><li><strong>禁用 bash 执行。</strong>&nbsp;Claude Agent SDK 默认可以执行任何系统命令，这太危险了。我只需要 AI 能读写文件，不需要它能执行&nbsp;<code><strong>rm -rf /</strong></code>。所以我在配置里把 bash 权限关掉了。</li><li><strong>路径隔离。</strong>&nbsp;每个用户只能访问自己的目录&nbsp;<code><strong>users/{user_id}/data/</strong></code>。任何试图访问这个目录之外的路径，都会被拒绝。这样就算 AI 出错，影响范围也只限于这个用户自己的文件。</li><li><strong>Docker 容器隔离。</strong>&nbsp;整个 Bot 跑在一个 Docker 容器里。就算最坏的情况发生——容器里的东西全被搞坏了——我只需要重建容器就行，不会影响到服务器上的其他东西。</li><li><strong>管理员面板。</strong>&nbsp;我给自己做了一个管理功能，可以查看所有用户的配额使用情况，可以禁用某个用户。这样如果有人滥用，我能及时处理。</li></ol><figure class="image ss-img-wrapper image_resized" style="width: 468px;"><img src="https://cdnfile.sspai.com/2026/01/10/28c35d741904a3b092e33950f422bc86.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p>这些措施听起来好像很「专业」，但其实都是常识。<strong>不是什么高级工程，就是基础的安全意识。</strong>&nbsp;关键是你要主动去想「会出什么问题」，而不是等问题发生了再补救。</p><p>我们之前也看到了很多人去用一些提示词注入去搞什么破解。然后他们通过怎么去诱导 AI，然后用到 agent，我们去把他们的一些环境给破坏掉的这种，这种新闻我觉得之前还是说得蛮多了。</p><p>所以你只要看得多了之后，你大概也会有这样一个意思，所以我觉得安全是一个必要的方面。就算你虽然不知道具体你要怎么去做，但是你一定要考虑到这个方面。你可以去问它，但是你不能忘了去问。</p><p>所以从整体上来说，我在做这个产品，最开始是为了给身边人、给家人用，但其实我的整个设计就是按照一个「想要把它给别人、给大家去用」的想法来做的。虽然我还不知道怎么去做这种商业化，但是我觉得这才是一个正常的产品。</p><p>我们从一开始就要养成这样的习惯，不是说 demo，你就什么都可以不用去管，或者说你给身边的人使用，你也不用去管很多东西，但我觉得这是一个习惯。</p><p>可能你现在只能做一个 demo，但是随着你的能力慢慢成长起来，你就可以做一些大的产品。你从小就把这个习惯养好了之后，后面就可以减少很多不必要的麻烦。</p><p>回顾这三个设计，我发现它们有一个共同点：<strong>都是在回答「为什么」的问题。</strong></p><ul><li>为什么要有配额？因为资源有限。</li><li>为什么长消息要变成文件？因为用户体验更好。</li><li>为什么要做这么多安全措施？因为风险真实存在。</li></ul><p>这些「为什么」，AI 回答不了。它只知道「怎么做」——你告诉它要配额系统，它就写配额系统；你告诉它要生成文件，它就生成文件。但它不会问「我们真的需要这个吗？」或者「有没有更好的方案？」</p><p><strong>这就是为什么我说产品思维是差异化因素。</strong></p><p>会用 AI 写代码的人会越来越多，这个门槛已经很低了。但能想清楚「做什么」和「为什么这样做」的人，永远是少数。</p><p>不会写代码，反而是一种优势。因为你不会陷入技术细节里，你会更多地思考：这个东西到底解决了什么问题？用户真正需要的是什么？有没有更简单的方案？</p><p><strong>代码是手段，产品是目的。</strong>&nbsp;AI 帮你搞定了手段，但目的只有你自己能定义。</p><h2>快去干吧！</h2><p>我在这个过程当中其实一直使用的工具是 Claude Code，所以我觉得大家可以赶快去使用起来，不仅仅是用它写代码，也可以让它帮你做一些个人生产力上的一些方法、一些实践吧。</p><p>比如有的人就用它去跟 Obsidian 结合起来，去和知识管理放在一起。然后有的人又用它去做一些自动化的操作，自己写一些 skill，把自己的sop梳理下来。 我也看到有人会给自己设定一些文件夹，把文件夹对应成生活、工作方面的一些不同部分，然后 agent 相当于是他的一个个人秘书，帮他去管理、帮他去管理这些文件夹。</p><p>就是很多这样的实践，其实工具它的能力是很强的，可能现在限制我去用它的一些方面，就是我自己的一个想象力、审美吧。</p><p>然后现在也已经有很多教程教大家怎么去用这类产品，包括说像 OpenCode 也有人推荐，如果说 Claude Code 太贵的话，也可以去用国内的智谱的 GLM，这个教程也是有很多的。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/10/6f06a62065eb903969e0a4a593f8f271.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p>包括这个新手指南写的挺好的，然后可以看第一、二、三章，看完差不多就开始用了。后面的那些教程，其实你可以在做项目的过程当中自己一点一点去摸索，然后逐渐学习：<a href="https://claudecode.tangshuang.net/easy-tutorial">https://claudecode.tangshuang.net/easy-tutorial</a></p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/10/9e2d9a36da4eedc73a8cd7a4f6084cfb.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><h2><strong>为什么普通人要多 Vibe Coding</strong></h2><p>写到这里，我想聊聊一个更大的问题：<strong>为什么我觉得不会编程的人，反而应该多用 AI 去构建东西？</strong></p><p>这个问题我想了很久，因为很多人会觉得「我又不是程序员，学这个干嘛」。但我的体会是，Vibe Coding 带给我的收获，远不止「做出了一个 Bot」这么简单。</p><figure class="image ss-img-wrapper image_resized" style="width: 501px;"><img src="https://cdnfile.sspai.com/2026/01/10/9ae446f4cadde65fd37253cf0fce6a26.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p><strong>第一，边干边学是最高效的学习方式。</strong></p><p>传统的学习路径是这样的：先学编程语言，再学框架，再学架构设计，然后才开始做项目。这条路走下来，少说也要一两年。而且很多人学到一半就放弃了，因为学的时候不知道这些东西有什么用，纯粹是在「为了学而学」。</p><p>Vibe Coding 的路径完全反过来：你先有一个想做的东西，然后边做边学。遇到不懂的，问 AI；卡住了，让 AI 帮你解决。整个过程可能只需要几天甚至几个小时，你就能做出一个可以用的东西。</p><p><strong>区别在哪里？动力。</strong></p><p>当你是为了解决自己的问题而学习时，每一个新知识都有明确的用途。我学 Docker 不是因为「Docker 是热门技术」，而是因为「我需要把我的 Bot 隔离起来，不然出问题会影响整个服务器」。这种学习是有目标的，所以记得住、用得上。</p><p>而且，这种方式的反馈循环特别短。传统学习可能学了三个月还看不到成果，Vibe Coding 可能聊了三个小时就有一个能跑的 demo 了。每一次小的成功都会给你动力继续往下做，形成正向循环。</p><figure class="image ss-img-wrapper image_resized" style="width: 509px;"><img src="https://cdnfile.sspai.com/2026/01/10/5c0851be2e59756905892850296008bc.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p><strong>第二，Demo 是最有说服力的沟通方式。</strong></p><p>这一点我在前面聊过，但我想再强调一下，因为这对不会编程的人来说太重要了。</p><p>以前，如果你有一个想法，你只能写文档、画原型图、做 PPT。但这些东西都是「描述」，不是「展示」。你说「我想做一个能自动分析数据的工具」，别人听了可能觉得「哦，又是一个想法」，然后就没有然后了。但如果你直接做一个 demo 出来，哪怕很粗糙，别人能亲手用一下、看到真实的效果，说服力完全不一样。</p><p><strong>Demo 是穿透认知壁垒的最短路径。</strong>&nbsp;而 Vibe Coding 让不会编程的人也能做 demo 了。这是一个巨大的能力解锁。</p><p><strong>第三，这是系统化思维最好的训练场。</strong></p><p>很多人觉得「系统化思维」是一个很虚的概念，不知道怎么培养。但我发现，用 AI 做一个完整项目，是培养系统化思维最实际的方式。</p><p>因为你必须想清楚很多问题：</p><ul><li>这个系统有哪些模块？它们之间怎么交互？</li><li>先做什么，后做什么？为什么是这个顺序？</li><li>如果这个模块出问题，会影响哪些其他模块？</li><li>资源有限的情况下，哪些功能是核心，哪些可以砍掉？</li></ul><p>这些问题在传统工作中很少有机会思考，因为大多数人只负责自己那一小块。但当你自己从零开始构建一个东西时，你必须站在全局的角度去思考。</p><p>而且 AI 会逼着你把想法表达清楚。你不能说「帮我做一个好用的系统」，你得说清楚「好用」是什么意思、「系统」包含哪些功能。这个过程本身就是在训练你把模糊的想法结构化。</p><p>做完几个项目之后，我发现自己在工作中思考问题的方式也变了。以前看到一个需求，我会想「这个功能怎么实现」；现在我会先想「这个需求的本质是什么、有哪些相关的模块、改动会带来什么影响」。这种思维方式的转变，比学会某个具体技术更有价值。</p><p><strong>第四，这是认识自己的一面镜子。</strong></p><p>这一点可能有点抽象，但我觉得很重要。</p><p>当你用 AI 做项目时，你会不断遇到「我想要什么」这个问题。AI 会问你：「你想要 A 方案还是 B 方案？」「这个功能的优先级是什么？」「出错的时候应该怎么处理？」</p><p>一开始你会发现，很多问题你自己都没想清楚。你以为自己知道想要什么，但真正被问到细节的时候，你才发现自己的想法是模糊的。</p><p>这个过程会逼着你不断澄清自己的想法。你要问自己：我真正在意的是什么？什么是必须有的，什么是可有可无的？我愿意为了简单牺牲多少功能？</p><p><strong>做着做着，你会越来越清楚自己是一个什么样的人。</strong>&nbsp;你是喜欢复杂但强大的系统，还是简单但够用的工具？你是在意功能完整性，还是在意用户体验？你是愿意花时间打磨细节，还是先上线再说？</p><p>这些问题没有对错，但你需要知道自己的答案。Vibe Coding 给了你一个低成本试错的机会，让你通过实际的选择来认识自己。</p><p><strong>第五，这是管理能力的预演。</strong></p><p>这一点是我后来才意识到的。</p><p>当你用 AI 做项目时，你其实在扮演一个「管理者」的角色。你负责定方向、做决策、分配任务、检查结果。AI 是你的「执行者」，负责把你的想法变成代码。</p><p>这和管理一个团队其实很像。你要学会：</p><ul><li>怎么把一个大目标拆解成可执行的小任务</li><li>怎么清晰地传达你的期望</li><li>怎么检查交付物是否符合要求</li><li>出了问题怎么定位原因、怎么给反馈</li></ul><p>如果你未来想带团队，这些能力是必须的。而 Vibe Coding 给了你一个零成本练习的机会——AI 不会抱怨你的需求不清楚，它只会按照你说的去做。如果结果不对，那一定是你没说清楚。这会倒逼你提升表达能力和任务拆解能力。</p><p><strong>所以，Vibe Coding 到底是什么？</strong></p><p>它不是一种编程技术，而是一种<strong>做事的方式</strong>。</p><p>它的核心是：</p><ul><li><strong>敢于尝试</strong>——因为试错成本很低，最多浪费几个小时</li><li><strong>快速反馈</strong>——做出来的 demo 比任何文档都有说服力</li><li><strong>在行动中学习</strong>——不是先学会再做，而是边做边学</li><li><strong>用 AI 放大自己</strong>——你有想法但不会实现？AI 帮你实现。你有产品感但不会编程？AI 帮你编程</li></ul><p><strong>在 AI 时代，瓶颈已经不是「我能不能写代码」，而是「我知不知道自己想要什么」。</strong></p><p>技术门槛被 AI 抹平了，但想清楚「做什么」和「为什么做」的能力，AI 替代不了。这才是真正稀缺的东西。</p><p>所以，如果你有一个想法，一直觉得「我不会编程，所以做不了」——现在没有这个借口了。</p><p>下载一个 Claude Code 或者 Cursor，把你的想法告诉 AI。</p><p>你会发现，原来自己能做到的事情，比想象中多得多。</p><p>&nbsp;</p>
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://sspai.com/post/105350</id>
            <title>新人报道-obsidian自动监测每周工作时长</title>
            <link>https://sspai.com/post/105350</link>
            <guid isPermaLink="false">https://sspai.com/post/105350</guid>
            <pubDate></pubDate>
            <updated>Mon, 12 Jan 2026 01:18:24 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <h3>实现功能一览：</h3><h4>在日记中的记录：</h4><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/11/343a44f38019a351d5579afe13966cda.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>图1：日记中的记录</figcaption></figure><h4>在月记中的统计实现：</h4><figure class="image ss-img-wrapper image_resized" style="width: 439px;"><img src="https://cdnfile.sspai.com/2026/01/11/c08c31c38b46a1034832c5c55c607cad.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>图2：月记中的统计实现</figcaption></figure><h4>说明：</h4><ul><li>标签列是一级标签，明细列是一级标签下的子标签，只支持两级标签。</li><li>时长统计根据日记中的逐行做差得到。</li></ul><h3>实现：</h3><h4>所需插件：</h4><ul><li>QucikAdd</li><li>DataView</li></ul><h4>日记中的实现：</h4><ol><li>指定一个节名，如图1中的"Time Log"，这对应代码中的：<code>l.section?.subpath === "Time Log"</code></li><li>手动记录每次任务开始时的时间，并加上标签，记录格式为<code>- hh:mm do what #tag</code><ul><li>每次手动输入时间是很麻烦的，可以利用QuickAdd插件制作模板，实现使用快捷键在日记中的指定位置插入当前时间以及你想记录的内容，这一小部分的教程请参考：<a href="https://sspai.com/post/86518">少数派-当 Obsidian 与时间管理相遇</a> 该教程中有两个错误：1. 创建 QuickAdd 的时候，选择 capture 而不是截图中的 template 2. capture format value 是小写。大写的VALUE 无法捕获。</li><li>注意最后一行需要有个不带标签的结束，例如图1中的"END"，这样才能完整做差，计算时间。</li></ul></li><li>需要在日记模板中加入日期与本年第几周的属性：</li></ol><figure class="image ss-img-wrapper image_resized" style="width: 354px;"><img src="https://cdnfile.sspai.com/2026/01/11/cebfd3da14ac115edb8b104dc6332fee.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>图3：日记中的笔记属性</figcaption></figure><ul><li>属性的代码实现如下：<br /><code>---</code><br /><code>date: &lt;% tp.file.creation_date("YYYY-MM-DD") %&gt;</code><br /><code>NO.week: &lt;% window.moment().format("GGGG-[W]WW") %&gt;</code><br /><code>---</code></li></ul><h4>月记中的实现：</h4><p>月记名为"YYYY-MM"格式，不是的话代码无法自动提取，需要你在代码中自行指定月份。</p><p>代码如下，注释挺良好的，记得改下文件夹路径之类的，其他看不懂的，GPT都懂：</p><pre class="language-javascript"><code>/***********************
 * 工具函数
 ***********************/
function parseTime(t) {
  const [h, m] = t.split(":").map(Number);
  return h * 60 + m;
}

function getMonth(day) {
  return `${day.year}-${String(day.month).padStart(2, "0")}`;
}

/***********************
 * 当前月（从月记文件名取）
 ***********************/
const currentMonth = dv.current().file.name.match(/\d{4}-\d{2}/)?.[0];

/***********************
 * 数据结构，不用管，自动填入
 ***********************/
// daily[date][root] = { total, children }
// weekly[week][root] = { total, children }
// monthly[root] = { total, children }

let daily = {};
let weekly = {};
let monthly = {};

/***********************
 * 只有在能识别月份时才执行统计
 ***********************/
if (currentMonth) {

  /***********************
   * 扫描本月所有日记，在“日记”文件夹下
   ***********************/
  for (const page of dv.pages('"日记"')) {

    if (!page.date) continue;

    const pageDate = dv.date(page.date);
    if (getMonth(pageDate) !== currentMonth) continue;

    const dateKey = dv.date(page.date).toFormat("yyyy-MM-dd");
    const weekKey = page["NO.week"] ?? "Unknown";

    daily[dateKey] ??= {};
    weekly[weekKey] ??= {};

    const logs = page.file.lists.filter(
      l =&gt; l.section?.subpath === "Time Log" //Time Log是你自定义的节名
    );

    for (let i = 0; i &lt; logs.length - 1; i++) {

      const curr = logs[i].text;
      const next = logs[i + 1].text;

      const t1 = curr.match(/\d{2}:\d{2}/)?.[0];
      const t2 = next.match(/\d{2}:\d{2}/)?.[0];
      if (!t1 || !t2) continue;

      const hours = (parseTime(t2) - parseTime(t1)) / 60;
      if (hours &lt;= 0) continue;

      const tags = curr.match(/#\S+/g) ?? [];

      for (const tag of tags) {

        const parts = tag.slice(1).split("/");
        const root = "#" + parts[0];
        const child = parts.length &gt; 1 ? parts.slice(1).join("/") : null;

        // 向 daily / weekly / monthly 三个桶同时累加
        for (const bucket of [
          daily[dateKey],
          weekly[weekKey],
          monthly
        ]) {
          bucket[root] ??= { total: 0, children: {} };
          bucket[root].total += hours;

          if (child) {
            bucket[root].children[child] =
              (bucket[root].children[child] ?? 0) + hours;
          }
        }
      }
    }
  }

  /***********************
   * 输出工具
   ***********************/
    function renderTable(title, data, firstCol, withSubtotal = false) {
      dv.header(3, title);

      dv.table(
        [firstCol, "标签", "总时长", "明细"],
        Object.entries(data)
          // 排序（weekly / monthly 都安全）
          .sort(([a], [b]) =&gt; dv.date(a) - dv.date(b))
          .flatMap(([key, roots]) =&gt; {

            const rows = [];
            let subtotal = 0;

            const entries = Object.entries(roots);

            entries.forEach(([root, info], idx) =&gt; {
              subtotal += info.total;

              const childText = Object.entries(info.children)
                .sort((a, b) =&gt; b[1] - a[1])
                .map(([k, v]) =&gt; `${k}: ${v.toFixed(1)}h`) //toFixed中的"1"是小数点后1位
                .join("&lt;br&gt;");

              rows.push([
                idx === 0 ? key : "",
                root,
                info.total.toFixed(1) + "h",
                childText || "&lt;span style='color: gray;'&gt;无&lt;/span&gt;"
              ]);
            });

            // ⭐ 小计行（只在 weekly / monthly 开启）
            if (withSubtotal &amp;&amp; entries.length &gt; 0) {
              rows.push([
                "",
                "小计",
                `${subtotal.toFixed(1)}h`,
                ""
              ]);
            }

            return rows;
          })
      );
    }

  /***********************
   * 三张表
   ***********************/
  renderTable("📊 本月统计", { "本月": monthly }, "范围", true);
  renderTable("🗓️ 每周统计", weekly, "周", true);
  renderTable("⏳ 逐天分布", daily, "日期", false);

} else {
  dv.paragraph("❌ 月记文件名中未找到 YYYY-MM");
}</code></pre><h3>其他：</h3><ul><li>推荐了解：<a href="https://github.com/wangwenyou/obsidian-work-logger">插件-worklogger</a>，实现了QuickAdd的自动记录和月记中自动统计时长的功能，界面优雅，支持接入大模型编写周报等。但对我来说，封装度有点高，我不想为了time log单独建议一个文件夹。</li><li>可结合Charts 插件做一些更精细化的分析，实现可请教GPT大人。</li></ul>
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://sspai.com/post/105280</id>
            <title>旧电脑上的Linux桌面配置小记</title>
            <link>https://sspai.com/post/105280</link>
            <guid isPermaLink="false">https://sspai.com/post/105280</guid>
            <pubDate></pubDate>
            <updated>Sun, 11 Jan 2026 10:17:32 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>我很想直截了当，贴出<a href="https://codeberg.org/cheech/dotfiles">配置文件</a>，让文章就此结束。因为思来想去，我也找不出几个非用Linux桌面不可的理由。但假使你：</p><ul><li>有一台硬件极度落伍（cpu连自己手机的处理器还不如）的电脑。</li><li>厌倦了「又不是不能用」的心态，想要一个能正常更新的操作系统。</li><li>有一定复制粘贴的耐心。</li></ul><p>那么，你可以试着配置一个轻量的Linux桌面，好使行将弃用的机器不至沦为一个摆件。声明在先，这不是一篇教人「改造」、「提升」的文章，配置Linux桌面和追求生产力无关，首先应当作是一种娱乐。</p><h2>选择一个Linux发行版</h2><p>发行版是一个收集、构建、集成并分发公开可用软件的项目。一个典型的Linux桌面发行版包括：</p><ul><li>Linux内核：用于驱动、管理底层硬件。</li><li>GNU工具链：一系列处理文件、文本、编译等方面的系统工具。</li><li>软件包管理器：负责软件的安装更新和依赖管理。</li><li>一个桌面环境：由一些基础组件（如窗口管理器、<a href="https://en.wikipedia.org/wiki/Compositing_manager">混成器</a>、<a href="https://wiki.archlinux.org/title/Desktop_notifications">通知服务器</a>）和一些基础应用（如网页浏览器、文件管理器、终端）组成。</li></ul><p>选择发行版时，除了考虑仓库中软件的丰富度，还要考虑到这些软件是如何被构建（是否在原有代码、配置上进行定制），用于构建的脚本、补丁是否透明可查，相关决策的制定是否规范，社区推行的行为准则等等。如果你之前没有接触过Linux发行版，我建议你跟随Linus Torvalds的脚步，使用<a href="https://fedoraproject.org/">Fedora</a>。</p><p>引用一位Fedora维护者的<a href="https://www.reddit.com/r/Fedora/comments/zb8hqa/comment/iypv4n3">回答</a>，选择Fedora的理由有：</p><ul><li>对成熟度足够的新技术会积极引入。</li><li>坚持「贴近上游」的策略，构建时尽量避免不必要的本地补丁。</li><li>对软件包签名，而非只签名元数据。支持Secure Boot，提升安全保障。</li><li>发布节奏稳定，每半年发行一个稳定版本。用户可借助如<a href="https://docs.fedoraproject.org/en-US/quick-docs/upgrading-fedora-offline/">dnf system-upgrade</a>的命令从旧版本升级。</li><li>背靠红帽公司的技术及资金支持。</li><li>社区友善、包容度高。</li></ul><h2>芜杂的桌面环境</h2><p>除却多达<a href="https://distrowatch.com/search.php?status=Active">数百个</a>可供选择的发行版外，Linux桌面环境的碎片化程度亦不遑多让，其中最为主流的当属<a href="https://www.gnome.org/">Gnome</a>和<a href="https://kde.org/">KDE</a>。Gnome以现代、简洁的设计见长，KDE则提供更丰富的个性化配置 。抛开个人好恶，两者在过时硬件上的表现仅是差强人意，尤其是对一台处理器性能约为N100一半的<a href="https://sspai.com/post/98006">机器</a>来说。因此，围绕混成器<a href="https://yalter.github.io/niri/">niri</a>搭建一个简易的桌面环境是更好的选择。选择niri的理由有：</p><ul><li>默认配置项合理，无需多少改动即可使用。</li><li>克制的交互动画，介于<a href="https://swaywm.org/" target="_blank">sway</a>和<a href="https://hypr.land/" target="_blank">hyprland</a>之间。</li><li>滚动式的平铺布局：将当前的工作区视作一张无限延展的画布，新建的应用窗口不会打破原有窗口的布局，而是出现在当前活动窗口的右侧，并尽可能占据全部高度。对笔记本这样的小屏幕较为友好。</li><li>良好的触摸版手势支持。</li><li>内建<code>Alt+Tab</code>功能，可以仅在当前工作区/显示器上的应用间进行切换。</li><li>开发者Ivan Molodetskikh同时也是Gnome项目的贡献者。niri受Gnome插件<a href="https://github.com/paperwm/PaperWM" target="_blank">PaperWM</a>启发，在UX上也有一些Gnome的影子（比如overview、dynamic vertical workspace）。对Gnome用户来说更容易接受。</li></ul><p>同样因为性能上的考量，如<a href="https://danklinux.com/">dms</a>、<a href="https://noctalia.dev/">noctalia</a>等基于<a href="https://quickshell.outfoxxed.me/">quickshell</a>的现成配置亦不在选择范围之内。</p><h2>欢迎来到真实的荒漠</h2><p>这是你刚装完niri后的样子：</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/09/23f1ffd8633e51ddae7a1169471a3bca.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p>一片荒芜。没有壁纸，没有状态栏，什么都没有。你只能通过快捷键打开终端或预先设定好的几个程序。接下来，我们要在这片荒原上搭积木。</p><h4>壁纸设置</h4><p>使用swaybg。如果有除静态壁纸外的需求，可使用<a href="https://codeberg.org/LGFae/awww">awww</a>。设置其随niri启动。（请阅读该<a href="https://github.com/YaLTeR/niri/wiki/Example-systemd-Setup">指南</a>设置随niri启动的服务。）</p><h4>状态栏</h4><p>使用waybar。需随niri启动。</p><h4>应用启动器</h4><p>使用fuzzel。上位替代有仿raycast设计的<a href="https://docs.vicinae.com/">vicinae</a>。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/09/2d7854796c8733eaa39bead4ae38d735.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>设置完壁纸、状态栏、启动器后的样子</figcaption></figure><h4>通知服务器</h4><p>使用<a href="https://github.com/ErikReider/SwayNotificationCenter">swaync</a>。其余类似软件，如mako、dunst等都过于简陋。需随niri启动。</p><h4>登出菜单</h4><p>使用<a href="https://github.com/nwg-piotr/nwg-bar" target="_blank">nwg-bar</a>。</p><h4>OSD窗口</h4><p>使用<a href="https://github.com/ErikReider/SwayOSD">swayosd</a>，以提示音量、亮度的变化。需随niri启动。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/09/c801ff504dbb0bd1fcefc5c7be22b9dc.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>swaync+nwg-bar+swayosd</figcaption></figure><h4>待机控制</h4><p>hypridle。需随niri启动。</p><h4>锁屏</h4><p><a href="https://github.com/jovanlanik/gtklock">gtklock</a>。hyprlock更轻量， 因<a href="https://github.com/hyprwm/hyprlock/issues/261">显示器独立缩放设置的问题</a>暂不考虑。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/09/c8964b0671dd3dcc741a6e8a2aff1073.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>gtklock</figcaption></figure><h4>终端</h4><p><a href="https://sw.kovidgoyal.net/kitty/" target="_blank">kitty</a>/<a href="https://codeberg.org/dnkl/foot" target="_blank">foot</a>/<a href="https://ghostty.org/" target="_blank">Ghostty</a>中任选其一。</p><h4>浏览器</h4><p>使用Firefox或<a href="https://helium.computer/">Helium</a>。虽然qutebrowser最顺手，奈何其有内存相关的恶性<a href="https://github.com/qutebrowser/qutebrowser/issues/1476">bug</a>。</p><h4>文件管理器</h4><p>使用Thunar。Dolphin次之。Nautilus最不推荐。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/09/f47b5255125953d3d5f1ec7d6be8a32b.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>qutebrowser和nautilus</figcaption></figure><h4>输入法</h4><p>通过fcitx使用rime并安装<a href="https://github.com/amzxyz/rime_wanxiang">万象</a>。在Fedora上，安装<code>fcitx5-autostart</code>使输入法随系统启动。</p><h4>截图</h4><p>使用<a href="https://github.com/Satty-org/Satty">Satty</a>。</p><h4>录屏</h4><p>使用<a href="https://git.dec05eba.com/gpu-screen-recorder/about/" target="_blank">gpu-screen-recorder</a>或OBS。</p><h4>剪贴板</h4><p>使用<a href="https://github.com/sentriz/cliphist" target="_blank">cliphist</a>。需随niri启动。</p><h4>软件管理</h4><p>除开默认的包管理器，可通过<a href="https://flathub.org/en/apps/com.github.tchx84.Flatseal">Flatseal</a>/<a href="https://flathub.org/en/apps/it.mijorus.gearlever">Gear Lever</a>来管理Flatpak/AppImage应用。</p><h2>结语</h2><p>我曾半开玩笑地将配置Linux桌面分为4个阶段：</p><ol><li>使用waybar等组件搭凑一个基本可用的桌面环境。</li><li>想要自定义桌面的方方面面，开始使用如quickshell的组件框架，编写属于自己的桌面环境。</li><li>不满足使用别人的框架，开始着手自建框架。</li><li>回到阶段1。</li></ol><p>本文只讨论了位于1阶段的配置，然而，这份配置已足够使用，并且资源占用很低，保证了老旧机器的流畅运行。回看开头的话：把配置Linux桌面当作一种娱乐——因其与搭积木并无本质上的不同。而每个用户都应有定义自己桌面窗口圆角的权利。</p><blockquote><p>[…] users, because of their widely varying skills and preferences, must be able to customize aspects of the interface.</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -&nbsp;<a href="https://ics.uci.edu/~kobsa/courses/ICS104/course-notes/Microsoft_WindowsGuidelines.pdf">The Windows Interface Guidelines, 1995</a></p></blockquote>
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://sspai.com/post/105335</id>
            <title>Claude Skill 快照：给你的 AI 技能迭代加个「后悔药」</title>
            <link>https://sspai.com/post/105335</link>
            <guid isPermaLink="false">https://sspai.com/post/105335</guid>
            <pubDate></pubDate>
            <updated>Sat, 10 Jan 2026 09:55:46 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>之前 <a href="https://sspai.com/post/105284">我的一篇介绍 Claude Skill 的文章</a> 很受大伙欢迎。很多小伙伴看过之后都跃跃欲试。</p><figure class="image ss-img-wrapper"><img alt="" src="https://cdnfile.sspai.com/2026/01/10/article/73f8e8ca332049b30e9bea54591296c7.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p>不知你都做了几个 Claude Skill 出来了？</p><p>假设为了完成某项任务，你 <a href="https://sspai.com/post/105284">参考我的教程</a> 创作了一个 Claude Code 的技能，并且不断迭代改进。折腾了好几天，技能终于调通了，效果也不错。你长舒一口气，想着「太好了，终于搞定」。</p><p>然后，你有了一个新想法：「要不，再加个功能？」</p><p>手悬在键盘上方，却迟迟不敢落下。</p><p>万一改坏了呢？万一新功能没加成，反而把原来能用的逻辑给弄崩了呢？你不记得之前是怎么调通的了，那些试错的弯路、那些灵光一现的小修改，全都模糊了。</p><p>于是你做了一件事：复制整个文件夹，改个名字。</p><p><code>my-skill-backup</code>。</p><p>过了两天，你又改了一版，又备份一次：<code>my-skill-v2</code>。</p><p>再过几天：<code>my-skill-final</code>。</p><p>然后是 <code>my-skill-final-final</code>。</p><p>最后，你的文件夹里躺着一排沉睡的文件夹：<code>my-skill-final-final-v2 - 真的最终版</code>。</p><p>哪个是能用的？哪个对应哪个功能状态？天知道。</p><p>这就是我说的<strong>​「改进恐惧症」​</strong>——技能调通后不敢动，生怕一动就回不去了。</p><p>今天要聊的这个工具，是我自己（指导 Claude Code）写的 Skill，叫做 "Skill Snapshot"（技能快照），专门治这个恐惧症，给你提供「后悔药」。</p><h2>背景</h2><p>在往下讲之前，咱们先对齐一下背景知识。</p><p><strong>Claude Code</strong> 是什么？你可以把它理解为一个住在命令行里的 AI 助手。它不只是聊天，还能帮你写代码、操作文件、执行命令。它就像一个坐在你电脑里的实习生，你说什么，它就去做什么。</p><p><strong>Skill（技能）​</strong>又是什么？你可以把它理解为给 Claude Code 加装的「专业模块」。就像手机里的 App，每个 Skill 让 AI 学会一项新本领。比如，你可以创建一个「写作助手」技能，专门帮你按照特定风格写文章；或者创建一个「代码审查」技能，专门帮你检查代码质量。</p><figure class="image ss-img-wrapper"><img alt="" src="https://cdnfile.sspai.com/2026/01/10/article/7844a7521636d80649ad784b18e851c5.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p>每个技能本质上就是一个文件夹，里面有一个叫 <code>SKILL.md</code> 的说明书，告诉 Claude Code：这个技能叫什么、能做什么、怎么触发。如果你想详细了解 Claude Skills，<a href="https://sspai.com/post/105284">欢迎查看我的这篇文章</a>。</p><p>就在几天前 ——2026 年 1 月 7 日 ——Claude Code 发布了 <a href="https://www.threads.com/@boris_cherny/post/DTOyRyBD018">2.1.0 版本</a>，带来了一波重大更新。Skills 功能大幅增强：支持热重载、支持自定义代理、可以用 <code>/</code> 直接调用。越来越多人开始创建自己的 Skills，技能的数量在快速增长。</p><p>但技能多了之后，一个新问题浮出水面：<strong>版本管理</strong>。</p><p>你有 10 个技能，每个都在不断迭代。哪个改过了？改了什么？改坏了怎么办？</p><p>这就是我做的 Skill Snapshot 要解决的问题。</p><p>程序员写代码有 Git，设计师画图有版本历史，连 Word 文档都有「修订记录」。但 Claude Code 的技能呢？之前没有现成的方案。</p><p>现在有了。</p><h2>破局</h2><p>我做 Skill Snapshot 的设计思路很简单：<strong>不重新发明轮子</strong>。</p><p>版本管理这件事，Git 已经做了几十年，是业界公认最成熟的方案。云端存储和同步，GitHub 也做得很好。既然有现成的基础设施，为什么要自己从头写？</p><p>所以 Skill Snapshot 的核心思路是：<strong>复用 Git + GitHub，用自然语言包装一层</strong>。</p><p>假设你的技能名称为 <code>my-skill</code>。你不需要记住 <code>git commit -m"message"</code> 这种命令，只需要说「保存 my-skill 快照」，工具会帮你翻译成具体的 Git 操作。</p><p><strong>存储位置选的是 GitHub 私有仓库</strong>。你可以把它理解为上了锁的保险柜——只有你自己能看到里面的内容，别人看不到。免费，安全，还能跨设备同步。</p><p>整个工具提供了 6 个命令，每个解决一个具体痛点：</p><p><code>init</code> 负责初始化 —— 首次使用时执行一次，自动在 GitHub 上创建私有仓库，然后把它克隆到本地。这是一次性的设置，之后不用再管。</p><p><code>save</code> 负责保存快照 —— 在你修改技能之前，跑一下这个命令，当前状态就被存档了。就像游戏里的「存档」功能。</p><p><code>restore</code> 负责恢复版本 —— 改坏了？没关系，一键退回到之前保存的某个版本。这是整个工具的核心价值所在。</p><p><code>list</code> 负责列出历史 —— 查看某个技能有哪些版本，每个版本是什么时候保存的，当时写的说明是什么。对抗记忆衰退。</p><p><code>diff</code> 负责对比差异 —— 当前版本和某个历史快照之间改了什么？一目了然。</p><p><code>scan</code> 负责智能扫描 —— 自动判断你的技能目录里，哪些需要备份，哪些可以跳过。减少决策负担。</p><p>数据流是这样的：你本地的技能文件夹（<code>~/.claude/skills/</code>）通过 <code>save</code> 命令同步到 GitHub 私有仓库，需要恢复时再通过 <code>restore</code> 命令拉回来。中间有一个本地镜像（<code>~/.claude/skill-snapshots/</code>）作为中转站。</p><figure class="image ss-img-wrapper"><img alt="" src="https://cdnfile.sspai.com/2026/01/10/article/6128c1640eb5771f4a8b76fc3ff81b05.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p>以上这些你了解就好，因为你从来不需要像写 Bash 脚本一样去可钉可铆调用这些功能，而是用自然语言跟它对话。甚至可以像我一样弄个话筒，随时拿起来跟 AI 一通「布置工作」。</p><figure class="image ss-img-wrapper"><img alt="" src="https://cdnfile.sspai.com/2026/01/10/article/ca9fa83c1551ccbd8d178fe3afe9f01f.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><h2>上手</h2><p>原理说得够多了，下面咱们不如直接上手试试。</p><h3>第 0 步：安装</h3><p>首先，请你执行以下命令，完成该技能的初始安装：</p><pre class="language-"><code>
git clone https://github.com/wshuyi/skill-snapshot-skill.git

cp -r skill-snapshot ~/.claude/skills/
</code></pre><p>之后，启动 Claude Code 的一个新对话，就可以继续了。</p><h3>第一步：初始化</h3><p>首次使用需要对已有技能的快照初始化，这一步只做一次。</p><p>你在 Claude Code 中，说一句「初始化技能快照」。</p><p>背后发生了什么？工具会用 <a href="https://cli.github.com/manual/gh_repo_create">GitHub CLI</a> 的 <code>gh repo create</code> 命令，在你的 GitHub 账号下创建一个私有仓库，名字叫 <code>skill-snapshots</code>。然后把这个仓库克隆到本地 <code>~/.claude/skill-snapshots/</code> 目录。</p><p>输出大概长这样：</p><pre class="language-"><code>
=== Skill Snapshot 初始化 ===

→ 创建私有仓库: your-username/skill-snapshots

✓ 私有仓库已创建

→ 克隆到本地: ~/.claude/skill-snapshots

✓ 已克隆到本地

=== 初始化完成 ===

私有仓库: https://github.com/your-username/skill-snapshots

本地路径: ~/.claude/skill-snapshots
</code></pre><p>看到这个输出，初始化就完成了。以后不用再跑这一步。</p><p>其实你完全可以不用显式地执行这一步。只要你下达备份某项技能的指令，如果系统发现该技能尚未初始化，它就会自动替你完成这一操作。</p><h3>第二步：扫描技能</h3><p>初始化完成后，你可能想知道：我有哪些技能需要备份？</p><p>你不需要挨个地打开技能去翻找，只需要说一句「扫描技能」。</p><p>工具会遍历你的 <code>~/.claude/skills/</code> 目录，用一套规则自动判断：哪些是你自己写的、需要备份的技能；哪些是外部安装的、不需要管的。</p><p>输出大概长这样：</p><pre class="language-"><code>
=== 技能快照扫描 ===

【需要备份】

○ my-skill (5 files, 68K) [未备份]

○ another-skill (3 files, 12K) [未备份]

✓ third-skill (4 files, 24K) [已有: v1]

【跳过】

✗ archive - 归档目录

✗ external-plugin - 符号链接（外部安装）

✗ git-managed-skill - 自带 Git 版本控制

需要备份: 3 个

跳过: 3 个
</code></pre><p>这个扫描很聪明。它会跳过几类技能：归档目录（archive）不管；符号链接（你可以理解为「快捷方式」）指向的外部安装插件不管；本身已经有 <code>.git</code> 目录、自带版本控制的技能也不管 —— 它们自己有办法。</p><p>剩下的，就是你真正需要关心的技能。</p><h3>第三步：保存快照</h3><p>看到「未备份」的技能了？在修改它之前，可以先存个档。</p><p>你说一句「保存 my-skill 快照」即可。如果你想加一句说明，可以说「保存 my-skill 快照，说明是『添加 XX 新功能前』」。</p><p>输出：</p><pre class="language-"><code>
=== 保存快照 ===

技能: my-skill

版本: v1

说明：添加 XX 新功能前

✓ 快照已保存: my-skill/v1

→ 可用 'restore my-skill v1' 恢复
</code></pre><p>完成。这个技能的当前状态已经被保存到 GitHub 私有仓库了，打上了 <code>my-skill/v1</code> 的标签。</p><p>如果你连续保存两次，但中间没有修改任何文件，工具会告诉你「无变化，不需要保存」—— 它不会创建无意义的版本。</p><p>对于我这样的懒人，会干脆要求 Claude Code「把所有你觉得需要备份的 Skill，都存一下」。完成。</p><h3>第四步：恢复版本</h3><p>这是整个工具最核心的功能。</p><p>假设你改了 my-skill，改坏了，想退回去。说一句「恢复 my-skill 到 v1」。</p><p>输出：</p><pre class="language-"><code>
=== 恢复快照 ===

技能: my-skill

版本: v1

→ 当前版本已备份到: .snapshot-backup/my-skill-20260110

✓ 已恢复到 my-skill/v1

→ 技能位置: ~/.claude/skills/my-skill
</code></pre><p>注意看第一行：「当前版本已备份到……」。工具在恢复之前，会先把你当前的版本（哪怕是改坏的版本）备份一份。为什么？万一你恢复后又后悔了呢？万一你发现「其实刚才改的那个版本有个地方是对的」呢？这份备份就是你的后路。</p><p>这种「替用户多想一步」的设计，叫做<strong>防御性编程</strong>。</p><p>因为咱们没有实际去编写代码，所以这叫「防御性氛围编程」，哈哈。</p><h2>发布</h2><p>Skill Snapshot 开发完成后，我决定把它公开分享。让你拿过来直接就能用。</p><p>但在发布之前，我必须（让 Claude Code）做一件事：<strong>隐私检查</strong>。</p><p>为什么？因为把技能发布出去的时候，规则和代码里可能藏着敏感信息。你自己用没问题，但公开给别人看就不合适了。</p><p>我把这事儿交给了 Claude Code ，于是它立即用 grep 命令搜了一遍：</p><pre class="language-"><code>
grep -rn "wsy\|wshuyi\|/Users/" ~/.claude/skills/skill-snapshot/
</code></pre><p>结果找到了 16 处私有技能名的引用，比如 <code>wsy-writer</code>、<code>research-to-diagram</code>。这些是我自己的技能，名字里带着个人标识。</p><p>怎么处理？<strong>脱敏</strong>。</p><p>Claude Code 自动把 <code>wsy-writer</code> 换成通用的 <code>my-skill</code>，把 <code>research-to-diagram</code> 换成 <code>another-skill</code>。用 <code>sed</code> 命令全局替换，确保没有遗漏。</p><p>发布的时候，当然还有一件事：<strong>双语文档</strong>。</p><p>我的读者有中文用户，也有英文用户。所以我准备了两份 README：</p><p><code>README.md</code> 是英文版，开头第一行就是指向中文版的链接：<code>[中文文档](README_CN.md)</code>。</p><p><code>README_CN.md</code> 是中文版，开头第一行指向英文版：<code>[English](README.md)</code>。</p><figure class="image ss-img-wrapper"><img alt="" src="https://cdnfile.sspai.com/2026/01/10/article/6dbe5690c5a32d7ad3f3699813670494.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p>这样做的好处是：无论用户从哪个入口进来，都能一键切换到自己熟悉的语言。这不是锦上添花，是对非母语用户的基本尊重。</p><p>最后，Claude Code 自动用 GitHub CLI 创建公开仓库：</p><pre class="language-"><code>
gh repo create skill-snapshot-skill --public --source=. --push
</code></pre><p>发布完成。公开仓库地址：<a href="https://github.com/wshuyi/skill-snapshot-skill">github.com/wshuyi/skill-snapshot-skill</a>。你可以直接点击查看。</p><figure class="image ss-img-wrapper"><img alt="" src="https://cdnfile.sspai.com/2026/01/10/article/6dff8d3be5eeb3c3f733b8b1b1486f28.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p>感觉好用的话，别忘了给加一颗星哦。</p><h2>小结</h2><p>回过头来看，Skill Snapshot 这个小工具制作的路径，背后，藏着几个可以迁移到其他场景的思维模式。</p><p><strong>第一，复用成熟基础设施</strong>。版本管理这件事，Git 已经做了几十年，稳定可靠，功能丰富。我没有自己写一套版本控制逻辑，而是直接站在 Git 的肩膀上。在设计新系统时，第一个问题应该是「有没有现成的轮子可以用」。</p><p><strong>第二，规则引擎替代人工决策</strong>。<code>scan</code> 命令用了 7 条规则来自动判断哪些技能需要备份：归档目录跳过、符号链接跳过、自带 Git 的跳过、体积超过 10MB 的跳过……这些规则一旦定义好，就不需要用户每次自己判断了。把重复性的决策交给规则，人才能专注于真正需要思考的事情。注意我也没有指导 Claude Code 定立这7条规则，我只是让它去思考该如何判定，并把这些判定<strong>沉淀、固化下来</strong>。</p><p><strong>第三，防御性（氛围）编程</strong>。恢复版本前先备份当前版本，这是「替用户多想一步」。无变化时友好提示而不是崩溃退出，这是「把用户当朋友而不是敌人」。好的工具应该预见用户可能犯的错误，并提前铺好退路。这里有的时候，Claude Code 不一定能想得很周全，需要你在合适的地方提示一下。</p><p><strong>第四，「元技能」的概念</strong>。Skill Snapshot 是一个「管理技能的技能」。此时在我的 Claude Code 生态系统中，创建技能有 <code>skill-creator</code>（来自官方），发布技能有 <code>skill-publisher</code>，备份技能有 <code>skill-snapshot</code>。当某类操作变得频繁，就值得把它抽象成一个工具。工具的工具，框架的框架——这种「元」的思维方式，是提升效率的关键。</p><p>最后，送你一句话：</p><p><strong>没有版本管理的 Claude Skill 技能，就像没有存档的游戏。</strong></p><p>你可以一路顺风打到最后一关，但只要失败一次，就得从头再来。</p><p>有了存档呢？大胆尝试，随时回退。「嘎」了不怕，读档重来。</p><p>这才是我们积极尝试 Skill 创作和修改时，正确的打开方式。</p><figure class="image ss-img-wrapper"><img alt="" src="https://cdnfile.sspai.com/2026/01/10/article/f4706d54ad3f71b0ebbfdfa87a25dc21.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p>现在，去初始化你的第一个快照，然后放心大胆迭代改进 Claude 技能吧。</p><p>你自己创建了哪些新的「元技能」，都解决了哪些痛点？欢迎留言，咱们一起交流讨论。</p><p>如果你觉得本文有用，请<strong>充电</strong>。</p><p>如果本文可能对你的朋友有帮助，请<strong>转发</strong>给他们。</p><p>欢迎<strong>关注</strong><a href="https://sspai.com/column/245">我的专栏「科研利器」</a>，以便及时收到后续的更新内容。</p><p><a href="https://sspai.com/prime/subscription?referral=314606736">点击这个链接加入少数派会员</a>，立享 9 折优惠！获得专属会员内容、会员播客以及会员定制周边。在更多的领域和方向帮你打开脑洞，找到新的兴趣点。与少数派一起洞悉当下，探索新知。</p><h2>延伸阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/cSysHNhu24H8dUpKk9XxQg">品味还是技能？ChatGPT 引发的能力培养变革</a></li><li><a href="https://sspai.com/post/83313">一款笔记工具用着很好，但有部分功能不满足我的需求，怎么办？</a></li><li><a href="https://sspai.com/post/105284">Claude Skills 入门：一篇文章搞懂 AI 怎么从「嘴替」升级成「打工人」</a></li><li><a href="https://sspai.com/post/105095">如何用 Claude Skill 帮你一句话做深度调研并自动画图？</a></li><li><a href="https://sspai.com/post/104369">AI 时代，请停止「做作业」，去创造属于你的「作品」</a></li></ul>
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://sspai.com/post/105325</id>
            <title>iOS逆向实战，去除广告与短视频</title>
            <link>https://sspai.com/post/105325</link>
            <guid isPermaLink="false">https://sspai.com/post/105325</guid>
            <pubDate></pubDate>
            <updated>Sat, 10 Jan 2026 05:19:03 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <h3>如果你想了解更多，欢迎收看</h3> <p>&nbsp;</p><h3><strong>项目背景与目标</strong></h3><p><br />作为B站的重度用户，Feed流中越来越多的竖屏视频与广告让人非常厌烦，于是决定逆向一把，过滤掉这些玩意。本文最后你将可以实现：</p><ul><li>完全可自定义的过滤规则</li><li>自定显示或隐藏某些UI界面</li><li>更改播放器的默认行为</li><li>控制面板<br />&nbsp;</li></ul><figure class="image ss-img-wrapper image_resized" style="width: 300px;"><img src="https://cdnfile.sspai.com/2026/01/10/article/9000a5a44aa4076a1ebbb25e72aa10b2.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p>&nbsp;</p><h3><strong>逆向基础知识</strong></h3><p><br />本文只着重分享逆向的实战经验与过程。但在开始之前，笔者还是要先简单讲一下几个比较重要的知识点。</p><ul><li><strong>函数调用机制</strong><br />在Objective-C中，简单来说，一个函数调用例如 [obj foo: arg]会在底层转变为obj_msgSend(obj, @selector(foo:), arg)，接着在运行时按照 method cache → 本类方法列表 → 父类链 查这个 SEL 对应的 IMP（实现函数） 并调用。<br />Method Swizzle（方法交换）<br />这是OC中提供的一种可以在运行时修改“SEL → IMP”映射的机制，能够在查找IMP的过程中使后续消息派发跳转到开发者自定义的新实现。<br />如果需要更改App的行为，绝大多数情况下，都是通过此机制Hook原函数并加入自定义逻辑。所以我们的目标就是找到某些功能对应的函数实现，并且加入我们的自定义逻辑，下文我们就将通过多种不同途径来寻找对应的函数。</li><li><strong>反射机制</strong><br />反射能够在编译时不感知目标类型与方法签名的情况下，仅靠 String（类名/方法名/SEL）完成查找、实例化与方法调用。我们在写逻辑时，就要靠他来对原App的具体变量进行访问。</li><li><strong>框架注入</strong><br />在重新打包App时，可以注入我们自己写的framework，再在OC中使用+load函数即可让我们的代码在App启动后自动运行，实现上面的方法交换逻辑。</li></ul><h3>前期准备</h3><p><br /><strong>砸壳</strong><br />App Store 下载的安装包，都是通过加密的，我们无法直接逆向，所以需要通过砸壳来获取未加密的IPA文件。这里有两种途径：</p><ol><li>准备一台越狱的iPhone，通过frida插件在App运行时提取未加密的IPA，https://github.com/AloneMonkey/frida-ios-dump<br />&nbsp;</li><li>对于一些主流App，会有第三方网站提供IPA文件下载，例如：https://decrypt.day，不过安全性不受保证。<br />安装与调试</li><li>在安装IPA之前需要对App进行重签名，这里笔者习惯使用Sideloadly，注意非Apple Developer开发者账号单次签名有效期只有7天，反之是一年。在选择设备后就可以安装到自己的手机上了。<br />&nbsp;</li></ol><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/10/article/6173efd9dce852bc9b986a72dde2a147.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p>调试可直接在Xcode中打开空白工程，并连接iPhone，在Debug-&gt;Attach to Process-&gt;xxxxxx，例如这里B站的process name就是 bili-universal</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/10/article/9c030ec123b55e1b62f77672e2bb9670.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p>在成功Attach上之后，就可以开始我们的逆向之旅了。</p><h4><br />更改 UI 行为</h4><p><br />首先暂停App之后，一个最简单的入手方法就是通过UI，我们在LLDB中输入<br /><code><strong>po [[UIWindow keyWindow] recursiveDescription]</strong></code><br />即可打印出目前屏幕上的UI树。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/10/article/7afb3978cf881097787814c559bb2527.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p>这里我们可以看到所有UIView的类名，属性，地址，甚至直接可以搜索屏幕上的元素。<br />例如此处搜索搜索框的文字，我们就能知道搜索框是由BBList.SearchControl实现。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/10/article/2333102bcebe6b1f5696ea68ca1abd9a.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/10/article/8116abc7d541a5603a21ff81f7d9dfd5.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p><br />如果我们仅仅需要Hook UI的一些行为，有了类名之后，到这里已经成功一大半了，下一步我们应该使用method swizzle找到一个合适的时机，将我们想要执行的代码塞进去就行了。那么我们一般寻找这个界面的ViewController就可以了，在VC中有各种生命周期可供Hook。<br />那么我们应该如何查找UIView对应的生命周期呢？简单来说就是递归调用NextResponder，由于篇幅篇幅原因，这里省略原理。总之nextResponder会按照 UIView → superview → ViewController 的顺序，所以例如这里的SearchControl，只需要在lldb中调用nextResponder，直到找到VC。<br />&nbsp;</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/10/article/03dde90b069d13cb4823c37e28e7a05a.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p><br />可以利用反射机制Hook该VC，并通过swizzle其生命周期函数，执行自己的逻辑，比如显示隐藏一个UIView，或者插入额外的view。<br />例如本项目的一个功能，禁止显示竖屏视频的按钮，就是通过Hook UIStackView的addArrangedSubView，再判断这些按钮是不是命中了类名，如果命中就拒绝执行。</p><pre class="language-javascript"><code>@interface UIStackView (GSVStackBlock)
- (void)gsv_addArrangedSubview:(UIView *)view;
- (void)gsv_insertArrangedSubview:(UIView *)view atIndex:(NSUInteger)stackIndex;
@end

@implementation UIStackView (GSVStackBlock)

- (void)gsv_addArrangedSubview:(UIView *)view {
    if (gsv_shouldBlockView(view)) {
        return;
    }
    [self gsv_addArrangedSubview:view];
}

- (void)gsv_insertArrangedSubview:(UIView *)view atIndex:(NSUInteger)stackIndex {
    if (gsv_shouldBlockView(view)) {
        return;
    }
    [self gsv_insertArrangedSubview:view atIndex:stackIndex];
}

@end

@interface GSVStackHooker : NSObject
@end

@implementation GSVStackHooker

+ (void)load {
    Class cls = [UIStackView class];
    if (!cls) { return; }
    gsv_swizzleInstance(cls, @selector(addArrangedSubview:), @selector(gsv_addArrangedSubview:));
    gsv_swizzleInstance(cls, @selector(insertArrangedSubview:atIndex:), @selector(gsv_insertArrangedSubview:atIndex:));
}

@end
</code></pre><p>&nbsp;</p><p>&nbsp;</p><h4>更改 App 逻辑</h4><p><br />在打包后的App中，虽然绝大多数函数名都被strip掉，但是对于OC类，仍然保留了methodDescption, 可以由一个实例的地址，拿到OC的类中方法与属性签名<br />&nbsp;</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/10/article/6ffcac8c0a4513d3d9ce525ef83c83dd.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p><br />例如在本项目中禁止短视频播放器的视频播放，就是通过播放器的UIView，找到他的ViewController，接着尝试打印他的方法，发现里面有setLooping方法，所以按照推测我们将viewDidAppear的时候强制setLooping为false，即可实现。</p><pre class="language-javascript"><code>@implementation UIViewController (GSVHook)

- (void)gsv_viewDidAppear:(BOOL)animated {
    [self gsv_viewDidAppear:animated];
    
    NSString *className = NSStringFromClass(self.class);
    GSVSettingsManager *settings = [GSVSettingsManager sharedManager];
    
    // 功能1：强制设置循环为false（针对BBStoryPlayerContainer）
    if ([className isEqualToString:@"BBStoryPlayerContainer"] &amp;&amp; settings.forceSetLoopingFalse) {
        SEL loopingSel = NSSelectorFromString(@"setLooping:");
        if ([self respondsToSelector:loopingSel]) {
            ((void (*)(id, SEL, BOOL))objc_msgSend)(self, loopingSel, NO);
        } else {
            NSLog(@"[GSV] %@ 不响应 setLooping:，跳过", className);
        }
    }
}

@end</code></pre><p><br />目前看起来逆向也太简单了，但并不是所有情况下，都能这么简单直接的找到所需要的类或函数，例如过滤Feed流中的短视频。</p><h3><br />进阶</h3><p><br />Feed流的显示，无非就是一个UICollectionView，然后有若干个Cell不断的进行替换，所以我有下面几个思路：</p><ul><li>暴力隐藏UIView<br />最简单的方案就像是上文中一样，直接暴力判断UIView的className是否等于xxxxx，然后再递归遍历其子View，如果发现有text为竖屏的UILabel，就强制设置isHidden = true，然后再该Cell移除屏幕 prepareForReuse的时候恢复其透明度。防止下次用的时候默认被隐藏了。<br />这个方法极其的简单粗暴，但也非常不完美，因为并不能改变layout，所以feed流上会出现一块一块的白补丁，Pass。</li></ul><pre class="language-javascript"><code>static NSString *gsv_firstPortraitLabelPath(UIView *root, BOOL isContentViewRoot) {
    if (!root) { return nil; }
    NSString *rootSeg = isContentViewRoot ? @"contentView" : NSStringFromClass(root.class);
    return gsv_findPortraitLabelPathRecursive(root, rootSeg);
 }
</code></pre><ul><li>CollectionView的DataSource<br />如果你了解CollectionView的工作方式，就是不停的到DataSource delegate中去询问需要展示几个Cell，每个Cell的内容等参数。所以在DataSource中，一定会有真正数据源的访问。接着我们可以顺着这条线寻找到真正的数据源。<br />这里我们就要通过上面method Description中打印出的方法地址，设置断点。切记给你的断点-N 加个名字，因为全是地址，断点多了不然会忘了是哪个。<br />&nbsp;</li></ul><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/10/article/fdd54e97fa944e835fb074fc789f3b0d.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p>接着操作一下app，就能命中这个断点。<br />在命中之后，使用di命令即可显示该函数下的汇编代码，这里我们可以借助AI进行分析，并在可疑的地址前下断点，再去访问加载到寄存器中的实例类名，并且通过偏移再去寻找其属性，这里略去具体过程。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/10/article/38d3eda1d965c0d13dc0d75c9a97a068.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p><br />分析得出该 CollectionView的dataSource就是VC，同时在运行 cellForItemAtIndexPath时，访问了viewController-&gt;viewModel-&gt;dataFatcher-&gt;cardData Array。<br />但不幸的是，从viewModel开始，就是Swift类了，Swift静态派发的方法，并不能像OC一样使用Swizzle进行替换，并且可用的信息也非常之少。所以最后这条路也行不通了。</p><ul><li>网络库<br />既然从UI下手行不通，那我们就尝试两头堵，从网络库入手试试看。首先我们使用Charles抓包抓到负责Feed流的网络请求，得到他的URL。</li></ul><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/10/article/b2fcb4cd377dd54607e35a00984a9da2.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p><br />接着我们Hook NSURLSession的delegate，打印出看否有符合我们要求的域名，结果果然是没有。看起来他也没有走自带的网络库，后来我想会不会是从前端将数据传递进来的，我还Hook了JSRuntime相关的函数，结果依然令人失望。</p><ul><li>IDA<br />似乎我们两头堵也不行，那咋办呢，这个时候就需要碰碰运气了。比如我又想到，获取数据一定跟刷新有关系，那么在CollectionView中如果想刷新，一定要调用 reload方法，所以我们在reload方法下断点。</li></ul><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/10/article/b8c123b823da6f47fd18c20a558b72e5.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p><br />这里我们使用backtrace展开调用栈。我们可以看到reload是由app中一些堆栈调用上来的，我们想知道下面的那些frame到底是什么。这里我们就搬出IDA了，IDA 可以将所有汇编代码映射到静态地址中。并且解析出所有符号。<br />所以我们只需要通过目前App运行的动态地址，计算出静态地址，再在IDA中通过地址查询，就可以找到地址对应的函数。<br />如何计算IDA中的静态地址呢？</p><ol><li>先在lldb中获取我们App，运行的基地址，例如这次是 0x104e14000：</li></ol><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/10/article/7d32aef8fd24c9c747e823805da84c80.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p>2. 使用frame中的地址减去基地址得到偏移量，在使用偏移量加上0x100000000</p><p>3. 在IDA中使用静态地址中搜索<br />经过一番尝试，还真找到了底层的Request<br />接着查看这个函数的伪代码，好家伙，连NSJSONSerialization都出来了，那基本上证明了这就是我们需要找的函数。<br />&nbsp;</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/10/article/e4deda2f847b60fc26206d8a9094835b.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p><br />接着直接Hook这个函数，如果判断是这个接口的话，先手动把Data序列化一遍，然后递归遍历是否有广告或者竖屏视频，如果有的话直接移除，最后再给他反序列回Data，透传给原函数的实现，这样就完美了。</p><pre class="language-"><code> "config": {
     "auto_refresh_by_behavior": 1,
     "auto_refresh_time": 1200,
     "auto_refresh_time_by_active": 1800,
     "auto_refresh_time_by_appear": 1800,
     "auto_refresh_time_by_behavior": 5,
     "autoplay_card": 11,
     "card_density_exp": 1,
     "close_small_window": 1,
     "column": 2,
     "enable_rcmd_guide": true,
     "exposure_duration_end_ratio": 0.800000011920929,
     "exposure_duration_min_ms": 1,
     "exposure_duration_start_ratio": 0.800000011920929,
     "feed_clean_abtest": 0,
     "history_cache_size": 10,
     "home_transfer_test": 0,
     "inline_sound_cold_state": 2,
     "is_back_to_homepage": true,
     "rcmd_label_mng_entrance": 1,
     "show_inline_danmaku": 1,
     "single_autoplay_flag": 1,
     "small_cover_wh_ratio": 1.333333,
     "space_enlarge_exp": 1,
     "story_mode_v2_guide_exp": 6,
     "three_point_style": 1,
     "toast": {},
     "trigger_loadmore_left_line_num": 1,
     "video_mode": 1,
     "visible_area": 80
 },
 "interest_choose": null,
 "items": [
     {
         "args": {
             "aid": 114902270222302,
             "tid": 76859374,
             "tname": "鬼畜星探企划第二十二期",
             "up_id": 1722956360,
             "up_name": "会跳舞的杰哥"
         },
         "can_play": 1,
         "card_goto": "inline_av_v2",
         "card_type": "large_cover_v9",
         "cover": "http://i0.hdslb.com/bfs/archive/2a45b6c09a3f51e9cc5f0ae237a2a1cc28e2be1c.jpg",
         "cover_left_1_content_description": "119.3K观看",
         "cover_left_2_content_description": "4694弹幕",
         "cover_left_icon_1": 1,
         "cover_left_icon_2": 3,
         "cover_left_text_1": "119.3K",
         "cover_left_text_2": "4694",
         "cover_right_content_description": "9分钟34秒",
         "cover_right_text": "9:34",
         "goto": "av",
         "idx": 1758725170,
         "inline_progress_bar": {
             "icon_drag": "https://i0.hdslb.com/bfs/archive/c1461e2c6ca97783ac0298b6ebb2d85d94b8f37c.json",
             "icon_drag_hash": "31df8ce99de871afaa66a7a78f44deec",
             "icon_stop": "https://i0.hdslb.com/bfs/archive/6ee2f9b016f20714705cb5b8f15da1446587d172.json",
             "icon_stop_hash": "5648c2926c1c93eb2d30748994ba7b96"
         },
         "like_button": {
             "aid": 114902270222302,
             "count": 4291,
             "dislike_night_resource": {
                 "content_hash": "c370e8d031381f4716d7564956a8b182",
                 "url": "https://i0.hdslb.com/bfs/archive/c9a20055b712068bfe293878639dc9066ba2690b.json"
             },</code></pre><p>收尾工作<br />最后我们用AI写个开关面板，然后再Hook一下UITableView，把B站讨厌的会员购icon与界面换成弹出我们的设置面板。<br />&nbsp;</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/10/article/db264eb0a808c84f6e43480ed0738790.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p><br />因为我们的代码都写在一个Framework里，我们只需要构建出产物，接着在打包的时候，选择Inject frameworks，接着把产物添加进去就OK了。<br />&nbsp;</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/10/article/b05977d88e3549488fb0fee9c337151f.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p><br />好了，现在终于可以在不看广告的情况下愉快的刷B站了。</p><p>关于我：</p><p>前不知名数码博主/独立开发者/客户端程序员&nbsp;</p><p>全网同名，欢迎关注</p>
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://sspai.com/post/105320</id>
            <title>Claude PPTX Skill 实践：AI 生成的 PPT 到底能不能用？</title>
            <link>https://sspai.com/post/105320</link>
            <guid isPermaLink="false">https://sspai.com/post/105320</guid>
            <pubDate></pubDate>
            <updated>Sat, 10 Jan 2026 01:58:54 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>【导语】</p><p>AI 写代码已经习以为常，但 AI 做 PPT 依然是很多人的痛点。Anthropic 官方随 Agent Skills 发布了一套 PPTX Skill 示例，号称能让 Claude 具备生成专业演示文稿的能力。这究竟是解决 PPT 噩梦的终极武器，还是又一个“看起来很美”的玩具？本文将带你从代码层面拆解这个 Skill，经历一次从“翻车”到“魔改”的完整探索，并顺带看看市面上其他 AI 工具的表现究竟如何。</p><p>【你能从这篇文章收获什么】</p><ul><li>🔍 <strong>深度拆解</strong>：理解 Claude 官方 PPTX Skill 的核心工作原理与 Prompt 设计逻辑。</li><li>🛠️ <strong>避坑指南</strong>：揭秘官方文档中不适配中文环境的“深坑”，并提供具体的代码级优化方案。</li><li>📊 <strong>工具横评</strong>：Claude PPTX Skill、Manus、NotebookLM、Gemini Canvas、Ima……谁才是目前 AI 生成 PPT 的最佳选择？</li></ul><h2>PPTX Skill 是如何“思考”的？</h2><p><strong>在人机协作中，Prompt 的质量决定了 AI 产出的上限</strong>。Agent Skills 的本质是可复用的 Prompt 工程。要用好 PPTX Skill，我们有必要深入剖析其内部逻辑与核心工作原理。</p><p>PPTX Skill 是 Anthropic 发布 Agent Skills 功能时的官方示例。其 <code>SKILL.md</code> 文件定义了三种生成能力：（1）无模板创建演示文稿，（2）基于模板创建演示文稿，（3）编辑现有演示文稿。</p><p><strong>本文重点探索“无模板创建”场景。其核心工作流包含四步：</strong></p><ol><li>根据用户提供的内容设计演示文稿</li><li>为每张幻灯片生成对应的 HTML 文件</li><li>使用脚本将全部的 HTML 文件转换成演示文稿</li><li>将演示文稿转换成缩略图，验证每张幻灯片的布局和设计</li></ol><p>随着模型能力的提升，生成美观的 HTML 已非难事。PPTX SKill 在核心文档 <code>SKILL.md</code> 为 AI 提供了详尽的设计指导，包括：</p><ul><li>根据内容匹配设计元素，兼顾主题、品牌标识与配色方案</li><li>为几何图案、图表、背景等元素设定具体规则</li><li>优先采用双栏布局与全幻灯片布局</li></ul><figure class="image ss-img-wrapper"><img alt="screenshot-20260108-155419.png|500" src="https://cdnfile.sspai.com/2026/01/10/article/dad1cbbd710a2c14b454bfff72810998.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption><i>我将 18 个配色方案转换成了可视化的卡片，你可以在生成演示文稿时指定配色</i></figcaption></figure><p>然而，将 HTML 转换为 PPTX 尚无成熟通用的方案。为确保样式精准还原，PPTX Skill 在 <code>html2pptx.md</code> 中预设了严格的约束条件，例如：</p><ul><li>文本约束：所有文本必须在特定标签 <code>&lt;p&gt;</code>、<code>&lt;h1&gt;</code> 内；不能使用手动项目符号，必须使用 <code>&lt;ul&gt;</code>&nbsp;或&nbsp;<code>&lt;ol&gt;</code>&nbsp;列表；</li><li>样式约束：背景、边框、阴影仅适用于 DIV 元素，不适用于文本元素；不能使用 CSS 渐变；</li><li>验证规则：内容不能溢出 body</li></ul><p>Skill 要求 AI 严格遵循约束生成 HTML，随后调用 <code>html2pptx.js</code> 脚本进行转换。脚本内置了严格的校验逻辑，一旦失败即返回错误信息，驱动 AI 进行自我修正。</p><p>最后，PPTX Skill 还要求 AI 在生成演示文稿后，使用 <code>thumbnail.py</code> 脚本将演示文稿转换成缩略图，通过缩略图验证每张幻灯片的布局和设计，而不仅仅依赖 <code>html2pptx.js</code> 脚本中的校验逻辑，为整个工作流提供了重要的自我纠错能力。</p><p><strong>综上所述，PPTX Skill 融合了精心设计的提示词、严谨的工程转换能力以及视觉验证机制。相比竞品宛如“抽奖游戏”一般的生成质量，它更像是一项严谨的系统工程。然而在实际测试中，其表现却未达预期。</strong></p><h2>魔改 Skill</h2><p>实际工作场景中，我们经常要根据具体的内容创作演示文稿，为了贴合实际场景，这里我选择了宝玉老师博客的一篇文章 <a href="https://baoyu.io/blog/claude-code-boris-9-practical-tips-simple-config">Claude Code 之父 Boris 的 9 条实战技巧：原来高手的配置这么“朴实无华”</a> 作为 PPT 生成的内容基础。</p><h3>前期准备</h3><p><code>SKILL.md</code> 文档末尾列出了所需依赖，并且在原文中提示 “Required dependencies (should already be installed)”，但普通用户的运行环境通常不具备这些条件。这也反映出 Anthropic 在设计这个 SKill 时仅从专业人士角度出发，而忽略了一般用户的使用场景。</p><p>另一方面，鉴于运行过程中会生成大量中间文件（如 HTML、缩略图等），为保持项目整洁，建议建立<strong>独立的专用目录</strong>来部署环境。</p><p>如果你也是 macOS 用户，可以参考下面的安装步骤：</p><pre class="language-"><code># 1. 创建项目  
mkdir pptx-project &amp;&amp; cd pptx-project  

# 2. 初始化 npm  
npm init -y  

# 3. 安装依赖  
npm install pptxgenjs playwright react-icons react react-dom sharp  

# 4. 安装 Playwright 浏览器  
npx playwright install

# 5. 安装 poppler-utils 和 libreoffice （原文提到的 apt-get 只能在 Linux 中使用，因此替换为 homebrew 在 macOS 中安装）
brew install --cask libreoffice
brew install poppler

# 6. 安装 markitdown
pip install "markitdown[pptx]"</code></pre><h3>发现问题</h3><p>我分别使用了 <code>Claude Code + DeepSeek-V3.2</code>、<code>Vscode Github Copilot Chat + Claude Sonnet 4.5</code> 两种不同的工具和模型的组合来生成演示文稿。</p><p>我将博客文章提前保存为本地 markdown 文档，使用如下提示词要求 AI 生成演示文稿：</p><pre class="language-"><code>根据 file:Claude Code 之父 Boris 的 9 条实战技巧：原来高手的配置这么“朴实无华”.md 文档，分析Boris的9条技巧，生成Claude Code最佳实践的演示文稿（PPTX)</code></pre><p>其中 <code>Claude Code + DeepSeek-V3.2</code> 耗时近 25 分钟，结果却完全不可用。我仔细查看了它的执行过程，发现其行为多处违背 <code>SKILL.md</code> 规范：</p><ol><li>没有在生成 HTML 前阐述自己的设计方案；</li><li>在 <code>html2pptx.js</code> 校验多次失败后，模型竟擅自跳过脚本，直接调用 PptxGenJS API 创建文档；</li><li>未将渐变 CSS 和图标栅格化为 PNG；</li><li>未生成缩略图并自我验证。</li></ol><figure class="image ss-img-wrapper"><img alt="claude-best-practices-thumbs.jpg|500" src="https://cdnfile.sspai.com/2026/01/10/article/eaaeb093e4d4f79bc0ab35738ee79622.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p><code>Vscode Github Copilot Chat + Claude Sonnet 4.5</code> 同样耗时 20 分钟，生成的结果只比 DeepSeek 稍好，内容提取尚可，但缺乏排版设计。且同样因脚本校验失败导致了超过 40 次的反复迭代！</p><figure class="image ss-img-wrapper"><img alt="claude-best-practices-boris-thumbs.jpg|500" src="https://cdnfile.sspai.com/2026/01/10/article/a628cc047bc7007baf58a36d1adcca11.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p>对比 DeepSeek 的执行过程，Claude 阐述了自己的设计方案，将渐变背景栅格化为 PNG，并生成缩略图验证结果，由此推断，前述三个问题主要归因于模型的执行能力差异。</p><p>而对于两者都出现的脚本校验不通过问题，我进一步查看了 <code>html2pptx.js</code> 脚本校验失败的错误提示，发现全部集中在内容溢出和底部边距不足上，也就是说，<strong>模型设计的幻灯片太高了，超过了脚本限制的高度。</strong></p><p><strong>这表明模型未能严格遵循 </strong><code><strong>html2pptx.md</strong></code><strong> 的约束条件。</strong> 并且为了通过脚本校验，模型在修复过程中大幅简化了原始 HTML，严重牺牲了排版效果。这是导致最终质量低下的核心原因。</p><p>除了上述与 <code>SKILL.md</code> 文档中要求的工作流明显相悖的情况，我还发现 <code>thumbnail.py</code> 脚本生成的缩略图清晰度非常差，模型很难借助图片完成自我纠错。</p><h3>SKILL.md 文档设计存在缺陷</h3><p>我仔细阅读了 <code>SKILL.md</code> 文档，结合上面的观察，发现可能存在以下的几点缺陷：</p><p><strong>文档冗长、结构混乱，且违背了“渐进式披露”原则</strong>。参照 Anthropic 官方提供的 <a href="https://console.anthropic.com/docs/zh-CN/agents-and-tools/agent-skills/best-practices">技能创作最佳实践 - Claude Docs</a> ，明确指出“保持 SKILL.md 正文在 500 行以下...使用目录结构化较长的参考文件...按领域组织内容以避免加载无关的上下文”，反观 PPTX Skill 的 <code>SKILL.md</code> 文档：</p><ol><li>共 484 行，已经接近 500 行的上限；</li><li>没有在文档开头列出目录结构；</li><li>文档先列出了大篇幅的设计原则，在 150 行才开始有第一个场景的工作流步骤；</li><li>文档混合了三种场景的工作流，本应拆分为独立的参考文件，由模型根据具体场景按需加载。</li></ol><p><strong>设置的工作流步骤可能会误导模型</strong>。针对“无模板生成演示文稿”这一场景，文档先列出了大篇幅的设计原则，之后在工作流的第一步要求模型阅读 <code>html2pptx.md</code> 文档。</p><p>而在我的观察中，模型在读取 <code>SKILL.md</code> 文档后，遵循工作流要求立即读取了 <code>html2pptx.md</code> 文档，之后开始设计演示文稿的内容。这会导致设计演示文稿的上下文内容影响模型遵循 <code>html2pptx.md</code> 文档的约束。更合理的流程应是：先专注于内容设计，再读取 <code>html2pptx.md</code> 规范，并立即开始生成 HTML。</p><p><strong>提供的设计原则不匹配中文内容</strong>。原文档的设计原则仅针对英文环境，直接应用于中文内容时会出现“水土不服”：</p><ol><li>“Use web-safe fonts only: Arial, Helvetica, Times New Roman...”：强制使用拉丁字体，导致中文显示依赖系统回退，字重与行距失衡；</li><li>“All-caps headers with wide letter spacing”：中文没有大小写概念，易造成视觉松散；</li><li>“Extreme size contrast (72pt headlines vs 11pt body)”：72pt 标题配合 11pt 正文，在中文演示中正文显得过于细小；</li><li>“Condensed fonts (Arial Narrow) for dense information”：中文窄体并不普遍，可能会导致字体挤在一起。</li></ol><h3>优化文档及脚本</h3><p>针对上述缺陷，我进行了如下优化：</p><p><strong>直接删除了 </strong><code><strong>SKILL.md</strong></code><strong> 中“使用模板生成演示文稿”和“编辑演示文稿”这两个场景相关的提示词</strong>，以缩减上下文长度。正确做法应当是拆分出三个场景的工作流文档，并在 <code>SKILL.md</code> 文档中引用，这里我为了快速测试，简化了流程。</p><p><strong>调整 </strong><code><strong>SKILL.md</strong></code><strong> 文档结构，将工作流放在文档开头，“设计原则”之前</strong>，让模型能遵循正确 的步骤执行。</p><p><strong>修改工作流步骤，添加“设计演示文稿内容”作为工作流的第一步</strong>，防止模型先读取 <code>html2ppt.md</code> 文档再生成 HTML，弱化约束条件作用。</p><p><strong>修改 </strong><code><strong>SKILL.md</strong></code><strong> 文档中不适配中文的设计原则以符合中文排版习惯</strong>。</p><p><strong>优化 </strong><code><strong>thumbnail.py</strong></code><strong> 脚本，支持为每张幻灯片生成更大且 DPI 更高的图片，以提供更清晰的缩略图</strong>。</p><h3>二次挑战</h3><p>除了针对文档和脚本的优化，我还要求模型根据 40 多次迭代的过程，总结出将 HTML 转换为 PPTX 的安全尺寸规范，并保存为“HTML2PPTX 安全尺寸规范”文档，方便在首轮对话中作为上下文提供给模型。</p><p>同时我还优化了提供给模型的初始提示词，在提示词中明确要求模型使用 PPTX Skill，并提醒模型生成 HTML 文件时要遵循 <code>html2pptx.md</code> 文档中的约束，最终的提示词如下：</p><pre class="language-"><code>分析Boris的9条技巧，使用 pptx Skill 生成Claude Code最佳实践的演示文稿（PPTX），务必遵循 html2pptx.md 文档中的约束，了解所有验证规则（特别是底部边距要求），然后再开始设计 HTML.
严格遵守HTML2PPTX 安全尺寸规范文档来设计页面布局。</code></pre><p>本轮测试仅耗时 3 分钟即成功生成演示文稿，且过程中未再出现校验错误。说明优化策略成效显著🎉！不过，最终成品的质量仍仅处于及格边缘。</p><figure class="image ss-img-wrapper"><img alt="thumbnails1.jpg|500" src="https://cdnfile.sspai.com/2026/01/10/article/abe49f3f36732c85922472019f205595.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p>我注意到“HTML2PPTX 安全尺寸规范”文档中要求底部预留 60pt 可能过于保守，且模型自主选择的配色缺乏美感。为此，我调整底部预留空间至 50pt，并强制指定 <code>Sage &amp; Terracotta</code> 配色方案，要求模型重新生成。这次生成的结果相对来说质量提高了一些，但整体上仍然不及预期。</p><figure class="image ss-img-wrapper"><img alt="boris-claude-thumbs.jpg|500" src="https://cdnfile.sspai.com/2026/01/10/article/4381f17ac5bca7a281eda55da649830e.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p><strong>综上，我在使用原生的 PPTX Skill 生成演示文稿后，针对生成过程中出现的问题，优化了相关文件并最终解决了问题，但使用 Skill 生成的演示文稿质量没有达到开箱即用的地步。</strong></p><p>我认为将内容设计这一步骤提取出来，先根据内容生成设计文档，再作为提示词让模型生成演示文稿，可以进一步优化最终的质量。不过这一步留待下篇文章再优化了。</p><h2>PPT 生成哪家强</h2><p>本人苦 PPT 久矣。然而经过耗时耗力的探索，PPTX Skill 仅能交付 60 分的答卷，远未达预期。为此，我全面测试了市面上主流的 AI 演示文稿生成工具，结果如下。</p><h3>最强王者：Manus</h3><p>上传文稿并输入提示词 <code>分析Boris的9条技巧，生成Claude Code最佳实践的演示文稿（PPTX）。</code>，仅耗时 4 分钟，<code>Manus 1.6 Lite</code> 模型给出了一份 85 分的答案，演示文稿的内容和设计有 80 分水平，将 Boris 的推特原文截图放在 PPT 中大大超出我的预期，再加 5 分！</p><p>Manus 唯一的缺点是贵（当然这是我的问题），最便宜的套餐也要 17 美元一个月，提供 4000 积分。上面这次任务消耗了 142 积分，也就是说不做其他事情，17 美元的套餐一个月可以让你生成 28 张演示文稿。</p><p>目前 Manus 对于免费用户，每天也会赠送 300 积分，建议先与 AI 讨论并确认最终的演示文稿设计方案，再要求 Manus 生成，相信足以应对工作中的一般任务了（需要科学上网）。</p><figure class="image ss-img-wrapper"><img alt="Manus_Claude_Code_thumbnails_4cols_clean.jpg|500" src="https://cdnfile.sspai.com/2026/01/10/article/2a08cb276f88461d1e9a7932575c8836.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><h3>食之无味：NotebookLM</h3><p>NotebookLM 同样生成了超出我预期的演示文稿，它本质上是生成图片而不是 PPTX 文件，因此它的设计效果是最好的，并且根据内容生成了非常棒的配图。</p><p>但也因此，页面上的字都是“画”上去的，细节处常显模糊甚至结构混乱，远看是字，近看却像小儿涂鸦。</p><p>且最终输出仅为 PDF 格式，<strong>完全无法应对领导轮番的修改需求</strong>，实属“食之无味，弃之可惜”的鸡肋。</p><figure class="image ss-img-wrapper"><img alt="NotebookLM_Claude_Code_thumbnails_clean.jpg|500" src="https://cdnfile.sspai.com/2026/01/10/article/53153797c3bb4a3753450224b5e7e6d7.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><h3>勉强及格：Gemini Canvas</h3><p>打开 Gemini 网页，选择 <code>Canvas</code> 模式，即可让 Gemini 根据内容生成幻灯片，任务完成后可以导出到谷歌幻灯片，就能下载为 PPTX 格式。注意：如果首次生成后你觉得不满意，让 AI 调整格式，就无法导出到谷歌幻灯片了。</p><p>我选择了 Gemini Pro 模型，使用的提示词为：<code>分析Boris的9条技巧，生成Claude Code最佳实践的 PPT 。使用16:9 的比例，浅色背景，所有内容必须使用中文。</code>，产出质量不太稳定，需要多次生成来获得最佳结果。优化提示词应该能获得更好的效果。</p><p>Gemini 生成的演示文稿，内容和排版属于“勉强可以用”的程度，但是图标和图表都被转换成图片且清晰度较低，图表旁的文字也会被合并在图片里，需耗费大量精力进行二次调整。</p><figure class="image ss-img-wrapper"><img alt="Claude_Code_Boris_Tips_thumbnails_clean.jpg|500" src="https://cdnfile.sspai.com/2026/01/10/article/3d0bfec26fe90ec4dff9e7833232d0a3.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption><i>不知为何，缩略图中的文字和原文件中不相同，请忽略字体样式</i></figcaption></figure><h3>值得期待：Ima</h3><p>腾讯的 Ima 近期上线了与 Manus 近似的“任务模式”，官方的定义是“适合处理复杂任务，并自主交付结果”，经我实测，每次生成 PPT 需要 20-40 分钟，时间较长，不过最终可以交付一份 60 分的演示文稿。考虑到这个功能还在内测阶段，可以期待它后续的迭代。</p><p>Ima 的“任务模式”目前还在内测阶段，每个人每天仅可使用 5 次，邀请朋友注册 Ima 即可解锁。</p><figure class="image ss-img-wrapper"><img alt="Claude Code进阶实战：Boris的9条高效编程工作法.jpg|500" src="https://cdnfile.sspai.com/2026/01/10/article/b74acdba33b46e9339d0b1aed8235824.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><h2>小结</h2><p>实际上，优化 SKILL 的过程并非如文中描述般顺畅。这不仅仅是“发现 - 分析 - 解决”的线性流程，而是经历了二十余次反复试错，耗费整整一周业余时间探索后的成果。</p><p>要想驾驭当前的 SKILL，门槛依然较高：不仅需要理解 Agent Skills 原理，还需具备代码基础及脚本调试能力。目前它更适合专业开发者，距离大众化的“开箱即用”尚有距离。</p><p>如果你要问我接下来使用哪个工具来生成演示文稿？那当然是 Manus😛。</p>
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://sspai.com/post/105301</id>
            <title>打开 app 是我在iPhone上使用LLM的最大阻力</title>
            <link>https://sspai.com/post/105301</link>
            <guid isPermaLink="false">https://sspai.com/post/105301</guid>
            <pubDate></pubDate>
            <updated>Fri, 09 Jan 2026 10:17:58 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>OpenAI 发布的 ChatGPT3 是我第一次接触大语言模型（large language model，LLM），那时我觉得这样一个对话模型好像只能用来自娱自乐。但是将时间快进到 2026 年，LLM 已经完成了一次又一次的升级与进化。从一开始的简单对话，到如今的复杂图片创作；从一开始的终端模拟，到如今百花齐放的CLI（command line interface）；从一开始的简单代码编写，到如今小白也能上手的 vibe coding······可以说在 PC 上，得益于 LLM，我们的工作效率或者学习效率得到了极大提升，而LLM已俨然颠覆了甚至开创了一条有别于传统的工作流。</p><figure class="image ss-img-wrapper image_resized" style="width: 500px;"><img src="https://cdnfile.sspai.com/2026/01/09/0226d9cef0622ca91cec7acbbfbb261e.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>LLM 百家争鸣</figcaption></figure><p>可是当我拿起手机，面对无能的 Siri（至于 Apple Intelligence 则是遥遥无期） 亦或是面对各家 LLM 厂商推出的 app，我却根本提不起一点使用他们的兴趣。为什么在手机上，我对 LLM 如此的“性冷淡”呢？其实我自己给出的答案很简单，不是现在的 LLM 不够强大，而是手机本身限制了这一切。因为在手机上你只有一个常驻的，强制全屏的 app 在前台，你干其他任何事情你都需要打断你当前的进程。在 PC 上，我可以开多个任务能够保持在后台，我可能按一下键盘的某个快捷键，或者鼠标点一下某个图标就能呼出你与 LLM 对话的窗口，你甚至可以将某个 LLM 窗口保留在你的桌面上或者外接显示器桌面上。LLM 就像一个管家（好比贾维斯），时刻准备为你服务。但是在手机上呢？或者说在 iPhone 上呢？想象以下场景，你当前在微信聊天，亦或是在刷小红书，亦或是你在看剧，突然你需要 LLM 帮你解释某个问题或者翻译某些句子亦或是帮你设置待办事项。你这个时候只能上滑小白条，下拉 Spotlight 搜索某个 app 或者滑动屏幕找到那个 app，然后等待 app 打开，点击对话框，输入你的问题，等待他的回复，然后等待他的回复，最后等待他的回复。这一套操作下来可能花费不了多少时间，但是我觉得烦，非常的麻烦。因此，我需要一个入口，能够随时调用的入口，而且不会打断我当前正在进行的事情。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/09/d1f09fabd430c5da4abdfd0caf9ff54d.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>Apple Intelligence — the personal intelligence system for iPhone, iPad, and Mac. 图片来自 Apple</figcaption></figure><p>那么有没有这么一个app，能随时被你调用，不需要在 app 之间切换，而且还是 LLM？（虚晃一枪，没有广告，广告位招租）没有，这是真的没有。真的没有吗？首先是一个随时可以被调用的入口。让我们想一下，Apple 在 iPhone15 系列加入的 Action Button，或者辅助功能中的敲击背板能不能成为我们的一个入口呢？当然可以，那么现在随时可以调用的入口有了，还差一个 LLM。但是去哪里找一个不会在 app 之间切换的 LLM 呢？这是真的没有了，除非Apple Intelligence（催更国行）。但是我们可以用曲线救国的方式来实现，那就是通过快捷指令 app调用 api。你通过 app 使用 LLM 本质上其实就是厂商已经提前给你准备好了调用方式（endpoint + API + content），你只需要填充其中content 的内容就可以了。 得益于快捷指令，我们可以使用系统级的交互方式来调用 LLM，比如说弹窗输入、通知，只要快捷指令提供的，都能为你所用。最终，只要小小的阅读一下厂商提供的 API 手册，学习一点点的快捷指令使用指南，加上一点点的调试，我得到了一个理论上拥有无限可能，能够比较接近Apple Intelligence的“系统级”LLM。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/09/f1fdc7a3e12ca8f7e2e5aa1401a03d33.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>Nvidia NIM 的 api 手册部分</figcaption></figure><figure class="image ss-img-wrapper image_resized" style="width: 250px;"><img src="https://cdnfile.sspai.com/2026/01/09/6a49a79e88ab882a81880406043d90e1.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>快捷指令部分命令</figcaption></figure><p>长按Action Button，就能呼出LLM 交互菜单。我预设了三个来自三家供应商的不同模型，分别是 siliconflow 的 qwen3-80b-a3b，nvidia 的 gpt-oss-120b，google 的 gemini3-flash。这三家提供的这三个模型都有一个共同特点，那就是回复很快，其中 gemini3-flash 是又强又快。为什么要回复快呢？因为快捷指令无法修改请求回复的等待时间。假如 LLM 回复的太慢，已经达到了快捷指令的等待时间上限，那么快捷指令不会继续等待，会执行下一条命令。选择模型后，我预设了三个功能，分别是问题回答、中英互译、待办事项添加。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/09/00efb0b388f00ecb7b4e8887e7d3aff2.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p>首先是问题回答，分为思考与不思考（虽然我大多数选择思考，而且现在很多模型都有根据问题来自动设置思考的程度的功能），选择一个选项后，会有一个输入框弹出，输入你的问题点击完成，就可以向LLM 发送请求了。等待一会儿便会弹出问题的答案，这期间你可以干任何事情，不过这个弹窗很容易会被误触，只要点击弹窗外的任何地方，弹窗就会消失，但是我们可以优化这个弹窗的显示逻辑。</p><figure class="image ss-img-wrapper image_resized" style="width: 444px;"><img src="https://cdnfile.sspai.com/2026/01/09/ac2dac0ae67e25c73bb8f4a20fc4defc.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><figure class="image ss-img-wrapper image_resized" style="width: 444px;"><img src="https://cdnfile.sspai.com/2026/01/09/0dbf9c0a1808971d40a923d76497e6c2.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p>第二项功能是中英互译，当然也可以根据 prompt 的不同来翻译其他语言。最重要的是，你可以在你当前屏幕上选择任何内容，然后长按 Action Button 呼出 LLM，之后将句子粘贴进输入框就可以得到译文，而且始终停留在你当前的页面。</p><figure class="image ss-img-wrapper image_resized" style="width: 510px;"><img src="https://cdnfile.sspai.com/2026/01/09/cb49b5ab74b7aafe4efd46519cba6fd4.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p>最后一个功能是待办事项的添加。你可以直接使用语音输入你的日程，得益于 LLM 的强大理解力，你的输入甚至能口语化，或者在输入中假如一些无关的内容，LLM 也会将你的日程整理出来，并且通过快捷指令将其添加到你的待办事项。最重要的是，这一切只需要你用用语音输入你日程，然后在屏幕上继续你的工作，所有的一切都会在后台自动完成。</p><figure class="image ss-img-wrapper image_resized" style="width: 510px;"><img src="https://cdnfile.sspai.com/2026/01/09/1b113e368cad27c2226bc28b0c8e20a9.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p>在第一个功能的基础上，除了弹窗容易消失的问题，系统弹窗也不能很好的兼容 markdown 格式，因此我使用熊掌记来记录问题的答案或者翻译的结果。熊掌记对快捷指令的支持非常完善，而且该 app 也足够轻量化没有其他乱七八糟的功能，有的只是 markdown 的编辑与显示（不是广告）。</p><figure class="image ss-img-wrapper image_resized" style="width: 510px;"><img src="https://cdnfile.sspai.com/2026/01/09/19b71429e66979ffff861baf4fcf86e3.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p>不过当前的快捷指令也只是一个勉强能用的状态，称不上有多么好用，能最基本满足我的需求。对我来说已经足够了，因为我在手机上使用 LLM 的次数比以前多了很多，我现在一有想法就会按下那颗AI 按键呼出随时待命的助手。</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p>
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://sspai.com/post/105279</id>
            <title>使用 Raycast 搜索 Confluence 或 Jira</title>
            <link>https://sspai.com/post/105279</link>
            <guid isPermaLink="false">https://sspai.com/post/105279</guid>
            <pubDate></pubDate>
            <updated>Fri, 09 Jan 2026 06:21:28 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <h2>前言</h2><p>如果你用过 Alfred，还没有用过 <a href="https://raycast.com/?via=73820f">Raycast</a>，不妨试试，其免费订阅也足够好用（<a href="https://www.raycast.com/raycast-vs-alfred?via=73820f">Raycast vs Alfred</a>）。</p><p>免费订阅用户无法享用 Raycast 内置的数据同步功能，可借助 Raycast 的 Export/Import Settings &amp; Data + iCloud Drive 进行同步。</p><h2>背景</h2><p>我们公司使用 Atlassian 旗下的 Confluence、Jira 做知识库、项目管理。</p><p>我们要经常打开 wiki 和 jira 页面查看相关内容，找到一篇目标文章或 Issue，往往需要几个动作才能完成：打开网页、聚焦输入框搜索、筛选...。稍快一点可能是将常用链接添加到书签或者创建 Raycast Quicklink + Alias 方便快速访问。</p><p>其中 Quicklink 有些场景很好用，比如检索文档：<code>https://developer.mozilla.org/zh-CN/search?q={Query}</code>，其中 <code>{Query}</code> 表示动态参数，也就是你要搜索的内容。只要是支持链接带参搜索的网站，都可以用这种方式，比如爱范儿的 <code>https://www.ifanr.com/search?query={Query}</code>。</p><p>但这种搜索方式在公司内部的 wiki、jira 中行不通。另外，通过创建 Quicklink 的方式其实“不太适合”公司内的文档检索。试想，随着时间积累，要访问、收藏的链接只会越来越多，无论是浏览器书签或 Quicklink 只会越来越多。</p><p>于是产生了开发一个 Raycast 扩展的想法，以支持 Confluence 和 Jira 的快速搜索以及部分简单操作。恰好公司私有部署版本（Data Center）也支持以 Personal Access Token 的方式进行身份认证，这是一种安全的认证方式以便于与外部程序集成。<a href="https://confluence.atlassian.com/enterprise/using-personal-access-tokens-1026032365.html">了解更多</a></p><h2>开始之前</h2><p>安装 Raycast 后，前往 Raycast Store 安装 <a href="https://raycast.com/tofrankie/atlassian-data-center?via=73820f"><strong>Atlassian Data Center (Self-Hosted)</strong></a> 扩展。</p><p>使用该扩展的命令时，会引导完成一些初始配置，准备好以下信息：</p><ul><li>Confluence Base URL：如 https://confluence.example.com</li><li>Confluence PAT：前往公司 Confluence 网站，在 Profile（头像处） → Personal Access Tokens → Create token（<strong>请妥善保管访问令牌，如有泄露，及时撤销</strong>）</li><li>Jira Base URL：https://jira.example.com</li><li>Jira PAT：创建方式跟 Confluence 同理</li></ul><blockquote><p>PS：由于以上配置做成必填的，如果只用到其一，另一个可以随便填个值，非空便可。</p></blockquote><h2>使用指南</h2><blockquote><p>PS：还可以根据个人习惯为命令设置 Alias 更方便直达命令</p></blockquote><p>目前 Atlassian Data Center 提供的命令有：</p><ul><li>Confluence<ul><li>Search Contents - 搜索页面（文章）、博文、附件、评论，支持收藏功能</li><li>Search Spaces - 搜索空间</li><li>Search Users - 搜索用户</li></ul></li><li>Jira<ul><li>Search Issues - 搜索 Issue，并支持一些简单的操作，比如扭转 Issue 状态、创建 Worklog</li><li>Board View - 看板，比如当前 Active Sprint</li><li>Worklog View - 你的工作记录</li><li>Notification View - 通知列表（若有“未读”消息，在 Search Issues 列表也会提示）</li><li>Manage Fields - 该命令的作用是辅助 Search Issues 以在搜索结果展示更多内容</li></ul></li></ul><p>每个搜索面板都内置了很多常用的筛选项（日常应该管够了）：</p><ul><li>Search Contents<ul><li>All Contents</li><li>Full Text Search - 搜索范围从 title ~ "xxx" 放宽到 text ~ "xxx"，而不仅仅搜索标题</li><li>Viewed Recently</li><li>Updated Recently</li><li>Created by Me</li><li>Contributed by Me</li><li>Mention Me</li><li>My Favourites</li><li>Watched by Me</li></ul></li><li>Search Issues<ul><li>All Issues</li><li>Full Text Search - 搜索范围从 summary ~ "xxx" 放宽到 text ~ "xxx"</li><li>Open Issues</li><li>My Open Issues</li><li>Assigned to Me</li><li>Reported by Me</li><li>Created Recently</li><li>Updated Recently</li><li>Resolved Recently</li><li>Viewed Recently</li><li>Watched by Me</li></ul></li></ul><p>前面提到时间越长 Quicklink 越多的情况，我认为将文章进行收藏是一个不错的方案（在 Action Panel 提供了快速收藏和取消收藏），检索时切换至 My Favourites 选项便可。</p><p>除此之外，还支持键入完整的 CQL 或 JQL 进行定制化的高级查询：</p><ul><li><a href="https://developer.atlassian.com/server/confluence/rest/v1020/intro/#advanced-searching-using-cql">Confluence Query Language</a></li><li><a href="https://confluence.atlassian.com/jiracoreserver/advanced-searching-939937709.html">Jira Query Language</a></li></ul><p>再提一句：</p><p>由于 Jira 允许自定义字段，字段类型繁多，加之各家 Jira 实例大不相同，因此添加了 Manage Fields 命令来辅助 Search Issue 以显示更多信息。</p><p>比如在 Manage Fields 界面下搜索 Test Engineer 并通过「Add to Search」添加成功，那么 Search Issues 列表下就可以显示该字段信息。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/09/article/3ce06a8a2860130d7df0b4b495edee5a.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><h2>截图</h2><p><strong>由于 Raycast List 显示的内容有限，很多附加信息只能隐藏在 tooltip 里，可以通过移动光标至图标、标题、副标题、时间、头像等处显示。</strong></p><p>▼ Confluence</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/09/article/bfc17c02321b51a6d5836f7d177c5c00.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p>▼ Jira</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/09/article/ec33ffddb170c3395ec8acbb4ed827c9.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p><a href="https://www.raycast.com/tofrankie/atlassian-data-center?via=73820f">更多截图</a></p><h2>其他</h2><p>个人常用的一些 Raycast 扩展，但不一定适合你，按需食用：</p><ul><li><a href="https://www.raycast.com/tmk/lark?via=73820f">Lark Documents</a> - 搜索飞书文档</li><li><a href="https://www.raycast.com/degouville/cursor-recent-projects?via=73820f">Cursor</a> - 常用 Search Recent Projects</li><li><a href="https://www.raycast.com/tofrankie/wechat-devtool?via=73820f">WeChat DevTool</a> - 启动小程序</li><li><a href="https://www.raycast.com/vivek/deepwiki?via=73820f">DeepWiki</a> - 了解一些库内部实现问答可能更快</li></ul>
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://sspai.com/post/105230</id>
            <title>Agent Skills 终极指南：入门、精通、预测</title>
            <link>https://sspai.com/post/105230</link>
            <guid isPermaLink="false">https://sspai.com/post/105230</guid>
            <pubDate></pubDate>
            <updated>Fri, 09 Jan 2026 03:00:22 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <h2><strong>🎐 卷首语</strong></h2><p><strong>应该是全网最好的 Skills 中文指南与教程，全文 1.2w 字，包含了我对 Skills 的完整应用思考。</strong></p><p style="margin-left: 0px;">巧借通用 Agent 内核，只靠 Skills 设计，就能低成本创造具有通用 AI 智能上限的垂直 Agent 应用。</p><p style="text-align: right;"><strong>@ 一泽Eze</strong></p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/09/cba34d69708aedf3c05053aac4982949.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><hr /><p style="margin-left: 0px;">Claude Skills 的价值，还是被大大低估了。</p><p style="margin-left: 0px;">一个好 Skill 能发挥的智能效果，甚至能轻松等同、超越完整的 AI 产品。任何不懂技术的人，都能开发属于自己的 Skills。</p><p style="margin-left: 0px;">比如我自己做的 Article-Copilot，一个 skill 就实现了从素材处理到正文写作的 Agent 应用；</p><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/2e7091c71a8951048eea2015017cf12a.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 0px;">又如 AI Partner Skill，让通用 Agent 深度学习你的记忆，塑造懂你的 AI 伴侣，给到个性回应。</p><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/5d354d43867dfbf8d38cf24ba5892d37.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 0px;">在研读 Anthropic 官方技术博客，与持续 Agent Skill 实验之后，形成了<strong>这份全网最完整的 Skill 指南</strong>，包含：</p><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/f2d806bf839e78deae3c75d330d749fe.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><ol><li>最容易读懂的<strong> Skills 概念与原理介绍</strong></li><li>讨论 Skills 的真实价值、技术优势、<strong>对 AI 产品设计的影响</strong></li><li><strong>非常完整的 Skills 使用与开发教程</strong></li><li>Skills 的场景识别，什么时候适合开发、使用 Skills？</li></ol><p style="margin-left: 0px;">从概念澄清、运作机制，到实践教程、应用价值，与你在本期分享。</p><hr /><h2><strong>一、Skills 是什么：从概念来源到运作原理</strong></h2><p style="margin-left: 0px;">2025 年 10 月中旬，Anthropic 正式发布 Claude Skills。</p><p style="margin-left: 0px;">两个月后，Agent Skills 作为开放标准被进一步发布，意在引导一个新的 AI Agent 开发生态。</p><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/edf2cfcd31b8fe21306a13be96429566.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 0px;">OpenAI、Github、VS Code、Cursor 均已跟进。</p><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/5a5c3f4664e63bb646f5c8a6a8a97aad.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 0px;">为了更好的理解，你可以把 <strong>Skills 理解为“通用 Agent 的扩展包”</strong>：</p><p style="margin-left: 0px;">Agent 可通过加载不同的 Skills 包，来具备不同的专业知识、工具使用能力，稳定完成特定任务。</p><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/a49a03b0b322400130555f00cbbfeefc.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 0px;">最常见的疑惑是：这<strong>和 MCP 有什么区别</strong>？</p><ul><li><strong>MCP</strong> 是一种开放标准的协议，关注的是 AI 如何以统一方式调用外部的工具、数据和服务，本身不定义任务逻辑或执行流程。</li><li><strong>Skill</strong> 则教 Agent 如何完整处理特定工作，它将执行方法、工具调用方式以及相关知识材料，封装为一个完整的「能力扩展包」，使 Agent 具备稳定、可复用的做事方法。</li></ul><p style="margin-left: 0px;">以 Anthropic 官方 Skills 为例：</p><ul><li><strong>PDF</strong>：包含 PDF 合并、拆分、文本提取等代码脚本，教会 Agent 如何处理 PDF 文件 - 提取文本，创建新的 PDF、合并或拆分文档。</li><li><strong>Brand-guidelines</strong>：包含品牌设计规范、Logo 资源等，Agent 设计网站、海报时，可参考 Skill 内的设计资源，自动遵循企业设计规范。</li><li><strong>Skill-Creator</strong>：把创建 Skill 的方法打包成元 Skill，让 AI 发起 Skill 创建流程，引导用户创建出符合需求的高水准 Skill。</li></ul><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/53b16a3d2177984611e2ad97a232d6b7.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>Skill-Creator：教 Agent 如何帮用户创建新 Agent 的技能</figcaption></figure><p style="margin-left: 0px;">但 Skills 的价值上限，远不止于此。</p><p style="margin-left: 0px;">它应该是一种极其泛用的新范式，从垂直 Agent 到 AI 产品开发：<strong>借用通用 Agent 内核，0 难度创造具备通用 AI 智能的垂直 Agent 应用。</strong></p><p style="margin-left: 0px;">本文开头提到的 article-copilot、AI Partner Skill，就是对这种可能性的验证。</p><p style="margin-left: 0px;">&nbsp;</p><p style="margin-left: 0px;">让我们从 Skill 的运作原理讲起。</p><hr /><h3><strong>首先，如何理解 Skill？</strong></h3><p style="margin-left: 0px;">Anthropic 说：</p><blockquote><p style="margin-left: 0px;">Skills 是模块化的能力，扩展了 Agent 的功能。每个 Skill 都打包了 LLM 指令、元数据、可选资源（脚本、模板等），Agent 会在需要时自动使用他们。</p></blockquote><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/9e9989ca3efee07b6c20ad7e2824bc02.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 0px;">我有个更直观的解释：<strong>Skill 就像给 Agent 准备的工作交接 SOP 大礼包</strong>：</p><p style="margin-left: 0px;">想象你要把一项工作交给新同事。若不准口口相传，只靠文档交接（而且你想一次性交接完成，以后不被打扰），</p><p style="margin-left: 0px;">你会准备什么？</p><ul><li>任务的执行 SOP 与必要背景知识（这件事大致怎么做）</li><li>工具的使用说明（用什么软件、怎么操作）</li><li>要用到的模板、素材（历史案例、格式规范）</li><li>可能遇到的问题、规范、解决方案（细节指引补充）</li></ul><p style="margin-left: 0px;">⬇️</p><p style="margin-left: 0px;">Skill 的设计架构，几乎是交接大礼包的数字版本：</p><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/2dbc5e6840c17726c5ea2cf7ffe44bd8.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>相对标准的 Skill 结构示例，实际案例中，只有 SKILL.md 是必需的，其他结构为可选项</figcaption></figure><p style="margin-left: 0px;">在 Skill 中，<strong>指令文档用于灵活指导，代码用于可靠性调用，资源用于事实查找与参考</strong>。</p><p style="margin-left: 0px;">当 Agent 运行某个 Skill 时，就会：</p><ol><li>以 SKILL.md 为第一指引</li><li>结合任务情况，判断何时需要调用代码脚本（scripts）、翻阅参考文档（ref.）、使用素材资源（assets）</li><li>通过“规划-执行-观察”的交错式反馈循环，完成任务目标</li></ol><p style="margin-left: 0px;">当然，Skill 也可以用来扩展 Agent 的工具、MCP 使用边界，<strong>通过文档与脚本，也可以教会 Agent 连接并使用特定的外部工具、MCP 服务</strong>。</p><p style="margin-left: 0px;"><i>举个例子，这是 PPTX Skill 的文件目录：</i></p><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/33ca2d3c15c2c7c7fc852b4cb1194e07.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><ul><li>整个文件夹就是一个完整的能力包，用来支持 AI 创建、编辑和分析 PowerPoint 演示文稿。</li><li>核心文件是 <code><strong>SKILL.md</strong></code>，包含技能的元数据和任务指导，告诉 agent 什么时候使用这个技能、如何按步骤处理任务。特别的，独立子技能往往会被拆为<strong>子文档</strong>（如教 AI 把 html 导出为 pptx 流程的 <code>html2pptx.md</code>），以避免一次性加载过长的 skill 文档，节省上下文窗口</li><li><code>Scripts/</code> 包含 Agent 可用的各类预先写好的程序脚本，比如 html 转 pptx 的一键程序脚本。这样 Agent 运行任务时就无需临时开发工具，直接调用，节省 tokens ，避免出错，提升速度</li><li>也有一些参考文档（此项目打包的不算规范，但根据 SKILL.md ，Agent 也能理解哪些文档可以参考），比如 ooxml.md，是对 ooxml 格式文件的解析指南</li></ul><p style="margin-left: 0px;">整个 Skill 以简明的形式，把技能指引文档、代码脚本、参考文档和可用资源组合，定向扩展了 Agent 完成 pptx 生成相关的工作能力。</p><hr /><h3><strong>Skills 的真实价值：垂直 Agent 的未来态</strong></h3><p style="margin-left: 0px;">看好 Skills 价值与未来生态发展的原因是，Skills 与其他 AI 应用开发方式，有底层机制的不同：</p><p style="margin-left: 0px;"><strong>人给出专业知识与工具方法，通用 Agent 提供智能，自主理解，主动执行。</strong></p><p style="margin-left: 0px;">说人话就是：人给指引，最终 Agent 还能根据自己的智力看着执行。</p><p style="margin-left: 0px;">而且「Agent + 文件」的形式，足够泛用。</p><p style="margin-left: 0px;">这就相较于它的前辈们（Workflow 和程序编写的 AI 应用）有了 <strong>3 个关键优势</strong>：</p><ul><li>非技术人员可用零代码、自然语言编写</li><li>能突破预设限制，灵活响应用户输入，应对边缘情况</li><li>甚至能多个 Skill 自由联用，应用方式极其灵活</li></ul><p style="margin-left: 0px;">这一部分可能会比较深入，但例证完善，实际上不会很难懂。虽一家之言，但仍有助于理解 Skill 价值与 Agent 发展趋势</p><h4 style="margin-left: 0px;"><strong>1️⃣ 零代码、自然语言，编写真·智能 Agent</strong></h4><p style="margin-left: 0px;">纵观此前的 AI 应用开发方法：</p><ul><li>不必多说程序编写的 AI 应用，必须懂程序逻辑、懂技术实现。</li><li>即便是 Coze、Dify、N8N 等近年流行的 Workflow 平台，也得理解节点配置、条件分支，仍算「编程」，只是界面友好一些。</li></ul><p style="margin-left: 0px;">而 Skills 的创建门槛，完全不同：<strong>入门门槛极低，智能上限极高</strong>。</p><p style="margin-left: 0px;"><strong>1）最简单的，以 Anthropic 的 brand-guidelines skill 为例</strong></p><p style="margin-left: 0px;">仅有一个 SKILL.md，纯自然语言写成。</p><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/a12d4022308ac99f2b43e1d8ca05acdb.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><ul><li>元信息：什么时候用这个 Skill</li><li>正文：品牌颜色、字体等文本描述信息</li></ul><p style="margin-left: 0px;">但足以引导 Agent 变成符合 Anthropic 品牌设计的垂直 Agent，可用于品牌官网、海报、PPT 设计。</p><p style="margin-left: 0px;">当你要设计一个符合 Anthropic 公司设计规范的 AI 搜索网站，Agent 就会自动运行该 Skill ⬇️</p><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/a84b439e0c33c98e0d1fdce7bb87432a.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><blockquote><p style="margin-left: 0px;">Skill 有两种加载模式：显式 / 隐式。</p><p style="margin-left: 0px;">前者通过 user query 直接指定调用；后者根据任务与元信息描述的相关性，LLM 自动匹配。</p></blockquote><p style="margin-left: 0px;">这是该 skill agent 一次性开发的网站，调性接近 Claude 官网设计：</p><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/63d7060ddbaf9a9e27765dc0ecd31f3e.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/d0a34381f9ce8eea85f655a3ec58b1ab.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>（我电脑上缺了他家的 Serif 字体，实际上可以更像）</figcaption></figure><hr /><p style="margin-left: 0px;"><strong>2）复杂的，以 AI-Partner Skill 为例，一个 Skill 就是一个复杂 Agent</strong></p><p style="margin-left: 0px;">包含 SKILL 文档、向量数据库构建指南、向量数据库使用脚本、AI 伴侣与用户的 Persona 模板资源</p><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/df1c8fffeaebe4d8d38572e16991254a.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 0px;"><code>SKILL.md</code> 本体依然由自然语言写成：</p><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/fbb3a08531127a57cb48ff4f24e27c32.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 0px;">借此，Agent 就能理解 AI-Partner 的初始化与对话方法，引导用户上传包含个人记忆的文档预料，在用户端智能切分笔记片段，构建向量数据：</p><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/a80ddeaecec1c28e4d461fa9ba555fe6.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 0px;">解析用户记忆文档，提炼个性化的 AI 伴侣与用户画像设定：</p><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/3ac95a134b566c206beb92bb82ca989d.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/3f387b9a433cd375c6a625cefe6e760e.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 0px;">最终智能检索用户记忆，提供懂用户的 AI Partner 对话体验：</p><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/08aba8b9a8937879f0637c926df8025e.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 0px;">这能基本验证：单靠 Skill + Agent 所构造的垂直 Agent，所实现的智能效果，无异甚至可超过同类 AI 产品。</p><p style="margin-left: 0px;">&nbsp;</p><p style="margin-left: 0px;">而做这些垂直 Agent，都不用编写程序代码。</p><p style="margin-left: 0px;">非技术出身的领域专家，离自己做专业 Agent 只剩隔着一层窗户纸——</p><p style="margin-left: 0px;">把你的专业经验和工作流程，用文档形式写清楚，Agent 就能照着执行。</p><hr /><h4 style="margin-left: 0px;"><strong>2️⃣ 突破预设限制，灵活应对实际情况</strong></h4><p style="margin-left: 0px;">Agents Skill 的这一优势往往被忽视。</p><p style="margin-left: 0px;">&nbsp;</p><p style="margin-left: 0px;"><strong>Workflow 或 传统程序 的核心问题是，它们假设所有情况都能预设。</strong></p><p style="margin-left: 0px;">比如基于用户记忆的 AI 个性化助理，往往需要提前设定：</p><ul><li>用户导入记忆文件的入口</li><li>允许用户上传的文件格式</li><li>数据应该包含哪些字段</li></ul><p style="margin-left: 0px;">以及可能出现哪些特殊情况，每种情况如何处理。</p><p style="margin-left: 0px;">&nbsp;</p><p style="margin-left: 0px;">但现实往往是：</p><ul><li>需要教育用户在哪点击「导入」</li><li>用户只有预期之外的格式：预期支持 md，但实际只有 doc</li><li>数据字段不符：预期每个文件需要一个标题，但用户文件没有标题</li></ul><p style="margin-left: 0px;">或者出现了预设之外的边缘情况。</p><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/dd27cfee5c7df845ce2c6cb878289a59.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 0px;">这时 Workflow 或传统程序就卡住了，它只能按预设路径执行，遇到意外就报错，或要求用户自行消除差距。</p><p style="margin-left: 0px;">&nbsp;</p><p style="margin-left: 0px;"><strong>而通用 Agent + Skill 应用的运作方式完全不同：</strong></p><ul><li>能在统一的对话框，接收各类用户数据（文本、文件、图片）</li><li>能自主调用其他 Skill，或即时编写 doc2md 脚本，自动转换用户格式</li><li>能提炼补充每个文件的标题，完成数据入库处理</li><li>能基于 LLM 的推理智能，弥合各类边缘问题</li></ul><p style="margin-left: 0px;">用 Skill 做的垂直 Agent，以 Skill 的知识与方法为指引，能巧借 Agent 内的 LLM 智能，灵活应对各类问题。</p><blockquote><p style="margin-left: 0px;">所以在 AI-Partner-Chat 中，也有过很有意思的探索：</p><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/b27b4581215c681472535a2282d3b7e3.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 0px;">借 Agent 本身的“观察-规划-执行”的动态智能，对用户文档进行自适应切片，而非所有文件都按照固定的分隔符 or 字数切分。</p><p style="margin-left: 0px;">（DailyNotes 按照日期标题切分；项目笔记按照标题级别与语义切分）</p><p style="margin-left: 0px;">这样能得到更符合实际情况的 RAG 切片。</p></blockquote><hr /><h4 style="margin-left: 0px;"><strong>3️⃣ 多 Skills 自由联用</strong></h4><p style="margin-left: 0px;">Agent Skills 实质仍是 Context 工程，Skills 只是把垂直领域的知识、脚本调用方法等挂载到 Agent 的上下文窗口。</p><p style="margin-left: 0px;">所以 Skills 在实际应用中极其灵活，甚至在一次任务中能调用多个 Skill。</p><p style="margin-left: 0px;">比如：</p><ul><li>联用 <strong>brand-guidelines + pptx</strong>，自动制作符合品牌规范的 pptx</li><li>联用 <strong>AI-Partner-Chat + Article-Copilot</strong>，写出更符合个人思考与文风的内容</li></ul><p style="margin-left: 0px;">&nbsp;</p><p style="margin-left: 0px;">也可以是更复杂的场景，如做一份产品分析报告：</p><ol><li>从网页抓取竞品数据（Web Scraping Skill）</li><li>提取 PDF 中的用户反馈（PDF Skill）</li><li>分析数据并生成图表（Data Analysis Skill）</li><li>按品牌规范制作 PPT（Brand Guidelines + PPTX Skill）</li></ol><p style="margin-left: 0px;">每多一个 Skill，就多一种能力，N 个 Skill 可以应对远超 N 的应用场景。</p><hr /><h3><strong>☞ Skills 核心运行机制：渐进式披露</strong></h3><p style="margin-left: 0px;">这节旨在讲解 Skills 运作的核心机制之一：渐进式披露。</p><p style="margin-left: 0px;">整体更偏技术理解，如果只是想用 or 做 Skill，可以滑到下一部分</p><p style="margin-left: 0px;">&nbsp;</p><p style="margin-left: 0px;">正如 <a href="https://mp.weixin.qq.com/s/OtDWk8aZ6ok54SS7EF6ybg">《有效的 Context 工程》</a> 文中所论证的，上下文过长容易导致模型能力下降。</p><p style="margin-left: 0px;">由于 Skills 的本质就是 Context 工程，所以这个问题也需在 Skill Agent 中注意。</p><p style="margin-left: 0px;">一个完整装载了 Skill 的 Agent 架构是这样的：</p><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/f52750defc7660fdf326a71da3422b50.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 0px;">Skill 包放在 Agent 文件系统（右侧）中，并非默认全量加载在 Context Window 中。</p><p style="margin-left: 0px;">根据 Context 加载顺序、优先级的不同，Skill 被划分为了 3 种层级：</p><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/06a41540b65c2ad8e167cf2cb0163113.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>Skill 内容物的 3 种渐进披露优先级</figcaption></figure><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/f09431ebc2ab4e1910c6be8db83448c7.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>渐进披露的流程图解</figcaption></figure><p style="margin-left: 0px;"><strong>1）Level 1（元数据，始终加载）：</strong></p><p style="margin-left: 0px;"><code>SKILL.md</code> 文档内的元数据，包含名称与用途描述。</p><p style="margin-left: 0px;">长度约 100 tokens。</p><p style="margin-left: 0px;">Agent 启动时，就在 Context Window 中加载 Skill 元数据，将其包含在系统提示中。</p><p style="margin-left: 0px;">AI 通过理解用户消息与 Skills 元数据的匹配情况，判断是否需要自动使用技能。</p><pre class="language-Plain"><code>---
name: pdf
description: 全面的 PDF 操作工具包，用于提取文本和表格、创建新 PDF、合并/拆分文档以及处理表单。当 Claude 需要填写 PDF 表单或大规模地程序化处理、生成或分析 PDF 文档时使用。
---</code></pre><p style="margin-left: 0px;">默认只加载元数据 → 意味着可以给一个 Agent 同时安装很多 Skills 但不影响上下文性能。</p><p style="margin-left: 0px;">&nbsp;</p><p style="margin-left: 0px;"><strong>2）Level 2（指令，触发时加载）：</strong></p><p style="margin-left: 0px;"><code>SKILL.md</code> 文档内的正文内容，也就是主要技能指令，一般包含工作流程、最佳实践和指导。</p><p style="margin-left: 0px;">建议少于 5000 tokens。</p><p style="margin-left: 0px;">当用户发出的消息与Skill 元数据的描述匹配，需要调用 Skill 时，Agent 才会用 bash 读取文档正文 。读取时文档内容加载到 Context Window 中。</p><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/aa27515a0708a9491e84429628e8c2a2.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>SKILL.md 的结构：分为 YAML 元数据与 MD 正文</figcaption></figure><p style="margin-left: 0px;">&nbsp;</p><p style="margin-left: 0px;"><strong>3）Level 3（子技能指令</strong> <strong>/</strong> <strong>资源 / 代码，按需动态加载）：</strong></p><p style="margin-left: 0px;">由子技能文档、代码脚本、参考文档、可用资源等文件构成。</p><p style="margin-left: 0px;">也有 Agent Skill 规范文档将它们统称为「Resource」。相对来讲，Level 3 结构要求没那么严谨。</p><p><strong>· Sub-SKILL.md 子技能文档</strong>：相对独立、复杂的子技能指令，单独放在 Level3 拆分加载</p><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/880fb5048dc85721c4cb5d5a2cc7f612.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 0px;">随着一个 Skill 的复杂度提升，可能因为技能知识的上下文过长，或者有些知识仅在特定场景使用，而不适合放入单个<code>SKILL.md</code>，可被分拆为独立指令文档，仅在必要时加载。</p><p><strong>· Scripts 代码脚本</strong>：视作“Agent 的可执行资源”，而不算 tool use（tool use 是 Agent 外部调用的独立服务）</p><p style="margin-left: 0px;">Agent 在 Agent 电脑（虚拟机）中直接调用脚本，脚本代码本身不进 Context Window，只有脚本运行完成后的输出会进 Agent 的 Context。</p><p><strong>· Reference 参考文档、Assets 可用资源</strong>，当然都是 Level 3，仅在必需时动态读取加载。</p><p style="margin-left: 0px;">Level 3 因为按需加载的特性，文件在被访问前不会占用 Context 长度，所以没有内容大小限制，可按业务实际说明需要添加材料。</p><p style="margin-left: 0px;">⬇️</p><p style="margin-left: 0px;">小结：整个 Skill 运行过程中，Agent 自动判断哪些技能与任务相关，根据 skills 的元信息，动态判断、加载完成任务所需模块：</p><pre class="language-Plain"><code>Level 1: SKILL.md 元数据（name + description）
 &nbsp; &nbsp; &nbsp; &nbsp; ↓
Level 2: SKILL.md 完整内容
 &nbsp; &nbsp; &nbsp; &nbsp; ↓
Level 3: Resources 中的具体文件（按需读取）</code></pre><p style="margin-left: 0px;"><strong>言午</strong> 在<a href="https://mp.weixin.qq.com/s/F9BtGpZNQxLkalg62ayBXw">《Claude Skills背后的信息分层设计哲学》</a>一文中，亦有形象的图解：</p><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/afc6d89b605eed2799d133104523f7d7.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 0px;">不过，即使 Agent Skill 支持「渐进式披露」。</p><p style="margin-left: 0px;">但在商业化的 Agent 产品中，单个或多个 Skills 联用，如何稳定控制运行过程中的 Context 长度，依然是绕不过的工程问题。</p><h3><strong>☞ Skills 对 AI 产品设计的影响</strong></h3><p style="margin-left: 0px;">我先和在做 Agent 平台的朋友 <strong>@付铖</strong> 讨论了一个问题：</p><p style="margin-left: 0px;"><strong>基于 Skills 做的垂直 Agent 应用，会不会有依赖推理，响应速度降低的问题？</strong></p><p style="margin-left: 0px;">我俩是在一个 Agent 开发者闭门会认识的，当时觉得他的 Agent 认知相当深刻。他负责的正是 Agent 平台的产品策划与研发。</p><p style="margin-left: 0px;"><strong>他给了一组很有意思的启发：</strong></p><ol><li>Skills 是一种非常宽容的 Agent 设计架构</li><li>Skills 可以被设计为很多 tokens 的指令文档，引导模型思考；也可以是无需思考的简单指令，直接指向可直接运行的脚本代码</li><li>因为 Skills 能直接调用代码逻辑，不进 Context 窗口。所以用 skill 也不需要 agent 一直推理，agent 也可以只承担类似 hook 的角色，实质上和正常程序运行并无差别</li><li>所以 Skills 慢起来可以是 prompt，快起来也可以是 workflow</li></ol><p style="margin-left: 0px;">另外，再结合两个趋势的极端判断：</p><ol><li>token 价格会下降</li><li>agent 速度会提升</li></ol><p style="margin-left: 0px;">这么看来，以 Skills 为基础的垂直 Agent，在性能、开销上的问题，也不是不可解决的持续性问题了。</p><p style="margin-left: 0px;">&nbsp;</p><p style="margin-left: 0px;">所以，进一步<strong>推演未来 ai native 产品的发展趋势，我目前的猜测是：</strong></p><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/45daa4c9c3c0619194c72a49d925ccc6.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><blockquote><p style="margin-left: 0px;">拿笔记类 APP 举例，大部分 APP 的逻辑还是：新笔记 -&gt; 代码 -&gt; 处理。新笔记完全用代码逻辑，原模原样直接入库。</p><p style="margin-left: 0px;">但如果是 ai native 式的笔记 APP，他们可能会内置一些类似 skill 的指引，包括笔记入库、智能纠错、冗余笔记合并等。这些 skill 有些可能以 prompt 为主（需要生成），有些基本只有代码逻辑（快速响应）。</p><p style="margin-left: 0px;">&nbsp;</p><p style="margin-left: 0px;">当用户写新笔记时，ai 快速自行判断：能不能直接入库？要不要智能纠错？有没有冗余的历史相似笔记需要合并？</p><p style="margin-left: 0px;">每种情况，都由 agent 拿着各种 skills 自动匹配来处理。</p></blockquote><p style="margin-left: 0px;">这样下来，Skills-based 的 Agent 产品，就能<strong>用同一个多模态输入框，处理用户各种不同的输入</strong>，也能灵活应对未被规划的边缘问题、<strong>为用户提供绝对个性化的生成需求</strong>了。</p><hr /><h2><strong>二、Skills 完全教程：制作与使用</strong></h2><p style="margin-left: 0px;">如果你看到了这里，那 Skills 对于 AI 应用开发的价值就不言而喻了：</p><p style="margin-left: 0px;"><strong>巧借通用 Agent 内核，只关注 Skills 设计，能低成本创造兼具通用 AI 智能上限的垂直 Agent 应用。</strong></p><p style="margin-left: 0px;">对于 Agent 开发者，尤其是非技术出身的团队 or 业务人员，是极大的<strong>开发利好：</strong></p><ol><li>0 代码创造 Agent 应用，仅靠“写文档”的方式，人人能做出可解决问题的垂直 Agent</li><li>无需过度关注 Agent 工程技术细节，凭借通用 Agent 智能，Skill Agent 能够自适应 Skill 设计中所缺失的代码、功能逻辑，甚至是自行在运行中克服 bug（虽有性能影响）。做 Demo、MVP、甚至小 Agent 应用，验证产品价值就非常容易</li><li>而且搓出来的垂直 Agent，兼具通用 AI 智能，有极其灵活的边界问题与个性化处理能力，智能上限极高。</li></ol><p style="margin-left: 0px;">那么，我们该如何开始使用 or 制作第一个 Skill？</p><h3><strong>1️⃣ 教程：我该如何使用 Skills？（Claude Code 版）</strong></h3><p style="margin-left: 0px;">如果你已经会了，可跳过此部分；</p><p style="margin-left: 0px;">也可以把这大概率是全网最详细的 Skills 教程，转给初学的小伙伴们</p><p style="margin-left: 0px;">使用 Skills 的方式很多，我先推荐一种自己用最多的本地方法，Claude Code（简称 CC）。</p><blockquote><p style="margin-left: 0px;">注意：只是使用工具，Claude 模型并非必需</p><p style="margin-left: 0px;">BTW：codex、cursor 等工具也逐步在支持 skill 的使用，有兴趣可以自行探索。</p></blockquote><p style="margin-left: 0px;">开个玩笑：</p><p style="margin-left: 0px;">Claude Code 是 Anthropic 推出的 coding 工具 ❌</p><p style="margin-left: 0px;">Claude Code 是 Anthropic 自己都没想到的通用 Agent 框架 ✅</p><p style="margin-left: 0px;">CC 能做的事情远不止 AI Coding：</p><p style="margin-left: 0px;">它能代替我们操作电脑，包括搜索网页、操作浏览器、访问文件，以及使用电脑底层命令、运行 python 脚本等行为。</p><p style="margin-left: 0px;">&nbsp;</p><p style="margin-left: 0px;">这就意味着 CC + Skills，就等于跑在自己电脑上的垂直 Agent。通过安装或自行创建不同的 Skills，就可以完成：</p><ul><li>搜索网络信息，总结感兴趣的资讯日报；</li><li>自动化翻阅项目文件夹，输出项目复盘文档；</li><li>以及其他不同的 Agent 任务。</li></ul><p style="margin-left: 0px;">使用方法其实并不复杂，只是需要一些耐心：</p><hr /><h4><strong>Step 1：安装 Claude Code</strong></h4><p style="margin-left: 0px;">如果从未安装过 Claude Code，请打开「终端/命令行」工具：</p><ul><li>遵循官方安装指引 <a href="https://code.claude.com/docs/en/quickstart#native-install-recommended">https://code.claude.com/docs/en/quickstart#native-install-recommended</a> ，完成 Claude Code 安装。</li><li>推荐直接把官方指引链接，按以下 Prompt 发给任意 AI（ChatGPT、Kimi 都行），让它一步步教你。</li></ul><p style="margin-left: 0px;"><code>我是电脑小白，参考以下信息，一步步指导我在【Mac/windows/linux】终端中安装该程序：【此处粘贴替换为官方安装指引文本】 当我遇到疑惑或报错时，我会把终端的日志发给你，请帮我解决。</code></p><p style="margin-left: 0px;">AI 就会这样教你安装：</p><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/7e1fd2cf2b449de21a3ffc8746805aac.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 0px;">遇到问题就截图给它，基本都能教你解决。</p><p style="margin-left: 0px;">&nbsp;</p><p style="margin-left: 0px;">安装后，终端里输入<code>claude --version</code>，看到版本号，则这一步安装成功。</p><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/df8d49570b11788169871503c83b11d9.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><hr /><h4><strong>Step 2：如果不用 Claude 模型，请替换模型</strong></h4><p style="margin-left: 0px;">现在大部分国产模型都已经支持了 Skill 的使用与创建。</p><p style="margin-left: 0px;">❶ 你可以用「模型名称 + Claude Code」的关键词去网上搜索模型厂商官方的 Claude Code 模型接入教程。</p><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/6828986a91ab4273e416cf3aaae02f77.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/3d17f70122ad9be0a443760b9b020739.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 0px;">目前比较推荐的是 GLM 4.7、Kimi K2-thinking 或新版本。</p><p style="margin-left: 0px;">发送以下 Prompt 给 AI 对话，就能得到详细的人话指导了：</p><pre class="language-Plain"><code>我是电脑小白，指导我根据【替换为教程链接】，并替换 claude code 内的模型。Claude Code 已经装好了</code></pre><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/555dcedbb35f57460c3f8a01732e0de6.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 0px;">❷ 另外，也有一些好用的 Claude Code 模型管理工具，比如「CC Swtich」，项目地址为 <a href="https://github.com/farion1231/cc-switch">https://github.com/farion1231/cc-switch</a></p><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/1483f781948f13fd13ebb16cbb7dcbe4.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 0px;">同样打开 AI，发送以下 Prompt，就能学会如何使用：</p><pre class="language-Plain"><code>我是电脑小白，指导我如何安装【项目地址】，并替换 claude code 内的模型，我要用的是【模型名称】</code></pre><hr /><h4><strong>Step 3：安装并使用 Skills</strong></h4><blockquote><p style="margin-left: 0px;">正式使用 Claude Code 之前，建议在任意目录下<strong>创建一个空文件夹</strong>，比如叫 <code>test</code>，再在终端内切换到对应文件目录：</p><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/4b30c691b581af268fde4cf873a136c0.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 0px;">然后在终端输入<code>claude</code>，就可以启动 CC 了，看到下图就是启动成功了</p><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/96e5c910a13e0890116c735b55d3ed05.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 0px;">这一步能把 Claude Code 的后续 AI 行为，都局限在该目录，减小对本地电脑其他文件的影响。</p></blockquote><p style="margin-left: 0px;">❶ 在安装 Skill 之前，你需要先获取需要的 Skill 文件包。</p><p style="margin-left: 0px;">比如官方 Skills 仓库：<a href="https://github.com/anthropics/skills/tree/main">https://github.com/anthropics/skills/tree/main</a>，里面就有很多已经做好的 Skills。</p><p style="margin-left: 0px;">&nbsp;</p><p style="margin-left: 0px;">你可以让 CC 替你自动安装 Skill，比如在 CC 中发送 <code>安装 skill，skill 项目地址为：&lt;skill 项目地址&gt;</code></p><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/ff0c9e675aa97ea698908d80b5b5e6ae.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 0px;">&nbsp;</p><p style="margin-left: 0px;">❷ 也可以手动下载 Skill，把文件包解压后，放在 skills 安装目录下：</p><p style="margin-left: 0px;">可以在当前项目文件夹的<code>/.claude/skills/</code>目录下，放入要安装的 skill 文件包：（如图为正确的项目 skills 路径配置）</p><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/3394da690a70336679c3193928c151ea.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 0px;">也可以选择全局目录<code>～/.claude/skills/</code>（所有项目都能共享放在全局目录的 Skill）</p><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/04b80e2871cba71115e665279f4f6cf4.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 0px;">❸ 完成安装后，记得重启 CC 👉 退出终端再打开就行，或者双击 ctrl+c 终止 CC 进程）</p><p style="margin-left: 0px;">&nbsp;</p><p style="margin-left: 0px;">⬇️</p><p style="margin-left: 0px;"><strong>要使用 Skill 时，</strong></p><p style="margin-left: 0px;">只要在装好后的 CC 中，发送<code>开始使用&lt;skill 名称&gt;</code>，</p><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/90449e2645e1e484e9c8880dc633a999.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 0px;">或者用户消息与 skill 元数据的描述匹配，</p><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/7ea13eaf68ed5b912d868c131ad0282a.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 0px;">就能自动调用 Skills，执行任务。</p><p style="margin-left: 0px;">之前实验 AI-Partner Skills 分享过的 step by step 教程，能进一步体验复杂 Skill 的智能上限。非常细致，值得参考：<a href="https://mp.weixin.qq.com/s/74XfeY-QuPLJ582izR2JKw">《只用 Claude Skills，打造专属 AI 伴侣</a>》</p><hr /><h3><strong>👉 怎么找到好用的 Skills 呢？</strong></h3><p style="margin-left: 0px;">你应该也看出来了，在面向 to C 用户（也就是自己日常使用）时，以上的方法有两个问题：</p><ul><li>使用步骤确实比日常的 APP 复杂不少</li><li>比较难找到想用的 Skills</li></ul><p style="margin-left: 0px;">常规方法是找规模比较大的第三方 Skills 市场：<a href="https://skillsmp.com/zh">https://skillsmp.com/zh</a></p><p style="margin-left: 0px;">但不难发现，现有大部分的 Skills 公开市场，没有完善的评价和精选体系，所有 Skill 缺少合理的分类与排序机制，导致很难找到需要的 Skills。</p><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/25aed211fd00f3a1d6e7123c15ddec16.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><hr /><h3><strong>2️⃣ 如何制作一个 Skill？</strong></h3><p style="margin-left: 0px;">好，话说回来。</p><p style="margin-left: 0px;">如果你按照上文，学会了 Skill 安装与使用，那制作第一个 Skill 将会无比容易。</p><p style="margin-left: 0px;">我们需要用到 Anthropic 官方的一个 skill：<strong>skill-creator</strong></p><p style="margin-left: 0px;">顾名思义，用来帮你自动开发 Skill 的 Skill（我的 AI-Partner 和 Article-Copilot Skills 也都借助了这个 skill，大幅提升开发 skill 的效率）</p><p style="margin-left: 0px;">❶ 首先是<strong>安装 skill-creator</strong>，skill 项目地址在：<a href="https://github.com/anthropics/skills/tree/main/skills/skill-creator">https://github.com/anthropics/skills/tree/main/skills/skill-creator</a>，安装过程一如上面的教程，请 CC 来帮忙自动安装：</p><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/7a38eb360fdf735efe84ce60bf9349d3.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 0px;">&nbsp;</p><p style="margin-left: 0px;">❷ 安装完成后，即可<strong>调用 skill-creator 自动创建需要的 skill</strong>。</p><p style="margin-left: 0px;">比如，发送创建需求给 CC：</p><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/bc38a4dc2c3309c2a196ea0917f4d09c.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 0px;">CC 自动调用 skill-creator，编写 SKILL.md 与 pdf2word 脚本</p><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/aab6ef592656660d7daa8771b7e364a8.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 0px;">最终提示创建成功：</p><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/9b6d3104f650cff02c6c8842ec05a9b2.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 0px;">你也可以试着：</p><p style="margin-left: 0px;">“创建 skill，能按照我写文章的行文风格写文章”</p><p style="margin-left: 0px;">“创建 skill，能自动整理近期 XX 领域的新闻日报”……</p><hr /><p style="margin-left: 0px;"><strong>👉 如何安装自己做好 skill ？</strong></p><p style="margin-left: 0px;">这种方式做出来的 skill，会默认是<code>xx.skill</code>格式，会与 zip 或文件夹格式略有区别。是 skill-creator 创建的 skill 压缩格式。</p><p style="margin-left: 0px;">告诉 CC 指定 <code>.skill</code> 的文件地址，要求 cc 直接安装 skill 即可：</p><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/f0469465b19ac35118e54deb43f55e66.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 0px;">如果是文件夹或者 zip，那就按上文的介绍，手动解压放到对应 skills 目录即可。</p><p style="margin-left: 0px;"><strong>👉 【进阶】如果你需要精调 skill，或者想完全手写一个 skill？</strong></p><p style="margin-left: 0px;">更细节的 Skill 规格设计说明，请参考：<a href="https://agentskills.io/specification#skill-md-format">https://agentskills.io/specification#skill-md-format</a></p><h2><strong>三、什么时候应该用 Skills？</strong></h2><p style="margin-left: 0px;">概念、价值、教程，都讲完了，但更重要的问题是：</p><p style="margin-left: 0px;"><strong>什么场景值得“用 Skill 来解决”、“开发一个 Skill”？</strong></p><p style="margin-left: 0px;">这个问题对于<strong>普通用户优化 AI 工作流程，开发者找 Skills Agent 创业机会</strong>，同样重要。</p><p style="margin-left: 0px;">根据 Anthropic 官方博客建议，与我的实际理解，梳理了 3 种明显的时机：</p><hr /><h3><strong>1️⃣ 发现自己在向 AI 反复解释同一件事</strong></h3><p style="margin-left: 0px;">最典型的信号是：为了完成某个任务，在多轮对话中，需要不断向 AI 解释一件事应该怎么做。</p><p style="margin-left: 0px;">比如：</p><blockquote><p style="margin-left: 0px;">“帮我写一份技术文档”</p><p style="margin-left: 0px;">“不对，我们公司的技术文档格式是这样的……”</p><p style="margin-left: 0px;">“还有，代码示例要按这个模板来……”</p><p style="margin-left: 0px;">“上次不是说了吗，章节标题要三级标题……”</p></blockquote><blockquote><p style="margin-left: 0px;">“帮我分析这个数据”</p><p style="margin-left: 0px;">“先把 ＞ XX 的异常值筛掉”</p><p style="margin-left: 0px;">“不对，应该用中位数，不是平均值”</p><p style="margin-left: 0px;">“图表要按我们公司文档的配色方案……”</p></blockquote><p style="margin-left: 0px;">这时候就该想到：与其每次都解释一遍，不如把这些规则打包成一个 Skill，一次创建永久复用。</p><hr /><h3><strong>2️⃣ 某些任务需要特定知识、模板、材料才能做好</strong></h3><p style="margin-left: 0px;">有时候是 AI 的通用能力够了，但缺“特定场景的知识材料”。</p><p style="margin-left: 0px;">典型场景：</p><ul><li><strong>技术文档写作</strong>：需要参考代码规范、术语表，使用文档模板</li><li><strong>品牌设计</strong>：需要参考品牌手册、色彩规范，使用 Logo 资源</li><li><strong>数据分析</strong>：需要参考指标定义、计算公式，使用报表模板……</li></ul><p style="margin-left: 0px;">这些都是「通用 Agent + 垂直知识」的典型场景：人提供材料，Agent 才能具备场景 Context。</p><p style="margin-left: 0px;">在 Skill 包里放对应的知识材料，比如把模板、规范、案例放到 Skill 的<code>assets/</code>、<code>reference/</code>目录，或者直接描述在<code>SKILL.md</code>中，</p><p style="margin-left: 0px;">Agent 就能一次性输出符合任务需要的精准结果。</p><hr /><h3><strong>3️⃣ 发现一个任务要多个流程协同完成</strong></h3><p style="margin-left: 0px;">有些任务更加复杂，往往需要“组合多个流程”才能完成。</p><ul><li><strong>竞品分析报告</strong>：检索竞品数据 + 数据分析 + 制作 PPT</li><li><strong>内容生产</strong>：收集参考资料 + 学习风格 + 大纲协作 + 正文写作</li></ul><p style="margin-left: 0px;">我相信你的工作环境里也有很多这种任务。</p><p style="margin-left: 0px;">把这类任务中每个环节的指令文档、可执行脚本、参考材料、可用资源打包成单个或多个 Skill 也是不错的 AI 解决方法。</p><p style="margin-left: 0px;">让Agent 根据任务描述，智能调用不同的 Skill 模块，通过“规划-执行-观察”的交错式行动，一次性完成原本需要多个流程协同完成的复杂任务。</p><hr /><h2><strong>🎐 写在最后</strong></h2><p style="margin-left: 0px;">写到这里，回到开头那个判断：<strong>Claude Skills 的价值，还是被大大低估了</strong>。</p><p style="margin-left: 0px;">&nbsp;</p><p style="margin-left: 0px;">Skills 是 Agent 的灵魂，就像 Steam 游戏 + 创意工坊一样。</p><p style="margin-left: 0px;">有了这种可扩展性极强的设计架构，Agent 开发者完全能巧借通用 Agent 内核,</p><p style="margin-left: 0px;"><strong>只需关注 Skills 本身的设计，就能低成本创造兼具通用 AI 智能上限的垂直 Agent 应用</strong>。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/07/f9dd5775f334a4a5ec6c46c680f5e7aa.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 0px;">对于Agent 创业者，乃至非技术的领域专家来说，Skills 无异代表了很多的新机会：</p><p style="margin-left: 0px;">垂直 Agent 工具，如果按传统方式开发 —— 从需求分析、技术选型、开发测试，到部署上线 —— 周期至少数周。</p><p style="margin-left: 0px;">但用 Skill 的方式，几小时甚至几分钟就能测试起来，且智力与能力上限也有机会直逼通用 Agent。</p><p style="margin-left: 0px;">⬇️</p><p style="margin-left: 0px;">这不是说 Agent Skill 必然全面替代传统开发。</p><p style="margin-left: 0px;">两种方式各有适用场景，但 <strong>Skill 确实让更多人、更多场景接入 Agent 能力变得更为可行</strong>：</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/07/4fa579959650dd82694dd7393ab4779e.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><ul><li>不必为了一个内部小工具开发完整产品，打包个 Skill 就能解决</li><li>不必说服 IT 团队理解你的需求，自己就能创建工具</li><li>不必等待产品迭代，你可以随时调整 Skill 的行为</li></ul><p style="margin-left: 0px;">&nbsp;</p><p style="margin-left: 0px;">从这个角度看，Skill 更是<strong>降低了验证想法的成本。</strong></p><p style="margin-left: 0px;">另外再换一个思路：<strong>把 Skill Agent 服务打包为 AI API，是不是也能快速给已有的产品赋上好用的 AI 能力？</strong></p><p style="margin-left: 0px;">&nbsp;</p><p style="margin-left: 0px;">现在还是 Skill 生态的早期，Agent Skills 开放标准发布不到 1 个月，工具在完善，社区在成长。</p><p style="margin-left: 0px;">但这个方向有意思的地方在于：<strong>它终于能让更多人、组织、行业参与 AI 应用的创造了</strong>。</p><figure class="image ss-img-wrapper"><img alt="img" src="https://cdnfile.sspai.com/2026/01/07/article/be431b540ffb35ddf959cf3778be516e.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p><strong>Ref.</strong></p><ul><li>Claude Doc - Agent Skills 说明：<a href="https://platform.claude.com/docs/en/agents-and-tools/agent-skills/overview">https://platform.claude.com/docs/en/agents-and-tools/agent-skills/overview</a></li><li>Agent Skills 开放标准：<a href="https://agentskills.io/home">https://agentskills.io/home</a></li><li>Equipping agents for the real world with Agent Skills：<a href="https://www.anthropic.com/engineering/equipping-agents-for-the-real-world-with-agent-skills">https://www.anthropic.com/engineering/equipping-agents-for-the-real-world-with-agent-skills</a></li></ul>
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://sspai.com/post/105284</id>
            <title>Claude Skills 入门：一篇文章搞懂 AI 怎么从「嘴替」升级成「打工人」</title>
            <link>https://sspai.com/post/105284</link>
            <guid isPermaLink="false">https://sspai.com/post/105284</guid>
            <pubDate></pubDate>
            <updated>Fri, 09 Jan 2026 01:30:44 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p style="margin-left: 0px;">&nbsp;</p><figure class="image ss-img-wrapper"><img alt="" src="https://cdnfile.sspai.com/2026/01/09/article/0fc45892a4a6261fe89e1b966a28fdfb.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 8px;">你有没有这种感觉 ——AI 领域的新名词，比手机型号更新还快？</p><p style="margin-left: 8px;">昨天刚搞懂「函数调用」(Function Calling) 是怎么回事，今天又冒出来个「Skills」。前天有人跟你说「MCP」，你还没反应过来，后天又有人聊「Agent」。每次看到这些词，第一反应都是：我是不是又落伍了？</p><p style="margin-left: 8px;">别慌。今天咱们把「Claude Skills」这事儿掰开揉碎了讲清楚。</p><p style="margin-left: 8px;">更重要的是，我会告诉你它跟你已经知道的那些概念 —— 函数、函数调用 —— 到底是什么关系。你会发现，这不是三个孤立的新词，而是一层一层往上搭的台阶。搞懂这三层，以后再出什么新词，你也能自己判断它在哪一层。</p><h2 style="margin-left: auto; text-align: center;"><strong>起点</strong></h2><p style="margin-left: 8px;">咱们从最熟悉的东西开始：编程里的「函数」。</p><p style="margin-left: 8px;">你可以把函数理解成一个「小助手」。你告诉它要做什么（给它一个输入），它帮你做完后告诉你结果（给你一个输出）。就像餐厅里的服务员：你点菜，他端菜，每次都按照固定流程来。</p><p style="margin-left: 8px;">举个例子，程序员写一个叫 <code>calculate_tax (income)</code> 的函数。你把收入数字扔进去，它把该交多少税算出来还给你。下次还要算？再调用一遍就行。不用每次都重写一遍算税的逻辑。</p><p style="margin-left: 8px;">函数的价值，说白了就三个字：<strong>封装、重用、标准化</strong>。</p><p style="margin-left: 8px;">把一件事情的做法「打包」起来，以后谁都能用，每次用的方式都一样。这是程序员几十年来最基本的生产力工具。</p><figure class="image ss-img-wrapper"><img alt="" src="https://cdnfile.sspai.com/2026/01/09/article/03c44f3ee107120c848037b9be7f7399.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 8px;">但函数有个局限 —— 它只活在代码世界里。</p><p style="margin-left: 8px;">程序员在代码里写 <code>getWeather()</code>，这个函数 100% 会被执行。可是普通人不会写代码，AI 也不会直接「运行」这些代码。那怎么让 AI 也能用上这些「小助手」呢？</p><h2 style="margin-left: auto; text-align: center;"><strong>架桥</strong></h2><p style="margin-left: 8px;">2023 年前后，一个叫「函数调用」（Function Calling）的概念火了起来。</p><p style="margin-left: 8px;">你可以把它理解成：给那个「只会聊天的 AI」配了一部电话和一本通讯录。</p><p style="margin-left: 8px;">以前的 AI，你问它「今天北京天气怎么样」，它要么从训练数据里瞎猜一个，要么老老实实说「我不知道」。因为它没有「手脚」，不能真的去查天气。</p><p style="margin-left: 8px;">有了函数调用之后，情况变了。</p><p style="margin-left: 8px;">开发者事先告诉 AI：「这是一本通讯录，里面有个叫 <code>get_weather</code> 的函数，你想查天气就打这个电话。」AI 收到「今天北京天气怎么样」的问题后，它会自己判断：「哦，这个问题我得打电话给 <code>get_weather</code> 才能回答。」</p><p style="margin-left: 8px;">然后它生成一段标准格式的「便签」（叫 JSON），上面写着：</p><pre class="language-javascript"><code>{
&nbsp;&nbsp;"function":&nbsp;"get_weather",
&nbsp;&nbsp;"arguments":&nbsp;{
"city":&nbsp;"北京"
&nbsp;&nbsp;}
}</code></pre><p style="margin-left: 8px;">这段便签被外部程序接收、解析、执行。真正打电话给气象台的，是外部程序，不是 AI 自己。执行完后，结果返回给 AI，AI 再用人话告诉你：「北京今天晴，15 度。」</p><p style="margin-left: 8px;"><strong>这里有个关键的转折，初学者容易忽略。</strong></p><p style="margin-left: 8px;">传统函数是「确定性」的——程序员在代码里写了 <code>getWeather()</code>，100% 会执行。</p><p style="margin-left: 8px;">但 LLM 的函数调用是「概率性」的——AI 看到「今天天气怎么样」，它要<strong>自己判断</strong>该不该调用天气函数。这个判断是基于理解，不是基于规则。有小概率它会判断错误，比如把「天气」理解成某个人名。</p><p style="margin-left: 8px;">所以说，函数调用的本质是：<strong>让 AI 能「打电话」，但打不打、打给谁，它自己决定。</strong></p><figure class="image ss-img-wrapper"><img alt="" src="https://cdnfile.sspai.com/2026/01/09/article/197ffdbe1ad0e46cf01f9e3035e00a61.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 8px;">这是一个巨大的进步 ——AI 不再只是「知识库」，它开始变成「行动者」。</p><p style="margin-left: 8px;">但函数调用还有个问题：它是零散的、一次性的。</p><p style="margin-left: 8px;">你给 AI 配了十几个函数，它每次只能选一个打电话。如果一个任务需要连续调用五六个函数、中间还有逻辑判断、还需要参考一些文档，函数调用就不够用了。</p><h2 style="margin-left: auto; text-align: center;"><strong>跃升</strong></h2><p style="margin-left: 8px;">2025 年 10 月 16 日，Anthropic 发布了一个新功能：<a href="https://support.anthropic.com/en/articles/12512176-what-are-skills">Claude Skills</a>。</p><p style="margin-left: 8px;">你可以把 Skills 理解成「员工手册」+「工具箱」的组合。</p><p style="margin-left: 8px;">员工手册告诉 AI：「当你遇到某类任务时，应该怎么做，分几步，每一步用什么工具。」工具箱里装着它需要用的脚本和参考资料。</p><p style="margin-left: 8px;">具体来说，一个 Skill 就是一个文件夹，里面有三样东西：</p><p style="margin-left: 8px;"><strong>第一，SKILL.md 文件</strong>。这是「指令」，用自然语言写的。告诉 AI：这个 Skill 是干什么的，什么情况下该用，怎么用，有什么注意事项。</p><p style="margin-left: 8px;"><strong>第二，脚本</strong>。可以是 Python、JavaScript 或者其他语言写的代码。当 AI 需要「动手」的时候，就执行这些脚本。</p><p style="margin-left: 8px;"><strong>第三，资源文件</strong>。比如参考文档、模板、配置文件。AI 在执行任务的时候可以查阅这些资料。</p><p style="margin-left: 8px;">你可能会问：这跟函数调用有什么本质区别？</p><p style="margin-left: 8px;">区别在于：<strong>函数调用是「单个工具」，Skills 是「整套解决方案」​</strong>。</p><p style="margin-left: 8px;">打个比方。函数调用像是给你一把锤子、一把螺丝刀、一把扳手，你得自己知道什么时候用哪个。Skills 像是给你一本《如何组装宜家书柜》的说明书，说明书里不仅告诉你步骤，还附上了所有需要的工具和零件。</p><p style="margin-left: 8px;">还有一个重要的机制叫「渐进式披露」。</p><p style="margin-left: 8px;">AI 的「工作记忆」是有限的（技术上叫「上下文窗口」）。如果你把所有 Skills 的内容一股脑塞进去，AI 会被信息淹没。</p><p style="margin-left: 8px;">Skills 的做法是：平时只告诉 AI「有这么一本说明书」，AI 真正需要的时候再去翻。就像你不用把整本百科全书背下来，遇到问题再查相关那一页就行。</p><figure class="image ss-img-wrapper"><img alt="" src="https://cdnfile.sspai.com/2026/01/09/article/e517704561a61477561465643ff1980c.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 8px;">现在，咱们把三层放在一起看：</p><figure class="image ss-img-wrapper"><img alt="" src="https://cdnfile.sspai.com/2026/01/09/article/cf40382b2b3ad1457264f4bb554b3aaf.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 8px;">从下往上看，抽象层次越来越高。函数是代码级的，函数调用是接口级的，Skills 是工作流级的。</p><p style="margin-left: 8px;"><strong>Skills 可以包含函数调用，但函数调用只是 Skills 的一部分。</strong></p><p style="margin-left: 8px;">就像一本菜谱不只是「切菜」「炒菜」「装盘」这几个动作的罗列，它还包括「为什么要这样做」「火候怎么掌握」「如果烧焦了怎么补救」这些知识。</p><h2 style="margin-left: auto; text-align: center;"><strong>实战</strong></h2><p style="margin-left: 8px;">说了这么多概念，Skills 到底能干什么？咱们看几个真实案例。</p><p style="margin-left: 8px;"><strong>先说一个我自己的项目：</strong><a href="https://github.com/wshuyi/x-article-publisher-skill"><strong>x-article-publisher-skill</strong></a><strong>。</strong></p><figure class="image ss-img-wrapper"><img alt="" src="https://cdnfile.sspai.com/2026/01/09/article/9f37443214bc71ba8e1f6d21119b3b3a.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 8px;">如果你用 Markdown 写文章，然后想发布到 X（Twitter）的 Articles 功能里，你会遇到一个极其崩溃的问题：复制粘贴过去，格式全丢了。</p><p style="margin-left: 8px;">标题变普通文字，粗体变普通文字，链接变普通文字。你得手动一个一个加回来。一篇文章，光是调格式就要花 15-20 分钟。</p><p style="margin-left: 8px;">更要命的是图片。你得手动上传每一张，然后把它拖到正确的位置。如果文章有十几张图，你很容易搞错顺序。</p><p style="margin-left: 8px;">这个 Skill 怎么解决的呢？</p><p style="margin-left: 8px;">它会先解析你的 Markdown 文件，提取标题、封面图，并且给每张内容图片计算一个「块索引」（block_index）—— 就是这张图应该出现在文章的第几个段落之后。</p><p style="margin-left: 8px;">然后，它把 Markdown 转成富文本 HTML，通过剪贴板粘贴到 X 编辑器里。格式完美保留。</p><p style="margin-left: 8px;">最后，它用浏览器自动化（Playwright）把每张图片精准插入到正确的位置。</p><p style="margin-left: 8px;">原本 20-30 分钟的手动操作，现在几分钟内<strong>全自动搞定</strong>。减少时长自不必说。<strong>对懒人而言，能全程不用自己再动手，才是最主要的嘛。</strong></p><p style="margin-left: 8px;">你可能会说：这不就是写了个自动化脚本吗？</p><p style="margin-left: 8px;">是，也不是。</p><p style="margin-left: 8px;">单纯的自动化脚本，你得自己记住什么时候用、怎么用、参数怎么填。但 Skill 把「什么时候用」「怎么用」都写进了指令里。你只需要跟 AI 说一句「把这篇文章发到 X」，它就知道该调用这个 Skill，该怎么操作。</p><p style="margin-left: 8px;"><strong>这就是「知识编码」的价值——把「我知道怎么做」变成「AI 也知道怎么做」。</strong></p><p style="margin-left: 8px;">再看几个企业场景。</p><p style="margin-left: 8px;"><strong>会议管理</strong>：有个 Skill 能自动从会议记录里提取摘要、决策和行动项，然后起草跟进邮件。开完会不用再花半小时整理笔记。</p><p style="margin-left: 8px;"><strong>数据分析</strong>：扔给它一个 CSV 文件，它能自动识别关键指标、找出异常值，生成图文并茂的报告。非技术人员也能快速从数据里挖出洞察。</p><p style="margin-left: 8px;"><strong>客户支持</strong>：它从公司知识库里检索准确答案，再用人性化的语言组织成回复。既保证准确，又不失温度。</p><p style="margin-left: 8px;">这些场景有个共同点：<strong>都是重复性高、步骤固定、但又需要一定判断力的任务</strong>。以前，要么靠人硬扛，要么花大价钱开发专门的软件。现在，一个 Skill 就能搞定。</p><p style="margin-left: 8px;"><strong>最后说说开发者工具。</strong></p><p style="margin-left: 8px;">有个叫 <code>skill-creator</code> 的 Skill，特别有意思 —— 它是用来创建 Skill 的 Skill。</p><figure class="image ss-img-wrapper"><img alt="" src="https://cdnfile.sspai.com/2026/01/09/article/bbfa2613ba60ee32084b241d9fb2d166.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 8px;">你跟它聊天，告诉它你想实现什么工作流，它会帮你生成一个完整的 Skill 项目框架。这就是所谓的「元技能」。</p><p style="margin-left: 8px;">还有 <code>webapp-testing</code>，能根据测试用例自动操作浏览器，对 Web 应用进行功能测试，然后生成测试报告。前端测试流程部分自动化了。</p><h2 style="margin-left: auto; text-align: center;"><strong>动手</strong></h2><p style="margin-left: 8px;">说了这么多，怎么开始用 Skills？</p><p style="margin-left: 8px;"><strong>如果你想用现成的 Skills</strong>，最简单的方式是通过 Claude Code 的插件市场。</p><p style="margin-left: 8px;">默认初始自动安装的只是 Claude 官方的插件市场。</p><figure class="image ss-img-wrapper"><img alt="" src="https://cdnfile.sspai.com/2026/01/09/article/b2867513cdd934131010227dbdd90a64.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 8px;">你也可以根据自己的需求，添加其他插件市场。格式例如：</p><pre class="language-hljs code__pre"><code>
    

    

    

  
/plugin&nbsp;marketplace&nbsp;add&nbsp;anthropics/claude-code</code></pre><figure class="image ss-img-wrapper"><img alt="" src="https://cdnfile.sspai.com/2026/01/09/article/afb305b8ba543fb00fdd0c45ad60c51a.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 8px;">安装之后，你这里就有两个插件市场了。</p><figure class="image ss-img-wrapper"><img alt="" src="https://cdnfile.sspai.com/2026/01/09/article/856f2ebb56e371a6849f218279e09ab2.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 8px;">你看到了，利用 <code>/plugin</code> 命令，可以添加、管理插件。</p><p style="margin-left: 8px;">这是我目前已经安装的部分插件。</p><figure class="image ss-img-wrapper"><img alt="" src="https://cdnfile.sspai.com/2026/01/09/article/8ae868d115990d44de70c0c95affa56b.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 8px;">装完之后，你可以让 Claude 用某个 Skill 来完成任务。比如：「用 PDF Skill 提取这份文件里的表格数据。」</p><p style="margin-left: 8px;"><strong>如果你想自己创建 Skills</strong>，可以用 <code>skill-creator</code> 这个元技能。跟它对话，描述你的工作流，它会帮你生成框架。</p><p style="margin-left: 8px;">你可以编写 Claude Skill，让它帮助你去分析材料、自动调研，并且绘制出对应的结构图。</p><p style="margin-left: 8px;">例如这是红楼梦人物关系图。</p><figure class="image ss-img-wrapper"><img alt="" src="https://cdnfile.sspai.com/2026/01/09/article/528e623676002edaa7a2b5a98cd298e1.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 8px;">下面是战国七雄的互动。</p><figure class="image ss-img-wrapper"><img alt="" src="https://cdnfile.sspai.com/2026/01/09/article/7ced9c4fe1d99bdb56e97e133a65edac.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 8px;">使用方式可以 <a href="https://sspai.com/post/105095">参考我这篇文章</a>。</p><p style="margin-left: 8px;">更高级的玩法是用 Claude Skills 连接一些非常好的外部工具，例如 NotebookLM 作为知识库使用。这样你就可以把 NotebookLM 强大的检索和知识验证功能，与你自己的创意以及其他模型工具的特点有机地结合在一起。</p><figure class="image ss-img-wrapper"><img alt="" src="https://cdnfile.sspai.com/2026/01/09/article/eeaf3f2b10b93fac2699e13bf33e0bea.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 8px;">我在 <a href="https://mp.weixin.qq.com/s/lrAeILr8qAJjrMXmnK339g">这篇文章当中有详细的介绍。</a></p><p style="margin-left: 8px;">想看看别人做了什么 Skills？去 GitHub 搜 <a href="https://github.com/travisvn/awesome-claude-skills">awesome-claude-skills</a>，那里有社区整理的优秀 Skill 清单。</p><figure class="image ss-img-wrapper"><img alt="" src="https://cdnfile.sspai.com/2026/01/09/article/956eeabeaf7549d8056ebbee04848775.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 8px;">我个人比较推荐的是活水智能（也就是阳志平老师团队）做的 <a href="https://42plugin.com/">插件市场 42plugin</a> 。</p><figure class="image ss-img-wrapper"><img alt="" src="https://cdnfile.sspai.com/2026/01/09/article/675db2a80669b6906abdf9c393dc8259.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 8px;">这里不仅整理了很多的插件，而且还有相应的评级评分，更可以保证避免踩坑。</p><figure class="image ss-img-wrapper"><img alt="" src="https://cdnfile.sspai.com/2026/01/09/article/f424f1e676d3e7eca7c9d2ad4580d7c8.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 8px;">最重要的一点：<strong>创建 Skill 不一定需要会写代码。</strong></p><p style="margin-left: 8px;">SKILL.md 里的指令是自然语言写的。如果你的工作流不涉及复杂的脚本，光靠自然语言指令就能完成很多事情。</p><p style="margin-left: 8px;">正如 Claire Vo 在 <a href="https://www.lennysnewsletter.com/p/claude-skills-explained">Lenny's Newsletter</a> 里说的：即使是非程序员，也可以通过清晰地定义工作流，创建出强大的、可复用的 AI 工作流。</p><figure class="image ss-img-wrapper"><img alt="" src="https://cdnfile.sspai.com/2026/01/09/article/53ed42d2320ea64c6e06f4128a8e5948.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><h2 style="margin-left: auto; text-align: center;"><strong>小结</strong></h2><p style="margin-left: 8px;">现在咱们回头看这三层台阶：</p><ul><li>• <strong>编程函数</strong>是基石。它提供了最基础、最可靠的逻辑执行单元。</li><li>• <strong>LLM 函数调用</strong>是桥梁。它让 AI 不再只是「知识库」，而是能「打电话」驱动外部世界的行动者。</li><li>• <strong>Claude Skills</strong>是蓝图。它把零散的工具和指令整合成完整的工作流，让 AI 能更可靠、更专业地完成复杂任务。<br />这三层会越来越融合。开发者继续写高效的函数作为底层工具；通过函数调用把工具暴露给 AI；再用 Skills 指导 AI 怎么智能地使用这些工具。</li></ul><p style="margin-left: 8px;"><strong>真正的力量在于：它让「领域专家」也能「教」AI。</strong></p><p style="margin-left: 8px;">你不需要是程序员，只需要清楚自己的工作流程是什么，就能把这些知识打包成一个 Skill。你的专业知识不再只存在于你脑子里，它变成了 AI 可以调用的能力。</p><p style="margin-left: 8px;">对了，就在我写这篇文章的时候（2026 年 1 月 8 日），Claude Code 又发布了一次重大更新。Skills 现在支持隔离上下文、热重载、指定模型、在子代理中使用……<a href="https://code.claude.com/docs/en/discover-plugins">Plugin Marketplace</a> 也正式上线了。</p><figure class="image ss-img-wrapper"><img alt="" src="https://cdnfile.sspai.com/2026/01/09/article/f7c3ea31f512b5022110b1e291e499e0.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 8px;">Anthropic 还把 Agent Skills 规范作为 <a href="https://aibusiness.com/foundation-models/anthropic-launches-skills-open-standard-claude">开放标准</a> 发布 —— 这跟他们之前推 MCP（Model Context Protocol）的路数一样，都是走开放生态路线。</p><p style="margin-left: 8px;">Gartner 的分析师说，这标志着 AI 市场的焦点正在从「模型更新」转向「用例落地」。</p><p style="margin-left: 8px;">翻译成人话就是：大家不再只比谁的模型更聪明，而是开始比谁能把 AI 用得更好。</p><p style="margin-left: 8px;">Skills 是这场转变的核心载体。它让 AI 从「应答者」变成了「协作者」。</p><p style="margin-left: 8px;">下次再有人跟你说什么关于 Agent 功能的新词，你就问自己：它是在哪一层？是代码级的工具，是接口级的桥梁，还是工作流级的蓝图？</p><p style="margin-left: 8px;">想清楚这个，新词就不再可怕了。</p><p style="margin-left: 8px;">你有没有尝试过 Claude Skills？有没有自己制作符合你自己工作流的 Claude Skill？</p><p style="margin-left: 8px;">欢迎分享在留言区，咱们一起交流讨论。</p><p style="margin-left: 8px;">如果你觉得本文有用，请<strong>充电</strong>。</p><p style="margin-left: 8px;">如果本文可能对你的朋友有帮助，请<strong>转发</strong>给他们。</p><p style="margin-left: 8px;">欢迎<strong>关注</strong><a href="https://sspai.com/column/245">我的专栏「科研利器」</a>，以便及时收到后续的更新内容。</p><p style="margin-left: 8px;"><a href="https://sspai.com/prime/subscription?referral=314606736">点击这个链接加入少数派会员</a>，立享 9 折优惠！获得专属会员内容、会员播客以及会员定制周边。在更多的领域和方向帮你打开脑洞，找到新的兴趣点。与少数派一起洞悉当下，探索新知。</p><h2 style="margin-left: auto; text-align: center;"><strong>延伸阅读</strong></h2><ul><li>• <a href="https://mp.weixin.qq.com/s/cSysHNhu24H8dUpKk9XxQg">品味还是技能？ChatGPT 引发的能力培养变革</a></li><li>• <a href="https://sspai.com/post/94582">AI 时代的真稀缺技能：从「有技术」到「会洞察」</a></li><li>• <a href="https://sspai.com/post/105095">如何用 Claude Skill 帮你一句话做深度调研并自动画图？</a></li><li>• <a href="https://sspai.com/post/98083">从枯燥理论到生动实践：AI 智能代理如何用交互式教程讲解复杂概念</a></li><li>• <a href="https://sspai.com/post/96868">新学期，给你自己配一个好用的 AI 助手吧。会思考，能联网，还有知识库那种</a></li></ul><p style="margin-left: 0px;">&nbsp;</p>
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://sspai.com/post/105218</id>
            <title>生产力祛魅 2026：构建一个“本地、稳定、可迁移”的数字堡垒</title>
            <link>https://sspai.com/post/105218</link>
            <guid isPermaLink="false">https://sspai.com/post/105218</guid>
            <pubDate></pubDate>
            <updated>Fri, 09 Jan 2026 01:08:46 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>时光回溯至2023年，当时我开启了《生产力祛魅》系列的创作。那是一个效率工具大爆发的年代，如Notion等各种时兴工具开始崭露头角，SaaS（软件即服务）模式成为了市场主流。那个系列受到了许多朋友的关注，我们相互交流、探讨，受益颇多。</p><p>转眼来到2026年，时隔差不多3年时间。我回看在《生产力祛魅》中提出的论断，发现它们不仅没有过时，反而愈来愈重要。</p><p>在目前这个AI「横行」的年代，一套能够持续运行、真正服务于人的生产力工作流，必须要死守这三个严苛的条件：</p><p>本地化（Local-First）： 数据必须物理地存在于我的硬盘上。任何必须联网才能打开、必须登录才能查看数据的工具，都不能作为核心生产力工具，只能作为临时管道。</p><p>稳定性（Stability）： 绝对不将云软件作为主要工具，工具应当像锤子和扳手一样，十年如一日地保持其功能预期。</p><p>可迁移性（Transferability）： 数据必须是通用的格式（Markdown、PDF、纯文本等）。</p><p>虽然核心论据未变，但随着技术的迭代（尤其是 Docker 容器化技术的普及和本地 AI 模型的轻量化），我所利用的软件还是有所变化。</p><p>因此，我想借这篇文章，以一个在读硕士研究生 / 文字工作者的视角，剥离掉协作功能（如 n8n 自动化流、团队协作 IDE 等），单纯地谈谈：一个人，一台电脑，如何构建一个不依赖外界、坚不可摧的「数字作坊」。从某种角度来说，我的「本地工作流」更像是一个纯粹的个人文字工作者如何安排、布置自己的「全天工作」。</p><p><strong>## 一 办公工作流</strong></p><p>在我的数字版图中，「办公」并非指在公司上班，而是指维持我个人数字生活正常运转的基础设施，这包括了网页浏览、数据存储、云盘软件等。虽然我的软件不少，但大多数都不会打开。真正作为「入口」和「中枢」的，依然是那些具有强大的「集聚」效应的工具。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/07/733a09929c0ee13e3c1e98c8889121f9.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>图1：办公 / 日常 / 云盘软件（1）</figcaption></figure><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/07/d5a4d9be6f5eb283f55f99c2e2fed60e.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>图2：办公 / 日常 / 云盘软件（2）</figcaption></figure><p>在图1和图2中展示的众多软件里，Devonthink是绝对的核心。它是一个本地文件管理器，Devonthink原本支持OCR，我可以将各种文件放进去，尤其是在处理大量非结构化数据（如古籍扫描件、学术论文PDF、网页存档）时，它会将其OCR，我可以搜索所有文件及其文本。这种无需联网的本地化智能，保障了研究的隐私性与连贯性。See Also、Graph等功能则为文件、文本之间的联系进行了更为直观地展示。</p><p>我的浏览器软件很多，但是主力是Arc浏览器，Chrome、Edge、Safari等主要是以备不时之需。Arc浏览器的工作区（Spaces）功能，让我感觉很舒服。我可以建立学术、日常、娱乐等不同的工作区，让我能够更加专注于特定事物。</p><p>我原来的主力是Chrome，因为其中有许多书签，我一直没有找到很好的替代品。Arc并不太能够支持大量书签的处理，这使我陷入了进退维谷的境地。后来我发现OneNav（https://github.com/helloxz/onenav）项目，通过用Docker搭建OneNav，然后将所有书签都导入进去，构建了一个独立的、标准化的导航索引库，将书签数据从浏览器端剥离。不论我使用何种浏览器，都可以应用这套导航索引库。分门别类，十分方便。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/07/7b2000b42ae52e063b10c4ff1330af4d.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>图3：OneNav 展示（1）</figcaption></figure><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/07/feccb3dacebd56f7fb09875955d09032.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>图4：OneNav 展示（2）</figcaption></figure><p>如图所示，虽然我有很多邮箱软件，但是我日常只用Thunderbird。</p><p>Thunderbird的优势在于对POP3、IMAP、SMTP等各种标准协议的遵循，以及丰富且透明的插件生态，其中有许多好用的插件（例如邮件流）。我将分散于Google、Microsoft Outlook、腾讯、网易等服务商的邮件都汇聚在Thunderbird，其本地数据库能够永久保存我的通讯记录。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/07/4995bfa6d4f82e7a5b21f13613b4af65.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>图5：Thunderbird 展示</figcaption></figure><p>至于Microsoft Office 365、云盘等软件，在此不过多赘述。值得分享的是OmniFocus，其实有许多朋友都分享、介绍过这款软件。在我看来，我不会用很花里胡哨的方式去使用它。我将它视作加强版本的日历软件，例如如图所示的「每周计划」、「专业活动」等。「每周计划」是我每周要提醒自己做的事情，每天早上起来略览一遍，便清楚一周的计划。「专业活动」则是与学术会议等学术活动有关系，例如我何时投稿了某个学术会议，包括其后续情况等。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/07/3b8b9c95d38cfb78db6f26cfd38b993f.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>图6：OmniFocus 展示</figcaption></figure><p><strong>## 二 信息工作流</strong></p><p>第二个工作流是信息工作流。过去的一年，我经常推荐Follow（Folo）这款软件，认为它是目前最适合RSS阅读的软件。但是在2025年10月左右，Folo开始收费。</p><p>其实我很理解软件收费，也愿意付费，然而Folo较为高昂的订阅制收费确实令我望而却步。结合Folo那时候的更新并不符合我的审美取向，对原来签到虚拟币的弃置等诸多原因，我还是放弃使用Folo，转而继续使用Reeder，并且自行搭建Rsshub。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/07/c115fcab51d10523b0053a4c354d59aa.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>图7：Reeder 展示（1）</figcaption></figure><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/07/a9ec0a44d2d2a1125159cad880e079cd.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>图8：Reeder 展示（2）</figcaption></figure><p>从BiLi、Youtube等视频网站，再到电报、豆瓣、X等平台资讯，以及学术方面的CNKI期刊等，搭建Rsshub的Reeder都能够支持。虽然没有AI翻译等功能，但是已经能够满足我的需要。</p><p>除Reeder，我还搭建了newsnow（https://github.com/ourongxing/newsnow）作为重要的新闻资讯来源。newsnow是Github上的开源项目，很方便就可以用Docker进行本地搭建。该软件能够以高密度的文本看板形式呈现全球资讯，很方便我在碎片化时间进行快速浏览，</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/07/b7310565c0890e340969429f74f8c48b.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>图9：</figcaption></figure><p>关于信息的收纳与整理，我个人的见解是：除非必要，否则不用在意，注意断舍离。之前我还经常将所看到的、颇为重要的信息以PDF形式进行保存。随着时间的流逝，我发现这毫无意义。有些朋友认为可以用AI工具辅助信息的收纳与整理，确实如此，但关键处在于要收纳与整理「重要信息」，而非全盘吸收，否则会被大量的信息「摧残」，进而不堪其扰，陷入摆烂状态。对此，其实我个人的观点是：对于重要信息（学业、职业、商业等各种相关），专门建立相应的笔记文件夹，并且要写日记，记录自己的感受感想。以此为基础，可以利用AI大模型等进行处理，建构个人的知识库。除此，其余信息均无记录必要。</p><p><strong>## 三 生产工作流</strong></p><p>之后是涉及到阅读、创作、研究等流程的生产工作流。Anytype这一软件我曾撰写专文进行介绍，它主要用来记录我所投稿的期刊，里面记录着期刊的各种信息，辅助我进行投稿等。不同于传统笔记软件的文档逻辑，Anytype允许用户自定义「对象类型」。例如我创建了「期刊」模板，里面包含影响因子、期刊级别、审稿周期等各种类型。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/07/bfa57d79abf58df7eab513076aad0aa5.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>图10：阅读/创作/研究软件</figcaption></figure><p>以Acrobat为代表的阅读类软件，则是根据场景、用途的差异进行使用。</p><p>Endnote、Scrivener、Tropy是我的三大主力创作工具，构成了我重要的学术知识生产工作流。我所有的写作都是以「项目」作为基准，然后在Devonthink内进行归档。接下来，我将详细介绍这个流程：</p><p>当我想要写作某篇文章时，我会用Scrivener建立一个新项目。Scrivener内置各种形式的模板，并且支持各种形式的资料导入。Scrivener的「活页夹」逻辑允许将长篇文章拆解为独立的文本块，支持非线性的跳跃式写作，对学位论文等长篇文章写作有很好的支持效果。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/07/c0aae36971bdd8679f401a50bde121ce.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>图11：Scrivener 展示（1）</figcaption></figure><p>例如当我利用Endnote导入各种书籍、论文时，我可以直接将Endnote里的相关资料拖入Scrivener建立一个书签。当我想要看相关资料时，直接打开书签预览即可。除此，Scrivener还支持快照（我在本科论文写作时改了20个版本，因此产生了20个文档。通过Scrivener，就不会有这么多文档，对照不同快照也很便利）、批注、引文、参考文献等各种功能。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/07/1f2d49f9e73a5651eb579f9d2f1d17dd.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>图12：Scrivener 展示（2）</figcaption></figure><p>针对学术研究中大量的档案扫描件与图片资料，一般图像软件其实并没有很好的支持，例如元数据标注需求（馆藏号、年代、作者等）。Tropy是一个免费、开源的软件，专门用于组织与处理图像，还支持图文对照录入，极大地提升了图像整理的精确度。我还会将我所利用的重要图像存储于Tropy，当我写作时，通过拖拽等动作，我可以同Scrivener建立与Endnote相同的链接。</p><p>当我完成文章后，我会将它们统一放到Devonthink。每个项目都会内置相应的文件夹：（1）草稿、正文及构思；（2）草稿及正文所配图像；（3）参考资料；（4）投稿发表；（5）见刊文件等。</p><p>在「草稿、正文及构思」文件夹，我会放置我的Scrivener写作文件，及其所导出的Word、Pdf等各种格式文件。在「草稿及正文所配图像」文件夹，我会放置我在正文中利用的图像，这些图像或多或少经过处理。在「参考资料」文件夹，我会将Endnote、Tropy这两个资料包放进去。</p><p>经过这一套流程，我写作的每篇文章都有迹可循，并且所有原始材料都能够完整保存。虽然我主要用这套工作流进行学术创作，但我认为这套工作流能够适配各种各样的写作任务，比较具有普适性。</p><p><strong>## 总结</strong></p><p>综上所述，我认为这套通过剥离非必要的云端协作依赖，坚持以「本地化、稳定性、可迁移性」为核心锚点的工作流，是我反复尝试过后的「当下最优解」。</p><p>无论是用Docker搭建OneNav、RSSHub、newsnow等项目，还是使用Thunderbird、Tropy等开源软件，其目的都在于一个纯粹的目标：在一个AI技术、云服务大肆发展的数字世界中，每个人都有必要开辟出一块完全属于自己的、利于深度思考与知识生产的自治领地。 这便是对生产力祛魅的最深刻实践。</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p>
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://sspai.com/post/105256</id>
            <title>理想首年使用回顾——我先把车停这了</title>
            <link>https://sspai.com/post/105256</link>
            <guid isPermaLink="false">https://sspai.com/post/105256</guid>
            <pubDate></pubDate>
            <updated>Thu, 08 Jan 2026 10:38:28 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>——从购车到使用，再到真实成本的完整回顾</p><p>2024 年 12 月 16 日提车，刚好一个完整周期。<br />这一年里有城市通勤、有高速长途、有夏天、也有北方的冬天。</p><p>今天不聊参数、不做测评，就从一个真实车主的角度，从我的主观感受，回顾这一年的用车体验。</p><hr /><h2>一、购车经历</h2><p>最开始我的购车预算，其实就是 30 万左右。</p><p>当时首选是 Model Y，我本人对科技、辅助驾驶都比较感兴趣。<br />但在实际看车、试车过程中，有两个比较现实的问题。</p><ul><li>我身高在 1.9 米以上，Model Y 不算难受，但空间确实略显局促。</li><li>选择 Model Y，再加上 6.4 万辅助驾驶包，整车价格就已经来到 30 万以上。</li></ul><p>看完 Model Y 后，正好旁边就是理想零售中心，我顺路去试驾了理想 L7。<br />说实话，试驾之前并没有认真考虑过买理想。（我好像也是那个试驾就订车的人）</p><p>但坐进去的第一感觉就完全不一样了：<br />空间明显更大，坐姿更放松，不会有压迫感，整体取向就是偏舒适。</p><p>当时我对用车场景的考虑其实很简单——基本就是我一个人用车。<br />所以对我来说：</p><ul><li>L7 Max 的空间完全够用</li><li>不需要后排娱乐屏</li><li>自己在前排开车、用车就已经很舒服</li></ul><p>最终在 2024 年 12 月 14 日下定，12 月 16 日提车。</p><p>购车费用简单算一笔账：</p><p>33.18 w（车辆零售价）+ 0.67 w（首年保险）- 1.5 w（置换补贴）- 0.3 w（大客户公司积分）</p><p>最终落地价格为 <strong>32.05 w</strong>。</p><p>（另外给大家参考：今年新购保险花了4900，还是降了不少的，有的保险公司会给你降车损可以跟他要求一下）</p><hr /><h2>二、一年使用情况（里程、能耗与费用）</h2><p>用车周期为 2024.12.16 – 2025.12.16。</p><p>一年总行驶里程为 <strong>21,178.2 公里</strong>。</p><figure class="image ss-img-wrapper image_resized" style="width: 287px;"><img src="https://cdnfile.sspai.com/2026/01/08/4f1dbd498ef6b04386959ccee3c5b7aa.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>一年用车使用情况</figcaption></figure><h4>行驶方式拆分</h4><ul><li>纯电里程：18,292.4 公里，占比约 86%</li><li>增程（用油）里程：2,885.8 公里</li></ul><p>整体用车方式：城市通勤基本用电（冬季会利用增程器取暖），高速或长途主要用油。</p><h4>车辆基础数据</h4><ul><li>WLTC 纯电续航：191 公里</li><li>电池容量：42 kWh</li><li>油箱容量：60 L</li></ul><p>这一年整体算是轻度使用，最初选择增程，是因为前几年我长途较多，一年 4–5 万公里并不少见，但这一年出行明显减少，总里程只在 2 万公里左右。</p><p>目前的用车状态基本是：<br />油箱里长期只加少量油备用，日常城市用车几乎全部依靠纯电完成。</p><h4>一年补能费用统计</h4><ul><li>充电费用合计：4251.2元</li><li>加油费用合计：2,430 元</li></ul><p>补能总费用为 <strong>6,681.2 元</strong>。</p><h4>平均每公里能源成本</h4><p>在一年行驶 21,178 公里的情况下，实际能源成本如下：</p><p><strong>总平均能源成本</strong>：<br />6,681.2 ÷ 21,178.2 ≈ <strong>0.32 元 / 公里</strong></p><p><strong>纯电行驶平均成本</strong>：<br />4,251.2 ÷ 18,292.4 ≈ <strong>0.23 元 / 公里</strong></p><p><strong>用油（增程）行驶平均成本</strong>：<br />2,430 ÷ 2,885.8 ≈ <strong>0.84 元 / 公里</strong></p><p>整体来看，城市通勤用电、高速和长途用油，</p><p>因为自己有电站免费冲的电无法计算，所以在3,251.2其他平台总计的3251.2元上增加 1000元，我自己也没有安装家充，所以这样下来我的用电每公里费用在 0.23 元/km。</p><p>最开始充电的时候会刻意去寻找谷电时间充电，当看到十几块钱充满电的时候是有一种快乐感的，这种快乐感是比我免费充电还要快乐。但开久了之后就没有刻意去寻找了，需要的时候就去冲了，但也会避开峰值价格。</p><p>现在比较喜欢在谷时去<strong>理想5C</strong>充电，充电速度比其他电站快15分钟吧，整个充电过程比较流畅，从拔枪自动打开充电盖到即插即充，并且充电枪重量很轻。</p><figure class="image ss-img-wrapper image_resized" style="width: 397px;"><img src="https://cdnfile.sspai.com/2026/01/08/1416cb9f34ea310235e41993f03a4653.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><hr /><h2>三、辅助驾驶功能使用情况</h2><p>在买车的最初我就决定要买一辆带辅助驾驶的车辆，当时也正好是特斯拉的 FSD 传出要在国内落地的时候，最后会选择理想也是因为他也具有相应的辅助驾驶功能。</p><figure class="image ss-img-wrapper image_resized" style="width: 457px;"><img src="https://cdnfile.sspai.com/2026/01/08/2e57c34f2796565ffabde3a1a9784a47.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p>先说下 24款 L7 Max的车机配置吧：</p><ul><li>NVIDIA Orin-X *2 处理器（508 TOPS）</li><li>128线激光雷达</li><li>正前、侧前、侧后 800w像素摄像头 *2</li><li>正后 200w像素摄像头 *1</li><li>360环视 300w *4</li><li>前向毫米波雷达 *1、超声波雷达 *12</li><li>电容式感应方向盘、方向盘震动提醒</li><li>注意力提醒系统</li></ul><p>我使用辅助驾驶功能算不上频繁吧，一年下来辅助驾驶行驶里程在 2753 km，大部分的使用场景还是在高速道路上，辅助驾驶毕竟不是 L3 级别的全自动驾驶，所以基本上是在做监管者看着车辆行驶，随时预判道路上可能发生的各种情况。但整体使用下来辅助驾驶功能我是很满意，可以从城市、高速道路两个情况讲述。</p><h4>城市道路</h4><p>在城市道路中其实接管的次数并不少，但基本上都是效率接管，在城市道路中理想辅助驾驶在规避车辆、进行复杂路口转弯识别和安全右转的时候，速度会比较慢，我会自己觉得影响了其他车辆的行驶效率，会自行接管车辆行驶。但如果不考虑这些因素的话他基本是可以自己行驶完全程的，从地下车库的驶离再到社会道路的驾驶都是可以无缝衔接的。</p><figure class="image ss-img-wrapper image_resized" style="width: 555px;"><img src="https://cdnfile.sspai.com/2026/01/08/add370211b1947e2a5e936605b81f459.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p>这个是我最近一次的辅助驾驶行驶报告，现在车辆已经完全学习了家里地库的所有空间，他可以自己从我的车位行驶到社会道路上去，并且在发生错车等情况的时候也可以很好的应对，并且在城市道路行驶时你可以选择视觉监控，这样车辆不会强制你的手在方向盘上。</p> <p>这个视频是车辆在地库开启 NOA 行驶并窄道错车的视频</p><p>其实我觉得在VLA 的时候李想说过一个思路我是非常认可的，VLA之前的车辆在城市道路中总感觉走的急刹的也急，因为他们最开始做辅助驾驶的时候想的是让辅助驾驶更接近车主的驾驶习惯，但自己在开车和车辆在开车，驾驶员的主观感受是不一样的。但在 VLA 之后，他们让辅助驾驶的习惯是以最稳的驾驶员的模式进行训练，而不是要去模仿日常的车主。我觉得这个观点转变的很好，因为在开启辅助驾驶之后，其实驾驶员也相应地变成了一个乘客，我们自己开车和看别人开车的感受是不同的，自己开车在遇到需要决策的问题的时候我们是可以马上做出反应的，但启动了辅助驾驶之后我们是以一个监管员的身份是参与驾驶的，我们在看到危险信号出现时，会比自己驾驶更加担心问题的发生，只有辅助驾驶越来越稳才会使用的最安心。</p><h4>高速道路</h4><p>其实高速道路在正常行驶下相较于城市道路来说要省事的多，但车机对道路安全的识别反应要求更高，这一年也发生了很多辅助驾驶在高速上的车祸。我在高速上使用辅助驾驶的时候是会关闭车辆自主变道选项的，每一次车辆的变道都需要在我的确认下才可以变道，我觉得这样我是可以和车辆一起去判断道路安全的。</p><p>整体的高速辅助驾驶我觉得都是很好的，特别在连续区间测速道路上那这功能简直了，手还是要求在方向盘上方便及时接管，但在开启辅助驾驶之后我自己会做这几件事的：</p><ul><li>紧盯路面，一些微小障碍物、路坑车辆无法识别，需要人为判断躲避；</li><li>眼观前路，我觉得现阶段人对危险的预判会比车机的预判要早，在距离很远处发生的情况我们肉眼就可以识别到，这样可以及时接管车辆规避风险；</li><li>避免施工路段、标线复杂路段，及时接管；</li></ul><figure class="image ss-img-wrapper image_resized" style="width: 597px;"><img src="https://cdnfile.sspai.com/2026/01/08/e22282b7ac7d6c57299e9a0aa92f7128.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p>上面是选了几个高速的辅助驾驶报告截图，说句实话在长途高速驾驶开启辅助驾驶功能会有点无聊，没有了驾驶的过程，就只能盯紧道路。</p><p>这一年使用下来的感受，理想的辅助驾驶确实帮我分担了很多的驾驶任务，在道路环境优良的情况下是可以做到很靠谱的驾驶的，并且他的主动安全也可以帮我规避掉一些危险，所以整体下来是符合我对当下辅助驾驶的期望的。</p><hr /><h2>四、车内使用感受</h2><p>理想车内的体验我觉得不用多说，冰箱彩电大沙发嘛，四座座椅按摩，单人床、双人床模式，铂金音响等等，我就从我使用过的来说吧。</p><h4>彩电</h4><p>先说彩电吧，我是做软件开发出身的，所以自身还是比较在乎车内的交互体验，其他的车辆我只是轻微使用过，不像理想这样深度的使用，但从 UI 设计上我觉得理想是最好的，整体的设计舒适度给我拉满了，整体的设计布局和交互操作一套下来是非常流畅的。软件主流的音视频软件基本都涵盖了，出了那个无麦K歌模式让我天天能在车里嗨。但最近听歌也有个痛点，感觉现在没有啥好听的歌了，很无奈。</p><h4>冰箱</h4><p>用过但不咋用，反正耗电···</p><h4>沙发</h4><p>舒适度可以，按摩也有，但我不咋用，如果这玩意是选配的话我一定不会要。</p><h4>音响</h4><p>我觉得还行吧，Max 是铂金音响，听起来还不错，但总觉得缺了点什么，这个音响方面确实是小白，自己通过调音大师找车友分享的各种调音，但都是觉得差了点什么，但我自己也说不上来，等我自己再找找吧。</p><h4>车内空间</h4><p>空间是很宽裕的，而且L7是五座版本，后备箱的容量也是很大。要说形容空间怎么大，我就得说说我今年在车上睡了一个星期的经历了，今年因为出差任务要到一个发展比较落后的地方一个星期，住的只有那种二十几块钱一晚的“招待所”，床垫枕头都发黄的那种，个人有点接受不了所以我就睡在了车上，195m的山东大汉睡在车上完全够用，夏天一晚上开着空调基本上用3-4度电，真的是我今年为数不多的奇特经历了。今年家里也要添新成员了，我看到理想商城有合作车机控制的安全座椅，准备到时候下单一个来体验一下。</p><h2>五、理想配件</h2><p style="margin-left: 0px;">1、当时正好是星巴克和理想的购车活动，购车送积分和配件</p><ul><li>6000理想商城积分（价值 600）</li><li>不锈钢随行杯</li><li>便携式手冲套装（还没拆）</li><li>理想定制户外露营桌椅套装（还没拆）</li><li>户外车用放电枪（还没拆）</li></ul><p style="margin-left: 0px;">2、Nappa真皮清洁养护套装</p><p style="margin-left: 0px;">我车是橙色内饰，刚提车的时候比较爱惜嘛就用的比较多，有脏污的时候还挺好用的，后面用车也比较爱惜，然后也越来越懒所以用的也比较少了。</p><p style="margin-left: 0px;">3、户外收纳箱</p><figure class="image ss-img-wrapper image_resized" style="width: 390px;"><img src="https://cdnfile.sspai.com/2026/01/08/3178e982c33b84b07f2d751449c5ff67.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p style="margin-left: 0px;">这个我买来放在后备箱收纳东西的，还挺合适不大不小，取用也很方便。</p><p style="margin-left: 0px;">4、车内悬浮桌板</p><figure class="image ss-img-wrapper image_resized" style="width: 434px;"><img src="https://cdnfile.sspai.com/2026/01/08/80f9f4e2abfda43677ddb33615b69ee5.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p>刚开始买来挺方便的，但主要使用场景是副驾驶放东西，当饭桌，我也尝试过用这个桌板放电脑办公，简单能用但长时间用电脑过沉会稍微偏一点</p><p>5、车载充电拓展坞</p><figure class="image ss-img-wrapper image_resized" style="width: 339px;"><img src="https://cdnfile.sspai.com/2026/01/08/15b5f35ba96a8d4410232d4aefcb5434.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p>这个挺实用的，官方的配件不用太担心安全问题，两侧都有抽拉typec充电线，可以拉到后排使用，中间也配了USBA/C接口各一个，并且还贴心的带了一个 typec 转 Lightning转换器。</p><p>6、单人充气床垫</p><p>这个是在我在车上睡觉的那一个星期激情下单的，但我就用了一晚上，有点高不太适应就没再用过了，我买完半个月就出新款了，也没理由再买一个了，所以就闲置了。</p><p>7、官方定制玻璃水</p><p>这个我觉得也是很值得推荐的，反正用了这个雨刮能刮到的地方没有油膜。</p><p>8、用车服务包</p><figure class="image ss-img-wrapper image_resized" style="width: 323px;"><img src="https://cdnfile.sspai.com/2026/01/08/5af9483b1f83c0df2283fa72e79f29a5.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p>这个我觉得还可以吧，我也是最近才买的，12月的时候进行了一次小保养花了我799，然后想起来这个服务包是带增程器保养、空调滤芯、无限流量、取送车服务的，正好我的空调滤芯又又臭了，我就买了这个 1399，前三项服务加在一起就基本上差不多了，所以还是可以的。但我真的想吐槽下空调滤芯，我已经换了第二个了，第一次是25年5月换的，这次是12月换的，我不在车里抽烟，但总是半年莫名其妙的就臭了。</p><h2>六、其他</h2><h4>能耗表现</h4><p>在非冬季、不刻意省电的情况下，城市用车的平均电耗基本在<br />16–18 kWh / 100km。</p><p>充满电后连续使用、不长时间停放，实际可行驶里程在 170 公里左右。</p><p>如果充满电后车辆长时间停放，哨兵模式和车辆待机会消耗一定电量，续航下降十几公里属于正常现象。</p><p>高速行驶时，纯电续航一般不到 100 公里，高速油耗基本在 9–10 L / 100km。对于一台尺寸和重量都不小的 SUV 来说，这个表现我个人是可以接受的。</p><h4>冬季体验</h4><p>山东的冬天不算极寒，但气温也不高。<br />冬季纯电行驶时，电耗会上升到 20–22 kWh / 100km。</p><p>后来我形成了一个比较舒服的用车习惯：在冬天不刻意纠结用油还是用电。</p><p>冷车启动、低温环境下，让增程器提前介入，利用发动机水温余热制热，可以明显降低热泵空调的负担，从而减少电耗。这一点对北方用户来说非常友好。</p><hr /><h2>七、总结</h2><p>回看这一年的用车体验，理想 L7 Max 并不是一台追求极致性能或参数的车，<br />但它非常清楚自己的定位：舒适、省心、好用。</p><p>对我来说，它在以下几个方面非常契合我的需求：</p><ul><li>城市用电（电池大点可能更好）、高速用油，使用方式灵活</li><li>冬季增程优势明显，对北方用户友好</li><li>空间与舒适度对高个子用户非常友好</li><li>辅助驾驶在合适场景下确实能有效减轻驾驶负担</li></ul><p>上面总结是 GPT 帮我写的，感觉像我在恰饭，说实话这一年这车除了出了焕新版、车价跌了跌、空调滤芯臭了又臭其他的方面还是很满意的，是一款符合我当下需求的好车。</p><p>先写到这吧，看了十多年少数派，第一次分享的我，都是些我的主观感受，如果有问题请大家指正。</p><p>&nbsp;</p>
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://sspai.com/post/105111</id>
            <title>如何不用空格打字——顶功类输入法简介</title>
            <link>https://sspai.com/post/105111</link>
            <guid isPermaLink="false">https://sspai.com/post/105111</guid>
            <pubDate></pubDate>
            <updated>Mon, 05 Jan 2026 05:48:11 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p style="margin-left: 0px;"><strong>Matrix 首页推荐</strong>&nbsp;</p><p style="margin-left: 0px;"><a href="https://sspai.com/matrix">Matrix</a>&nbsp;是少数派的写作社区，我们主张分享真实的产品体验，有实用价值的经验与思考。我们会不定期挑选 Matrix 最优质的文章，展示来自用户的最真实的体验和观点。&nbsp;</p><p style="margin-left: 0px;">文章代表作者个人观点，少数派仅对标题和排版略作修改。</p><hr /><p>又名：为了不患腱鞘炎，我学了一个追求极致码长的小众输入法</p><p>如果您从未接触过字形输入法，可先阅读北鸮的这两篇文章：<a href="https://sspai.com/post/77340">尝试了七种形码输入法后，我想聊聊在 2022 年用五笔这件事</a>、<a href="https://sspai.com/post/83376">为了打字更爽，我学了一个追求极致性能的小众输入法</a>。本人去年的拙作<a href="https://sspai.com/post/90816">如何制作一款字形输入法</a>里也作了简短介绍，朱宇浩所作<a href="https://shurufa.app/docs/concepts.html">琼林撷英</a>亦可作为百科全书速查。</p><p>关于本人：聊天打字用<a href="https://github.com/xkinput/Rime_JD">星空键道</a>，书面打字用<a href="https://shurufa.app/docs/ming.html">日月</a>，打单速度 80 字/分钟。之前浅学过<a href="https://flypy.com/">小鹤音形</a>、<a href="https://www.chinesecj.com/5cjbook">仓颉五代</a>和<a href="https://tiger-code.com/">虎码</a>，因需求不同而放弃。在转日月之前已使用近三年<a href="http://xumax.cn/">徐码</a>，因手感（Z 键频率）问题放弃。</p><h2>不使用空格键的两种方式</h2><p>以 86 五笔为例，单字全码码长要么是三要么是四，在<strong>开启最大码长顶屏，关闭唯一候选自动上屏</strong>时，仅三码字上屏需要空格。输入法为提高效率还使用简码，所有简码上屏都需要空格。在只打一二简的情况下，使用<a href="https://faculty.blcu.edu.cn/xinghb/zh_CN/article/167473/content/1437.htm">北语邢红兵教授的字频表</a><sup class="ss-footnote" href="" title="如无特殊说明，本文字频数据均使用该表。">1</sup>加权 <a href="https://github.com/rime/rime-wubi">86 五笔码表</a>，65%的情况需要打空格，即便只打一简也有高达 47%的情况，无疑对腱鞘炎患者非常不友好。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/03/c205e86a9dedc72753680b6a8cbba6aa.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>86 五笔平均四次击键中有一次空格</figcaption></figure><p>那么，有没有不需要空格的输入法？2005 年，戴石麟带着论文<a href="https://kns.cnki.net/kcms2/article/abstract?v=3uoqIhG8C475KOm_zrgu4h_jQYuCnj_co8vp4jCXSivDpWurecxFtLD2kD6nzekFVwkQBgFBS14SR5j5JmVipd_yIdixRehk">《汉字编码输入法研究》</a>横空出世，提出首款可脱离空格打字<sup class="ss-footnote" href="" title="可脱离空格打字，并不代表不能打空格上屏。">2</sup>的顶功输入法。</p><p>以<a href="https://sbxlm.github.io/">声笔简码</a>为例，顶功输入法通常将常用于汉字编码的 26 个字母分为两个集合——B:{aeiou} 与 A:{bpmfdtnlgkhjqxzcsrywv}——即元音字母和辅音字母，并规定汉字编码只能以 A 中字母开头，可表示为 A、AB、ABB、ABBB。当用户输入 AA、ABA 等不存在的编码时，软件就知道上一字已经结束，自动将其顶上屏。由于在输入过程中消除了空格，<strong>汉字的实际编码等同于原始编码</strong>，这便是顶功码的第一种定义。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/03/762a15edd8b6cd249c431c87fabc3ef3.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>声笔系列码宣传图</figcaption></figure><p>为什么是 21:5？汉字可表示为横竖撇点折五种笔画，而字母中元音字母也有五个，所以 21:5 是<strong>易学性最好</strong>的分类法。当然 20:6、16:12 的分割的顶功码也是存在的，详见<a href="https://ding.tansongchen.com/" target="_blank">顶功集萃</a>。</p><p>如果我们将空格（后文表示为 _）视为 B 集合的唯一元素，即 B:{_}, A:{a-y}，则五笔的实际编码可表示为 AB、AAB、AAAB、AAAA。仔细观察会发现<strong>任意编码都不是其他编码的前缀</strong>，像这样的编码我们称为<strong>前缀码</strong>。而观察前文声笔码的表示方式，可发现顶功码并不满足前缀码的条件，故<strong>非前缀码</strong>是顶功码的第二种定义。</p><p>对于五笔这类 B 集合只含空格的前缀码，又可称作<strong>空格前缀码</strong>。由于空格前缀码的简码必带空格，在优化简码效率的同时，空格的频率也会越来越高：以<a href="https://shurufa.app/docs/joy.html">卿云</a>为例，光只打一简就高达 67%，算上避重三简甚至能到达 90%！</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/03/487a35c82cf403000a8ccd36a20c4cad.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>卿云，越优化越多的空格</figcaption></figure><p>有没有通用的方法降低空格前缀码的空格频率？</p><p>一是整句输入，又叫智能联想。原理很简单，只要词库够大，语言模型就能自动分割人类无法分割的编码，相当于外置大脑，目前市面上的主流输入法软件（某狗、某度）都自带此方法。但对于 RIME 这类离线输入法，即便是打单用户也要部署一个超大词库。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/03/e4e23d42ee88a1b3404ef0348f751354.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption><a href="https://github.com/Litles/rime-xingma-sentence">三码整句</a></figcaption></figure><p>二是顶功化改造。我们观察到二简的占空格频率的 20 %，所以只要将其改造成二码顶就可以大幅提高效率。此时编码方式为 AA、AAAB、AAAAB，由于不存在 AAAAA 编码，用户每打出第五个 A，前两个 A 的简码字就会自动上屏，相当于用四根字的码长来换取二简字码长。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/03/b7a1ebd2de8460e17dcd7567a98b8037.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption><a href="https://github.com/Ace-Who/rime-xuma">徐码五二顶</a></figcaption></figure><p>2025 年，朱宇浩提出了一个新想法：如果前缀码的 B 集合不使用空格，改用与声笔相同的 aeiou，同样能满足顶功码的第一种定义，即<a href="https://ding.tansongchen.com/theory/definition#%E5%89%8D%E7%BC%80%E7%A0%81%E4%B8%8E%E9%A1%B6%E5%8A%9F%E7%A0%81%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7">无空前缀码与顶功码在数学上等价</a>，可视为广义顶功码。</p><h2>优势与劣势</h2><h3>顶功分析</h3><p>由于不用打空格，顶功码的简码效率（单字简码缩减的实际码长）比前缀码要高一些：五笔实际码长恒定为四（四码定长，以下简称四定），可得 25 个二码上屏一简字所减短的实际码长为(4-2)x0.2590 = 0.518；声笔简码同为四码定长，21 个一码上屏一简字效率为 (4-1)x0.2381 = 0.7143。在缺少 4 个一简的情况下，声笔的一简效率比五笔多 0.1963，这便是顶功的优势。当然这是假定简码只按字频无理设置的情况，五笔的实际一简效率为 0.41，声笔实际一简效率为 0.61。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/03/bf904404ccb73b720b10af979dbb5bed.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p>注意：简码效率（越大越好）只能在定长输入法之间比较，最大码长不同的输入法之间须直接比较动态码长（越小越好）。</p><p>争议：空格键的输入方式与其他按键不同——一是拇指不用移动，二是有拇指作为最有力的手指，敲击速度也更快。空格键增加的实际码长与其他编码增加的码长有极大的手感差异，故而顶功缩减码长带来的好处并没有数据那么大。</p><p>如此大的优势，自然不会是天上掉下的馅饼。由于声笔简码的后三位编码只能在 B 集合中取，声笔简码的可用全码空间（可能的编码组合）为 21x5^3=2625，就算加上简码的 21+21x5+21x5^2 也只有 3276，连通用规范汉字表的 8105 个汉字都无法完全容纳，重码重上天！与之相对，只要 ，五笔的全码空间为 25^3+25^4=406250。如此悬殊的数据差距，注定声笔简码实际上无法打单，只能与简拼结合作为声笔系列码的入门方案。</p><p>注意到，B 集合是声笔简码输入法空间如此之小的罪魁祸首，所以要增加全码空间有几种思路——扩大全集 U（即 AUB）、扩大 B 集合、减少编码中 B 的数量、增加最大码长。</p><p>扩大全集 U：让更多的键位参与编码，比如 30 键输入法。</p><p>增加最大码长：每加一位就乘五，力大砖飞。</p><p>扩大 B 集合：编码空间为 (26-B)x B^3，运用高中数学知识可知编码空间在 0-19 之间单调递增。但此方法的问题是易学性要降低，而且五笔画把折拆成顺时针和逆时针变成六笔画就没得再加了。</p><p>改变编码方式：如果我们让编码第二位也能取 A，表示 AABB、ABBB 如何？25^2x5^2=15625，能容纳所有的通规字，这便是<a href="https://sbxlm.github.io/sbfd/">声笔飞单</a>的编码方式。</p><p>声笔飞单的最短上屏码长为 2（即最后一个 A 在编码中的位置），称为二码顶；同理，声笔简码为一码顶。二码顶能自动上屏的无空最短编码是 AA/AB，实际二简效率为 0.992，而五笔的实际一二简效率为 0.776，但声笔使用特殊二简 AB 的代价是简全不一（简码不是全码的前缀）。如果能接受再打 20% 的空格一简，声笔飞单最终的一二简效率为 1.4 左右。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/03/2c4331ac36b4176ca7881ef0e1c309c2.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /></figure><p>有二码顶自然就有三码顶、四码顶……但人的记忆力和简码设置均存在边际效应，一二简共 21x27=567 个简码其实就是初学者的极限了。所以我们可以给出采用声笔一二简的动态码长公式 L-max(L-N,L-2)x0.2048-max(L-N,L-3)x0.2720-0.2240x(L-2) 可用全码空间公式为 21^x5^{L-N}，其中L=最大码长，N=最短上屏码长。计算得出下表：</p><figure class="table"><table><thead><tr><th>最大码长</th><th>最短上屏码长</th><th>动态码长</th><th>全码空间</th><th>空格频率</th></tr></thead><tbody><tr><td>4</td><td>2</td><td>2.5984</td><td>11025</td><td>0.2048</td></tr><tr><td>4</td><td>3</td><td>2.8704</td><td>46305</td><td>0.4768</td></tr><tr><td>5</td><td>1</td><td>3.5088<br /><br />注：一码顶没有 AA 二简，如果算上 ABB 三简码长为 2.9 左右<br />&nbsp;</td><td>13125</td><td>0</td></tr><tr><td>5</td><td>2</td><td>2.8976</td><td>55125</td><td>0.2048</td></tr><tr><td>5</td><td>3</td><td>3.1696</td><td>231525</td><td>0.4768</td></tr><tr><td>6</td><td>2</td><td>3.1968</td><td>275625</td><td>0.2048</td></tr><tr><td>6</td><td>3</td><td>3.4688</td><td>1157625</td><td>0.4768</td></tr></tbody></table></figure><p>不难发现，四定二码顶就已经满足常用字集的最短上屏码长，三码顶虽然提升四倍的编码空间，但码长由于 AA 二简要打空格反而下降，而这编码空间依旧无法满足全字集 101984 个汉字。<br />又因为四定空格前缀的动态码长在 3±0.1，六定三码顶负收益首先排除，剩下的六定二码顶 ABB 简相比五定三码顶有更高的简码效率，同时全码空间也更大，六定二码顶胜出。</p><p><strong>结论：在 21:5 的分类下，顶功要么是满足常用字集的四定二码顶，要么是满足全字集的六定二码顶。</strong></p><p>本人用的键道就是六定二码顶。</p><h3>无空前缀分析</h3><p>假定存在一个四定无空前缀码，总编码空间为 AAAA、AAAB、AAB、AB、B=243101，虽然只有空格前缀码的一半空间，但对于目前汉字的总量已经够用，这就是<a href="https://shurufa.app/docs/ling.html">宇浩灵明</a>的编码方式。当然灵明由于取主副根，部分 AB 形式的编码为全码，实际为四不定（最大码长为 4 的不定长编码）。</p><p>虽然同最大码长的无空前缀比顶功重码更低，但由于无空前缀码在不打空格的情况下无法使用 AA 简，必须记忆 AAB 形式的三简，对人的记忆负担较大。</p><p>可算出灵明的简码效率为 0.320179+0.232354+0.133855=0.6863。但由于是四不定，灵明的全码动态码长约为 3.6，最后得出的实际动态码长约为 3。</p><figure class="image ss-img-wrapper"><img src="https://cdnfile.sspai.com/2026/01/03/790133e576377a7924b55ed73b2bdcde.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" /><figcaption>灵明简码效率</figcaption></figure><p>由于前缀码的简码恒定为 B、AB、AAB，当最大码长 L 增大时，需记忆的简码更多，但动态码长不会再提升，此处就不再列表作比。<strong>直接说结论：不定无空前缀码最大码长要么是四要么是五，优化方向为减小需记忆的简码量，优化方法为设置主副根。</strong></p><p>自无空前缀的概念问世，目前已有日月（大乱小音托）、灵明（大乱小音托主副根）、<a href="https://hertz-hwang.github.io/hao/gen-sy.html">松烟</a>（纯乱）、<a href="https://input.tansongchen.com/snow-qingyun/">清韵</a>（全音托主副根）四种方案，各位读者如果对常见输入法的空格占比有所顾虑，不妨一试。</p><p>不过顶功类方案还有一个问题：目前仅 RIME 能较好支持，如果日常打字环境不能装就完蛋了。</p><h2>闲话：输入法宣传之道</h2><p>比如虎测评网的表里有个大跨排，因为虎码算法专门优化过；</p><p>比如宇浩测评网表里有繁体数据，因为只有他在做简繁通打；</p><p>比如声笔宣传实际码长低得离谱，但是出满二三简且不出全；</p><p>比如三郑宣传动态选重率 0.15%，但其实智能选重谁都能开。</p><p>虽然之前曾说一切需求𣅜不重要，但搞清数据的条件还是很重要的。</p><p>另：之前看到有人说简繁通打要多记一倍字根，令人莞尔。实际上，以宇浩拆分为例，一共只有 22 个繁体专用字根（鳥烏魚馬風來車長門鬥齒飛見貝鹵僉韋咼黽）。</p><p style="margin-left: 0px;">&gt; 关注&nbsp;<a href="https://www.xiaohongshu.com/user/profile/63f5d65d000000001001d8d4" target="_blank">少数派小红书</a>，感受精彩数字生活 🍃</p><p style="margin-left: 0px;">&gt; 实用、好用的 <a href="https://sspai.com/mall">正版软件</a>，少数派为你呈现 🚀</p>
                ]]>
            </content:encoded>
        </item>
        
    </channel>
</rss>